---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2022/01/10 16:49
--- Describe:
---

local math  = math
local acos	= math.acos
local sqrt 	= math.sqrt
local max 	= math.max
local min 	= math.min
local clamp = Mathf.Clamp
local cos	= math.cos
local sin	= math.sin
local abs	= math.abs
local sign	= Mathf.Sign
local setmetatable = setmetatable
local rawset = rawset
local rawget = rawget
local type = type

local rad2Deg = 57.295779513082
local deg2Rad = 0.017453292519943

---@class Vector3 : table
Vector3 = {}
Vector3.count = 0

Vector3.__index = function(_table, _key)
	if _key == "magnitude" then
		return Vector3.Magnitude(_table)
	elseif _key == "normalized" then
		return Vector3.Normalize(_table)
	elseif _key == "sqrMagnitude" then
		return Vector3.SqrMagnitude(_table)
	else
		return rawget(Vector3, _key)
	end
end

Vector3.__call = function(_tab,_x, _y, _z)
	local _tab = {x = _x or 0, y = _y or 0, z = _z or 0}
	setmetatable(_tab, Vector3)
	return _tab
end

-- 
function Vector3.New(_x, _y, _z)
	Vector3.count = Vector3.count + 1
	
	local _tab = {x = _x or 0, y = _y or 0, z = _z or 0}
	setmetatable(_tab, Vector3)
	return _tab
end

local _new = Vector3.New


function Vector3.Set(v,x,y,z)
	--if nil == v then return end
	v.x = x or 0
	v.y = y or 0
	v.z = z or 0
end

function Vector3.Get(v)
	--if nil == v then return 0,0,0 end
	return v.x, v.y, v.z
end

function Vector3.Clone(v)
	--if nil == v then return setmetatable({x = 0, y = 0, z = 0}, Vector3) end
	return setmetatable({x = v.x, y = v.y, z = v.z}, Vector3)
end

---@public
function Vector3.Copy(v1, v2)
	v1.x = v2.x
	v1.y = v2.y
	v1.z = v2.z
	return v1
end

function Vector3.Distance(va, vb)
	return sqrt((va.x - vb.x)^2 + (va.y - vb.y)^2 + (va.z - vb.z)^2)
end

function Vector3.SqrDistance(va, vb)
	return (va.x - vb.x)^2 + (va.y - vb.y)^2 + (va.z - vb.z)^2
end

function Vector3.Dot(lhs, rhs)
	return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z
end

function Vector3.Cross(lhs, rhs, _receiver)
	local _ret = _receiver or Vector3.zero_local()
	
	local x = lhs.y * rhs.z - lhs.z * rhs.y
	local y = lhs.z * rhs.x - lhs.x * rhs.z
	local z = lhs.x * rhs.y - lhs.y * rhs.x
	
	_ret:Set(x, y, z)
	return _ret
end


function Vector3.Lerp(from, to, t)	
	t = clamp(t, 0, 1)
	return _new(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t)
end

-- 非截断式lerp wth添加
function Vector3.LerpUnclamped(from, to, t)
	t = clamp(t, 0, 100)
	return _new(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t)
end

function Vector3.Max(lhs, rhs)
	return _new(max(lhs.x, rhs.x), max(lhs.y, rhs.y), max(lhs.z, rhs.z))
end

function Vector3.Min(lhs, rhs)
	return _new(min(lhs.x, rhs.x), min(lhs.y, rhs.y), min(lhs.z, rhs.z))
end

function Vector3.Normalize(v, _receiver)
	local x,y,z = v.x, v.y, v.z
	local num = sqrt(x * x + y * y + z * z)	
	
	if num > 1e-5 then
		local _fix = 1/num
		if _receiver then
			_receiver.x = x * _fix
			_receiver.y = y * _fix
			_receiver.z = z * _fix
			return _receiver
		end
		return setmetatable({x = x * _fix, y = y * _fix, z = z * _fix}, Vector3)
    end
	  
	if _receiver then
		_receiver.x = 0
		_receiver.y = 0
		_receiver.z = 0
		return _receiver
	end
	return setmetatable({x = 0, y = 0, z = 0}, Vector3)
end

---@public
function Vector3:SetNormalize()
	local num = sqrt(self.x * self.x + self.y * self.y + self.z * self.z)
	
	if num > 1e-5 then
		local _fix = 1 / num
        self.x = self.x * _fix
		self.y = self.y * _fix
		self.z = self.z * _fix
    else    
		self.x = 0
		self.y = 0
		self.z = 0
	end 

	return self
end

---检查两个点足够接近
---@param _v1 Vector3
---@param _v2 Vector3
---@param _dis number 距离
function Vector3.CloseEnough(_v1, _v2, _dis)
	if not _v1 or not _v2 then return false end
	_dis = _dis or 1e-10
	local _x = _v1.x - _v2.x
	local _y = _v1.y - _v2.y
	local _z = _v1.z - _v2.z
	return _x * _x + _y * _y + _z * _z <= _dis * _dis
end

function Vector3.Length(v)
	return sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
end

function Vector3.Magnitude(v)
	return sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
end
	
---@public
function Vector3:SqrMagnitude()
	return self.x * self.x + self.y * self.y + self.z * self.z
end

function Vector3:ClampMagnitude(maxLength)	
	if self:SqrMagnitude() > (maxLength * maxLength) then    
		self:SetNormalize()
		self:Mul(maxLength)        
    end
	
    return self
end

local dot = Vector3.Dot

---@public
function Vector3.Angle(from, to, _hasBeenNormalized)
	if _hasBeenNormalized then
		return acos(clamp(dot(from, to), -1, 1)) * rad2Deg
	else
		return acos(clamp(dot(from:Normalize(), to:Normalize()), -1, 1)) * rad2Deg
	end
end

function Vector3.MoveTowards(current, target, maxDistanceDelta)	
	local delta = target - current	
    local sqrDelta = delta:SqrMagnitude()
	local sqrDistance = maxDistanceDelta * maxDistanceDelta
	
    if sqrDelta > sqrDistance then    
		local magnitude = sqrt(sqrDelta)
		
		if magnitude > 1e-6 then
			delta:Mul(maxDistanceDelta / magnitude)
			delta:Add(current)
			return delta
		else
			return current:Clone()
		end
    end
	
    return target:Clone()
end

function ClampedMove(lhs, rhs, clampedDelta)
	local delta = rhs - lhs
	
	if delta > 0 then
		return lhs + min(delta, clampedDelta)
	else
		return lhs - min(-delta, clampedDelta)
	end
end

local overSqrt2 = 0.7071067811865475244008443621048490

function OrthoNormalVector(vec)
	local res = _new()
	
	if abs(vec.z) > overSqrt2 then			
		local a = vec.y * vec.y + vec.z * vec.z
		local k = 1 / sqrt (a)
		res.x = 0
		res.y = -vec.z * k
		res.z = vec.y * k
	else			
		local a = vec.x * vec.x + vec.y * vec.y
		local k = 1 / sqrt (a)
		res.x = -vec.y * k
		res.y = vec.x * k
		res.z = 0
	end
	
	return res
end

function Vector3.RotateTowards(current, target, maxRadiansDelta, maxMagnitudeDelta)
	local len1 = current:Magnitude()
	local len2 = target:Magnitude()
	
	if len1 > 1e-6 and len2 > 1e-6 then	
		local from = current / len1
		local to = target / len2		
		local cosom = dot(from, to)
				
		if cosom > 1 - 1e-6 then		
			return Vector3.MoveTowards (current, target, maxMagnitudeDelta)		
		elseif cosom < -1 + 1e-6 then		
			local axis = OrthoNormalVector(from)						
			local q = Quaternion.AngleAxis(maxRadiansDelta * rad2Deg, axis)	
			local rotated = q:MulVec3(from)
			local delta = ClampedMove(len1, len2, maxMagnitudeDelta)
			rotated:Mul(delta)
			return rotated
		else		
			local angle = acos(cosom)
			local axis = Vector3.Cross(from, to)
			axis:SetNormalize ()
			local q = Quaternion.AngleAxis(min(maxRadiansDelta, angle) * rad2Deg, axis)			
			local rotated = q:MulVec3(from)
			local delta = ClampedMove(len1, len2, maxMagnitudeDelta)
			rotated:Mul(delta)
			return rotated
		end
	end
		
	return Vector3.MoveTowards(current, target, maxMagnitudeDelta)
end
	
function Vector3.SmoothDamp(current, target, currentVelocity, smoothTime,maxSp,dt)
	local maxSpeed = Mathf.Infinity
	local deltaTime = Time.deltaTime
	if maxSp ~= nil and maxSp > 0 then
		maxSpeed = maxSp
	end
	if dt ~= nil then
		deltaTime = dt
	end
    smoothTime = max(0.0001, smoothTime)
    local num = 2 / smoothTime
    local num2 = num * deltaTime
    local num3 = 1 / (1 + num2 + 0.48 * num2 * num2 + 0.235 * num2 * num2 * num2)    
    local vector2 = target:Clone()
    local maxLength = maxSpeed * smoothTime
	local vector = current - target
    vector:ClampMagnitude(maxLength)
    target = current - vector
    local vec3 = (currentVelocity + (vector * num)) * deltaTime
    currentVelocity = (currentVelocity - (vec3 * num)) * num3
    local vector4 = target + (vector + vec3) * num3	
	
    if Vector3.Dot(vector2 - current, vector4 - vector2) > 0 then    
        vector4 = vector2
        currentVelocity:Set(0,0,0)
    end
	
    return vector4, currentVelocity
end	
	
function Vector3.Scale(a, b)
	local x = a.x * b.x
	local y = a.y * b.y
	local z = a.z * b.z	
	return _new(x, y, z)
end
	
function Vector3.Equals(v1, v2)
	return v1.x == v2.x and v1.y == v2.y and v1.z == v2.z
end

function Vector3.EqualsXYZ(v, x, y, z)
	if x == v.x and y == v.y and z == v.z then
		return true
	end
	return false
end
	
function Vector3.IsZero(v)
	if 0 == v.x and 0 == v.y and 0 == v.z then
		return true
	end
	return false
end

function Vector3.Reflect(inDirection, inNormal)
	local num = -2 * dot(inNormal, inDirection)
	inNormal = inNormal * num
	inNormal:Add(inDirection)
	return inNormal
end

	
function Vector3.Project(vector, onNormal, _receiver)
	_receiver = _receiver or Vector3.New()
	
	local num = onNormal:SqrMagnitude()
	
	if num < 1.175494e-38 then
		Vector3.Set(_receiver, 0, 0, 0)
		return _receiver
	end
	
	local num2 = dot(vector, onNormal)
	Vector3.Copy(_receiver, onNormal)
	Vector3.MulNumber(_receiver, num2/num, _receiver)
	return _receiver
end
	
function Vector3.ProjectOnPlane(vector, planeNormal, _receiver)
	_receiver = _receiver or Vector3.New()
	Vector3.Project(vector, planeNormal, _receiver)
	Vector3.MulNumber(_receiver, -1)
	Vector3.Add(_receiver, vector, _receiver)
	return _receiver
end

function Vector3.Slerp(from, to, t)

	local omega, sinom, scale0, scale1

	if t <= 0 then
		return from:Clone()
	elseif t >= 1 then
		return to:Clone()
	end

	local v2 	= to:Clone()
	local v1 	= from:Clone()
	local len2 	= to:Magnitude()
	local len1 	= from:Magnitude()
	v2:Div(len2)
	v1:Div(len1)

	local len 	= (len2 - len1) * t + len1
	local cosom = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z

	if cosom > 1 - 1e-6 then
		scale0 = 1 - t
		scale1 = t
	elseif cosom < -1 + 1e-6 then
		local axis = OrthoNormalVector(from)
		local q = Quaternion.AngleAxis(180.0 * t, axis)
		local v = q:MulVec3(from)
		v:Mul(len)
		return v
	else
		omega 	= acos(cosom)
		sinom 	= sin(omega)
		scale0 	= sin((1 - t) * omega) / sinom
		scale1 	= sin(t * omega) / sinom
	end

	v1:Mul(scale0)
	v2:Mul(scale1)
	v2:Add(v1)
	v2:Mul(len)
	return v2
	
end

---@public
function Vector3.MulVec3(v1, v2, _receiver)
	_receiver = _receiver or v1
	
	_receiver.x = v1.x * v2.x
	_receiver.y = v1.y * v2.y
	_receiver.z = v1.z * v2.z
	
	return _receiver
end

-- 
function Vector3.MulNumber(v, q, _receiver)
	_receiver = _receiver or v
	_receiver.x = v.x * q
	_receiver.y = v.y * q
	_receiver.z = v.z * q
	return _receiver
end

---@public
function Vector3.Mul(v, q, _receiver)
	if type(q) == "number" then
		return Vector3.MulNumber(v, q, _receiver)
	elseif q.w == nil then
		return Vector3.MulVec3(v, q, _receiver)
	else
		return Vector3.MulQuat(v, q, _receiver)
	end
end

---@public
function Vector3.Div(v, d, _receiver)
	_receiver = _receiver or v
	local _fix = 1 / d
	
	_receiver.x = v.x * _fix
	_receiver.y = v.y * _fix
	_receiver.z = v.z * _fix
	
	return _receiver
end

---@public
function Vector3.Add(v1, v2, _receiver)
	_receiver = _receiver or v1
	
	_receiver.x = v1.x + v2.x
	_receiver.y = v1.y + v2.y
	_receiver.z = v1.z + v2.z
	
	return _receiver
end

---@public
function Vector3.Sub(v1, v2, _receiver)
	_receiver = _receiver or v1
	
	_receiver.x = v1.x - v2.x
	_receiver.y = v1.y - v2.y
	_receiver.z = v1.z - v2.z
	
	return _receiver
end

function Vector3.MulQuat(v, quat, _receiver)
	_receiver = _receiver or v
	
	local num 	= quat.x * 2
	local num2 	= quat.y * 2
	local num3 	= quat.z * 2
	local num4 	= quat.x * num
	local num5 	= quat.y * num2
	local num6 	= quat.z * num3
	local num7 	= quat.x * num2
	local num8 	= quat.x * num3
	local num9 	= quat.y * num3
	local num10 = quat.w * num
	local num11 = quat.w * num2
	local num12 = quat.w * num3

	local x = (((1 - (num5 + num6)) * v.x) + ((num7 - num12) * v.y)) + ((num8 + num11) * v.z)
	local y = (((num7 + num12) * v.x) + ((1 - (num4 + num6)) * v.y)) + ((num9 - num10) * v.z)
	local z = (((num8 - num11) * v.x) + ((num9 + num10) * v.y)) + ((1 - (num4 + num5)) * v.z)

	Vector3.Set(_receiver, x, y, z)
	return _receiver
end

---@param from Vector3
---@param to Vector3
---@param axis Vector3
---@param _vector3Pool Vector3Pool
function Vector3.AngleAroundAxis (from, to, axis, _vector3Pool)
	
	local _v3FromInAxis = _vector3Pool:Pop()
	Vector3.Project(from, axis, _v3FromInAxis)
	local _v3FromTmp = _vector3Pool:Pop()
	Vector3.Sub(from, _v3FromInAxis, _v3FromTmp)

	local _v3ToInAxis = _vector3Pool:Pop()
	Vector3.Project(to, axis, _v3ToInAxis)
	local _v3ToTmp = _vector3Pool:Pop()
	Vector3.Sub(to, _v3ToInAxis, _v3ToTmp)

	local angle = Vector3.Angle (from, to)
	local _v3FromToDir = _vector3Pool:Pop()
	Vector3.Cross(from, to, _v3FromToDir)
	local _fFinalAngle = angle * (Vector3.Dot (axis, _v3FromToDir) < 0 and -1 or 1)

	_vector3Pool:Push(_v3FromInAxis)
	_vector3Pool:Push(_v3FromTmp)
	_vector3Pool:Push(_v3ToInAxis)
	_vector3Pool:Push(_v3ToTmp)
	_vector3Pool:Push(_v3FromToDir)
	return _fFinalAngle
	
	--from = from - Vector3.Project(from, axis)
	--to = to - Vector3.Project(to, axis) 	    
	--return angle * (Vector3.Dot (axis, Vector3.Cross (from, to)) < 0 and -1 or 1)
end


Vector3.__tostring = function(self)
	if self.x ~= nil and self.y ~= nil and self.z ~= nil then
		return "["..self.x..","..self.y..","..self.z.."]"
	else
		return "vector3 contain nil"
	end
end

Vector3.__div = function(va, d)
	return _new(va.x / d, va.y / d, va.z / d)
end

Vector3.__mul = function(va, d)
	if type(d) == "number" then
		return _new(va.x * d, va.y * d, va.z * d)
	elseif d.w == nil then
		return _new(va.x * d.x, va.y * d.x, va.z * d.x)
	else
		local vec = va:Clone()
		vec:MulQuat(d)
		return vec
	end	
end

Vector3.__add = function(va, vb)
	return _new(va.x + vb.x, va.y + vb.y, va.z + vb.z)
end

Vector3.__sub = function(va, vb)
	return _new(va.x - vb.x, va.y - vb.y, va.z - vb.z)
end

Vector3.__unm = function(va)
	return _new(-va.x, -va.y, -va.z)
end

Vector3.__eq = function(a,b)
	local v = a - b
	local delta = v:SqrMagnitude()
	return delta < 1e-10
end

------------------------------------------------------------------------------------------------------------------------

local _global_forward = _new(0,0,1)
Vector3.forward = _global_forward

function Vector3.forward_global()
	return _global_forward;
end

function Vector3.forward_local()
	return _new(0,0,1)
end



local _global_back = _new(0,0,-1);
Vector3.back = _global_back

function Vector3.back_global()
	return _global_back;
end

function Vector3.back_local()
	return _new(0,0,-1);
end

local _global_up = _new(0,1,0)
Vector3.up = _global_up

function Vector3.up_global()
	return _global_up
end

function Vector3.up_local()
	return _new(0,1,0)
end



local _global_down = _new(0,-1,0);
Vector3.down = _global_down

function Vector3.down_global()
	return _global_down
end

function Vector3.down_local()
	return _new(0,-1,0)
end



local _global_right = _new(1,0,0)
Vector3.right = _global_right

function Vector3.right_global()
	return _global_right
end

function Vector3.right_local()
	return _new(1,0,0)
end


local _global_left = _new(-1,0,0)
Vector3.left = _global_left
function Vector3.left_global()
	return _global_left
end

function Vector3.left_local()
	return _new(-1,0,0)
end



local _global_one = _new(1,1,1)
Vector3.one = _global_one
function Vector3.one_global()
	return _global_one
end

function Vector3.one_local()
	return _new(1,1,1)
end


local _global_zero = _new(0,0,0)
Vector3.zero = _global_zero
function Vector3.zero_global()
	return _global_zero
end

function Vector3.zero_local()
	return _new(0,0,0)
end

-- 
function Vector3.FormatEuler(_euler)
	local _value = _euler.x
	if _value < -180 then
		_value = _value + 360
	elseif _value > 180 then
		_value = _value - 360
	end
	_euler.x = _value
	
	_value = _euler.y
	if _value < -180 then
		_value = _value + 360
	elseif _value > 180 then
		_value = _value - 360
	end
	_euler.y = _value
	
	_value = _euler.z
	if _value < -180 then
		_value = _value + 360
	elseif _value > 180 then
		_value = _value - 360
	end
	_euler.z = _value
end

return Vector3