---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2022/01/11 14:14
--- Describe:
---


local math	= math
local sin 	= math.sin
local cos 	= math.cos
local acos 	= math.acos
local asin 	= math.asin
local sqrt 	= math.sqrt
local min	= math.min
local max 	= math.max
local sign	= math.sign
local atan2 = Mathf.Atan2
local clamp = Mathf.Clamp
local abs	= math.abs
local setmetatable = setmetatable
local getmetatable = getmetatable
local rawget = rawget
local rawset = rawset

local rad2Deg = Mathf.Rad2Deg
local halfDegToRad = 0.5 * Mathf.Deg2Rad
local _next = { 2, 3, 1 }
local _forward = Vector3.forward_global()
local _up = Vector3.up_global()

---@class Quaternion : table
Quaternion = {}
Quaternion.count = 0

Quaternion.__index = function(t, k)
	return rawget(Quaternion, k)
end

Quaternion.__newindex = function(t, name, k)	
	if name == "eulerAngles" then
		t:SetEuler(k)
	else
		rawset(t, name, k)
	end	
end

Quaternion.__call = function(t, x, y, z, w)
	local t = {x = x or 0, y = y or 0, z = z or 0, w = w or 0}
	setmetatable(t, Quaternion)	
	return t
end

function Quaternion.New(x, y, z, w)	
	Quaternion.count = Quaternion.count + 1
	
	local t = {x = x or 0, y = y or 0, z = z or 0, w = w or 0}
	setmetatable(t, Quaternion)	
	return t
end

local _new = Quaternion.New

function Quaternion:Set(x,y,z,w)
	self.x = x or 0
	self.y = y or 0
	self.z = z or 0
	self.w = w or 0
end

function Quaternion:Get()
	return self.x, self.y, self.z, self.w
end

function Quaternion.Clone(_q)
	return _new(_q.x, _q.y, _q.z, _q.w)
end

function Quaternion.Copy(_dest, _src)
	_dest.x = _src.x
	_dest.y = _src.y
	_dest.z = _src.z
	_dest.w = _src.w
	return _dest
end

function Quaternion.Dot(a, b)
	return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
end

function Quaternion.Length(q)
	return sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w)
end

function Quaternion.Angle(a, b)
	local dot = Quaternion.Dot(a, b)
	if dot < 0 then dot = -dot end
	return acos(min(dot, 1)) * 2 * 57.29578	
end

function Quaternion.AngleAxis(angle, axis, _receiver)
	_receiver = _receiver or Quaternion.New()
	
	local normAxis = axis:Normalize()
    angle = angle * halfDegToRad
    local s = sin(angle)    
    
    local w = cos(angle)
    local x = normAxis.x * s
    local y = normAxis.y * s
    local z = normAxis.z * s
	
	Quaternion.Set(_receiver, x,y,z,w)
	return _receiver
end

---@public
---@param angle number 角度
---@param axis Vector3 旋转轴(已经归一化之后的)
---@param _receiver Quaternion
function Quaternion.AngleNormalizedAxis(angle, axis, _receiver)
	_receiver = _receiver or Quaternion.New()
	
    angle = angle * halfDegToRad
    local s = sin(angle)    
    
    _receiver.x = axis.x * s
	_receiver.y = axis.y * s
	_receiver.z = axis.z * s
	_receiver.w = cos(angle)
	
	return _receiver
end

function Quaternion.Equals(a, b)
	return a.x == b.x and a.y == b.y and a.z == b.z and a.w == b.w
end

-- 
function Quaternion.FromEuler(v, _receiver)
	return Quaternion.Euler(v.x, v.y, v.z, _receiver)
end

function Quaternion.Euler(x, y, z, _receiver)
	if y == nil and z == nil then		
		y = x.y
		z = x.z	
		x = x.x
	end
	
	x = x * 0.0087266462599716
    y = y * 0.0087266462599716
    z = z * 0.0087266462599716

	local sinX = sin(x)
    x = cos(x)
    local sinY = sin(y)
    y = cos(y)
    local sinZ = sin(z)
    z = cos(z)

	if _receiver then
		Quaternion.Set(_receiver, 
				y * sinX * z + sinY * x * sinZ,
					sinY * x * z - y * sinX * sinZ,
					y * x * sinZ - sinY * sinX * z,
					y * x * z + sinY * sinX * sinZ
		)
		return _receiver
	end
	
    local q = {x = y * sinX * z + sinY * x * sinZ, y = sinY * x * z - y * sinX * sinZ, z = y * x * sinZ - sinY * sinX * z, w = y * x * z + sinY * sinX * sinZ}
	setmetatable(q, Quaternion)
	return q
end

function Quaternion.SetEuler(q, x, y, z)		
	if y == nil and z == nil then		
		y = x.y
		z = x.z	
		x = x.x
	end
		
	x = x * 0.0087266462599716
    y = y * 0.0087266462599716
    z = z * 0.0087266462599716
	
	local sinX = sin(x)
    local cosX = cos(x)
    local sinY = sin(y)
    local cosY = cos(y)
    local sinZ = sin(z)
    local cosZ = cos(z)
    
    q.w = cosY * cosX * cosZ + sinY * sinX * sinZ
    q.x = cosY * sinX * cosZ + sinY * cosX * sinZ
    q.y = sinY * cosX * cosZ - cosY * sinX * sinZ
    q.z = cosY * cosX * sinZ - sinY * sinX * cosZ
	
	return q
end

function Quaternion.Normalize(q)
	local _quat = Quaternion.Clone(q)
	Quaternion.SetNormalize(_quat)
	return _quat
end

function Quaternion.SetNormalize(q)
	local n = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w
	
	if n ~= 1 and n > 0 then
		n = 1 / sqrt(n)
		q.x = q.x * n
		q.y = q.y * n
		q.z = q.z * n
		q.w = q.w * n		
	end
end

--产生一个新的从from到to的四元数
function Quaternion.FromToRotation(from, to, _receiver)
	local quat =_receiver or Quaternion.New()
	quat:SetFromToRotation(from, to)
	return quat
end

--设置当前四元数为 from 到 to的旋转, 注意from和to同 forward平行会同unity不一致
function Quaternion:SetFromToRotation1(from, to)
	local v0 = from:Normalize()
	local v1 = to:Normalize()
	local d = Vector3.Dot(v0, v1)

	if d > -1 + 1e-6 then	
		local s = sqrt((1+d) * 2)
		local invs = 1 / s
		local c = Vector3.Cross(v0, v1) * invs
		self:Set(c.x, c.y, c.z, s * 0.5)	
	elseif d > 1 - 1e-6 then
		return _new(0, 0, 0, 1)
	else
		local axis = Vector3.Cross(Vector3.right_global(), v0)
		
		if axis:SqrMagnitude() < 1e-6 then
			axis = Vector3.Cross(Vector3.forward_global(), v0)
		end

		self:Set(axis.x, axis.y, axis.z, 0)		
		return self
	end
	
	return self
end

--from 和 to 都是归一化之后的值
function Quaternion.SetFromToRotation2(from, to, _receiver)
	
	local d = Vector3.Dot(from, to)

	if d > -1 + 1e-6 then	
		local s = sqrt((1+d) * 2)
		local invs = 1 / s
		local c = Vector3.Cross(from, to) * invs
		Quaternion.Set(_receiver, c.x, c.y, c.z, s * 0.5)
	elseif d > 1 - 1e-6 then
		Quaternion.Set(_receiver, 0, 0, 0, 1)
	else
		local axis = Vector3.Cross(Vector3.right_global(), from)

		if axis:SqrMagnitude() < 1e-6 then
			axis = Vector3.Cross(Vector3.forward_global(), from)
		end

		Quaternion.Set(_receiver, axis.x, axis.y, axis.z, 0)
	end

	return _receiver
end

function MatrixToQuaternion(rot, quat)
	local trace = rot[1][1] + rot[2][2] + rot[3][3]
	
	if trace > 0 then		
		local s = sqrt(trace + 1)
		quat.w = 0.5 * s
		s = 0.5 / s
		quat.x = (rot[3][2] - rot[2][3]) * s
		quat.y = (rot[1][3] - rot[3][1]) * s
		quat.z = (rot[2][1] - rot[1][2]) * s
		quat:SetNormalize()
	else
		local i = 1		
		local q = {0, 0, 0}
		
		if rot[2][2] > rot[1][1] then			
			i = 2			
		end
		
		if rot[3][3] > rot[i][i] then
			i = 3			
		end
		
		local j = _next[i]
		local k = _next[j]
		
		local t = rot[i][i] - rot[j][j] - rot[k][k] + 1
		local s = 0.5 / sqrt(t)
		q[i] = s * t
		local w = (rot[k][j] - rot[j][k]) * s
		q[j] = (rot[j][i] + rot[i][j]) * s
		q[k] = (rot[k][i] + rot[i][k]) * s
		
		quat:Set(q[1], q[2], q[3], w)			
		quat:SetNormalize()		
	end
end

function Quaternion:SetFromToRotation(from, to)
	from = from:Normalize()
	to = to:Normalize()
	
	local e = Vector3.Dot(from, to)
	
	if e > 1 - 1e-6 then
		self:Set(0, 0, 0, 1)
	elseif e < -1 + 1e-6 then		
		local left = {0, from.z, from.y}	
		local mag = left[2] * left[2] + left[3] * left[3]  --+ left[1] * left[1] = 0
		
		if mag < 1e-6 then		
			left[1] = -from.z
			left[2] = 0
			left[3] = from.x
			mag = left[1] * left[1] + left[3] * left[3]
		end
				
		local invlen = 1/sqrt(mag)
		left[1] = left[1] * invlen
		left[2] = left[2] * invlen
		left[3] = left[3] * invlen
		
		local up = {0, 0, 0}
		up[1] = left[2] * from.z - left[3] * from.y
		up[2] = left[3] * from.x - left[1] * from.z
		up[3] = left[1] * from.y - left[2] * from.x
				

		local fxx = -from.x * from.x
		local fyy = -from.y * from.y
		local fzz = -from.z * from.z
		
		local fxy = -from.x * from.y
		local fxz = -from.x * from.z
		local fyz = -from.y * from.z

		local uxx = up[1] * up[1]
		local uyy = up[2] * up[2]
		local uzz = up[3] * up[3]
		local uxy = up[1] * up[2]
		local uxz = up[1] * up[3]
		local uyz = up[2] * up[3]

		local lxx = -left[1] * left[1]
		local lyy = -left[2] * left[2]
		local lzz = -left[3] * left[3]
		local lxy = -left[1] * left[2]
		local lxz = -left[1] * left[3]
		local lyz = -left[2] * left[3]
		
		local rot = 
		{
			{fxx + uxx + lxx, fxy + uxy + lxy, fxz + uxz + lxz},
			{fxy + uxy + lxy, fyy + uyy + lyy, fyz + uyz + lyz},
			{fxz + uxz + lxz, fyz + uyz + lyz, fzz + uzz + lzz},
		}
		
		MatrixToQuaternion(rot, self)		
	else
		local v = Vector3.Cross(from, to)
		local h = (1 - e) / Vector3.Dot(v, v) 
		
		local hx = h * v.x
		local hz = h * v.z
		local hxy = hx * v.y
		local hxz = hx * v.z
		local hyz = hz * v.y
		
		local rot = 
		{ 					
			{e + hx*v.x, 	hxy - v.z, 		hxz + v.y},
			{hxy + v.z,  	e + h*v.y*v.y, 	hyz-v.x},
			{hxz - v.y,  	hyz + v.x,    	e + hz*v.z},
		}
		
		MatrixToQuaternion(rot, self)
	end
end

function Quaternion:Inverse(_receiver)
	local quat = _receiver or Quaternion.New()
		
	quat.x = -self.x
	quat.y = -self.y
	quat.z = -self.z
	quat.w = self.w
	
	return quat
end

function Quaternion:SetInverse()
	self.x = -self.x
	self.y = -self.y
	self.z = -self.z
	self.w = self.w
end

function Quaternion.Lerp(q1, q2, t)
	t = clamp(t, 0, 1)
	local q = {x = 0, y = 0, z = 0, w = 1}	
	
	if Quaternion.Dot(q1, q2) < 0 then
		q.x = q1.x + t * (-q2.x -q1.x)
		q.y = q1.y + t * (-q2.y -q1.y)
		q.z = q1.z + t * (-q2.z -q1.z)
		q.w = q1.w + t * (-q2.w -q1.w)
	else
		q.x = q1.x + (q2.x - q1.x) * t
		q.y = q1.y + (q2.y - q1.y) * t
		q.z = q1.z + (q2.z - q1.z) * t
		q.w = q1.w + (q2.w - q1.w) * t
	end	
	
	Quaternion.SetNormalize(q)
	setmetatable(q, Quaternion)
	return q
end

-- 非截断式插值 add by wth
function Quaternion.LerpUnclamped(q1, q2, t)
	t = clamp(t, 0, 100)
	local q = {x = 0, y = 0, z = 0, w = 1}

	if Quaternion.Dot(q1, q2) < 0 then
		q.x = q1.x + t * (-q2.x -q1.x)
		q.y = q1.y + t * (-q2.y -q1.y)
		q.z = q1.z + t * (-q2.z -q1.z)
		q.w = q1.w + t * (-q2.w -q1.w)
	else
		q.x = q1.x + (q2.x - q1.x) * t
		q.y = q1.y + (q2.y - q1.y) * t
		q.z = q1.z + (q2.z - q1.z) * t
		q.w = q1.w + (q2.w - q1.w) * t
	end

	Quaternion.SetNormalize(q)
	setmetatable(q, Quaternion)
	return q
end


--function Quaternion.LookRotation_noAlloc(forward, up, outQua)
--	local mag = forward:Magnitude()
--	if mag < 1e-6 then
--		error("error input forward to Quaternion.LookRotation"..tostring(forward))
--		return nil
--	end
--
--	local x, y, z, w = toluaThrud.Quaternion_LookRotation(forward.x, forward.y, forward.z, up.x, up.y, up.z)
--	--local ret = _new(x, y, z, w)
--	outQua.x = x;
--	outQua.y = y;
--	outQua.z = z;
--	outQua.w = w;
--	return ret;
--end

---@public
---@param _targetForward Vector3 要看向的目标向量 
---@param _targetUp Vector3 指定的上方向
---@param _qReceiver Quaternion 用于接收结果的四元数
---@param _vector3Pool Vector3Pool
---@return boolean 是否成功
function Quaternion.LookRotation(_targetForward, _targetUp, _qReceiver, _vector3Pool)

	if not _targetForward then
		if CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "error input forward to Quaternion.LookRotation, forward is nil")
		end
		return false
	end
	
	if not _targetUp then
		if CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "error input forward to Quaternion.LookRotation, up is nil")
		end
		return false
	end
	
	local _v3Forward
	local _v3Up
	local _v3Right
	if not _vector3Pool then
		_v3Forward = Vector3.Normalize(_targetForward)
		_v3Up = Vector3.Normalize(_targetUp)
		_v3Right = Vector3.zero_local()
	else
		_v3Forward = _vector3Pool:Pop(_targetForward)
		Vector3.SetNormalize(_v3Forward)
		_v3Up = _vector3Pool:Pop(_targetUp)
		Vector3.SetNormalize(_v3Up)
		_v3Right = _vector3Pool:Pop()
	end

	Vector3.Cross(_v3Up, _v3Forward, _v3Right)
	Vector3.SetNormalize(_v3Right)
	
	Vector3.Cross(_v3Forward, _v3Right, _v3Up)
	Vector3.Cross(_v3Up, _v3Forward, _v3Right)
	
	local t = _v3Right.x + _v3Up.y + _v3Forward.z

	if t > 0 then
		local x, y, z, w
		t = t + 1
		local s = 0.5 / sqrt(t)
		w = s * t
		x = (_v3Up.z - _v3Forward.y) * s
		y = (_v3Forward.x - _v3Right.z) * s
		z = (_v3Right.y - _v3Up.x) * s
		
		Quaternion.Set(_qReceiver, x, y, z, w)
	else
		local rot =
		{
			{_v3Right.x, _v3Up.x, _v3Forward.x},
			{_v3Right.y, _v3Up.y, _v3Forward.y},
			{_v3Right.z, _v3Up.z, _v3Forward.z},
		}

		local q = {0, 0, 0}
		local i = 1

		if _v3Up.y > _v3Right.x then
			i = 2
		end

		if _v3Forward.z > rot[i][i] then
			i = 3
		end

		local j = _next[i]
		local k = _next[j]

		local t = rot[i][i] - rot[j][j] - rot[k][k] + 1
		local s = 0.5 / sqrt(t)
		q[i] = s * t
		local w = (rot[k][j] - rot[j][k]) * s
		q[j] = (rot[j][i] + rot[i][j]) * s
		q[k] = (rot[k][i] + rot[i][k]) * s

		Quaternion.Set(_qReceiver, q[1], q[2], q[3], w)
	end

	if _vector3Pool then
		_vector3Pool:Push(_v3Forward)
		_vector3Pool:Push(_v3Up)
		_vector3Pool:Push(_v3Right)
	end
	return true
	
	--local right = Vector3.Cross(up, forward)
	--right:SetNormalize()
	--up = Vector3.Cross(forward, right)
	--right = Vector3.Cross(up, forward)

	--[[	local quat = _new(0,0,0,1)
		local rot = 
		{ 					
			{right.x, up.x, forward.x},
			{right.y, up.y, forward.y},
			{right.z, up.z, forward.z},
		}
		
		MatrixToQuaternion(rot, quat)
		return quat--]]

	--local t = right.x + up.y + forward.z
	--
	--if t > 0 then
	--	local x, y, z, w
	--	t = t + 1
	--	local s = 0.5 / sqrt(t)
	--	w = s * t
	--	x = (up.z - forward.y) * s
	--	y = (forward.x - right.z) * s
	--	z = (right.y - up.x) * s
	--
	--	local ret = _new(x, y, z, w)
	--	ret:SetNormalize()
	--	return ret
	--else
	--	local rot =
	--	{
	--		{right.x, up.x, forward.x},
	--		{right.y, up.y, forward.y},
	--		{right.z, up.z, forward.z},
	--	}
	--
	--	local q = {0, 0, 0}
	--	local i = 1
	--
	--	if up.y > right.x then
	--		i = 2
	--	end
	--
	--	if forward.z > rot[i][i] then
	--		i = 3
	--	end
	--
	--	local j = _next[i]
	--	local k = _next[j]
	--
	--	local t = rot[i][i] - rot[j][j] - rot[k][k] + 1
	--	local s = 0.5 / sqrt(t)
	--	q[i] = s * t
	--	local w = (rot[k][j] - rot[j][k]) * s
	--	q[j] = (rot[j][i] + rot[i][j]) * s
	--	q[k] = (rot[k][i] + rot[i][k]) * s
	--
	--	local ret = _new(q[1], q[2], q[3], w)
	--	ret:SetNormalize()
	--	return ret
	--end
	
end

function Quaternion:SetIdentity()
	self.x = 0
	self.y = 0
	self.z = 0
	self.w = 1
end

function UnclampedSlerp(q1, q2, t)		
	local dot = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w

    if dot < 0 then
        dot = -dot        
        q2 = setmetatable({x = -q2.x, y = -q2.y, z = -q2.z, w = -q2.w}, Quaternion)        
    end

    if dot < 0.95 then		
	    local angle = acos(dot)
        local invSinAngle = 1 / sin(angle)
        local t1 = sin((1 - t) * angle) * invSinAngle
        local t2 = sin(t * angle) * invSinAngle
        q1 = {x = q1.x * t1 + q2.x * t2, y = q1.y * t1 + q2.y * t2, z = q1.z * t1 + q2.z * t2, w = q1.w * t1 + q2.w * t2}
		setmetatable(q1, Quaternion)		
		return q1
	else
		q1 = {x = q1.x + t * (q2.x - q1.x), y = q1.y + t * (q2.y - q1.y), z = q1.z + t * (q2.z - q1.z), w = q1.w + t * (q2.w - q1.w)}		
		Quaternion.SetNormalize(q1)		
		setmetatable(q1, Quaternion)
		return q1
    end
end


function Quaternion.Slerp(from, to, t)	
	if t < 0 then
		t = 0
	elseif t > 1 then
		t = 1
	end

	return UnclampedSlerp(from, to, t)
end

function Quaternion.RotateTowards(from, to, maxDegreesDelta)   	
	local angle = Quaternion.Angle(from, to)
	
	if angle == 0 then
		return to
	end
	
	local t = min(1, maxDegreesDelta / angle)
	return UnclampedSlerp(from, to, t)
end

function Approximately(f0, f1)
	return abs(f0 - f1) < 1e-6	
end

function Quaternion:ToAngleAxis()		
	local angle = 2 * acos(self.w)
	
	if Approximately(angle, 0) then
		return angle * 57.29578, Vector3.New(1, 0, 0)
	end
	
	local div = 1 / sqrt(1 - sqrt(self.w))
	return angle * 57.29578, Vector3.New(self.x * div, self.y * div, self.z * div)
end

local pi = Mathf.PI
local half_pi = pi * 0.5
local two_pi = 2 * pi
local negativeFlip = -0.0001
local positiveFlip = two_pi - 0.0001
	
function SanitizeEuler(euler)	
	if euler.x < negativeFlip then
		euler.x = euler.x + two_pi
	elseif euler.x > positiveFlip then
		euler.x = euler.x - two_pi
	end

	if euler.y < negativeFlip then
		euler.y = euler.y + two_pi
	elseif euler.y > positiveFlip then
		euler.y = euler.y - two_pi
	end

	if euler.z < negativeFlip then
		euler.z = euler.z + two_pi
	elseif euler.z > positiveFlip then
		euler.z = euler.z + two_pi
	end
end

--from http://www.geometrictools.com/Documentation/EulerAngles.pdf
--Order of rotations: YXZ
function Quaternion:ToEulerAngles(_receiver)
	local x = self.x
	local y = self.y
	local z = self.z
	local w = self.w
		
	local check = 2 * (y * z - w * x)
	
	local v = _receiver or Vector3.zero_local()
	if check < 0.999 then
		if check > -0.999 then
			Vector3.Set(v, 
					-asin(check),
						atan2(2 * (x * z + w * y), 1 - 2 * (x * x + y * y)),
						atan2(2 * (x * y + w * z), 1 - 2 * (x * x + z * z))
						)
			SanitizeEuler(v)
			v:Mul(rad2Deg)
			return v
		else
			Vector3.Set(v,
						half_pi,
						atan2(2 * (x * y - w * z), 1 - 2 * (y * y + z * z)),
						0
			)
			SanitizeEuler(v)
			v:Mul(rad2Deg)
			return v
		end
	else
		Vector3.Set(v,
					-half_pi,
					atan2(-2 * (x * y - w * z), 1 - 2 * (y * y + z * z)),
					0
		)
		SanitizeEuler(v)
		v:Mul(rad2Deg)
		return v		
	end
end

function Quaternion.Forward(_self)
	return Quaternion.MulVec3(_self,_forward)
end

---@param _receiver Vector3
---@return Vector3
function Quaternion.MulVec3(self, point, _receiver)

	local vec = _receiver or Vector3.New()

	local num 	= self.x * 2
	local num2 	= self.y * 2
	local num3 	= self.z * 2
	local num4 	= self.x * num
	local num5 	= self.y * num2
	local num6 	= self.z * num3
	local num7 	= self.x * num2
	local num8 	= self.x * num3
	local num9 	= self.y * num3
	local num10 = self.w * num
	local num11 = self.w * num2
	local num12 = self.w * num3

	vec.x = (((1 - (num5 + num6)) * point.x) + ((num7 - num12) * point.y)) + ((num8 + num11) * point.z)
	vec.y = (((num7 + num12) * point.x) + ((1 - (num4 + num6)) * point.y)) + ((num9 - num10) * point.z)
	vec.z = (((num8 - num11) * point.x) + ((num9 + num10) * point.y)) + ((1 - (num4 + num5)) * point.z)

	return vec
end

function Quaternion.MulQuan(_self, _rotate, _receiver)

	local _quan = _receiver or Quaternion.identity_Local()
	
	local _lx = _self.x
	local _ly = _self.y
	local _lz = _self.z
	local _lw = _self.w
	local _rx = _rotate.x
	local _ry = _rotate.y
	local _rz = _rotate.z
	local _rw = _rotate.w
	
	_quan.x = (((_lw * _rx) + (_lx * _rw)) + (_ly * _rz)) - (_lz * _ry) 
	_quan.y = (((_lw * _ry) + (_ly * _rw)) + (_lz * _rx)) - (_lx * _rz) 
	_quan.z = (((_lw * _rz) + (_lz * _rw)) + (_lx * _ry)) - (_ly * _rx) 
	_quan.w = (((_lw * _rw) - (_lx * _rx)) - (_ly * _ry)) - (_lz * _rz)

	return _quan
end

Quaternion.__mul = function(lhs, rhs)
	if Quaternion == getmetatable(rhs) then
		return lhs:MulQuan(rhs)
	elseif Vector3 == getmetatable(rhs) then
		return lhs:MulVec3(rhs)
	end
end

Quaternion.__unm = function(q)
	return Quaternion.New(-q.x, -q.y, -q.z, -q.w)
end

Quaternion.__eq = function(lhs,rhs)
	--0.00081028度
	return Quaternion.Dot(lhs, rhs) > 0.9999999999
end

Quaternion.__tostring = function(self)
	if self.x ~= nil and self.y ~= nil and self.z ~= nil and self.w ~= nil then
		return "["..self.x..","..self.y..","..self.z..","..self.w.."]"
	else
		return "quaternion contain nil"
	end
end

Quaternion.__sub = function(va, vb)
	return Quaternion.New(va.x - vb.x, va.y - vb.y, va.z - vb.z, va.w - vb.w)
end



local _global_identity = _new(0,0,0,1)
Quaternion.identity = _global_identity
function Quaternion.identity_Gloabal()
	return _global_identity
end

function Quaternion.identity_Local()
	return _new(0,0,0,1)
end

return Quaternion