---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2022/1/11 16:33
--- 移动工具类

MOVE_UTILS = {}
local _cachedV3_1 = Vector3.New()
local _cachedV3_2 = Vector3.New()
local _cachedQuan_1 = Quaternion.New()
local _cachedQuan_2 = Quaternion.New()

--- AI转向
---@public
---@param _actionStateManager ActionStateManage
---@param _qReceiveFinalRotation Quaternion 用于接收计算结果的四元数
---@param _vCurEuler Vector3 当前欧拉角
---@param _v3CameraParam Vector3 旋转摇杆量
---@param _fSensitivityX number x方向灵敏度
---@param _fSensitivityY number y方向灵敏度
function MOVE_UTILS.AiRotate(_actionStateManager, _qReceiveFinalRotation, _vCurEuler,_v3CameraParam,_fSensitivityX,_fSensitivityY, _hAngleLimit, _vAngleLimit)
    local _unit = _actionStateManager:GetUnit()
    local _netId = _unit:GetNetId()
    
	if _netId == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "MOVE_UTILS.Rotate_AI start", "_v3CameraParam", _v3CameraParam, "_hAngleLimit", _hAngleLimit, "_vAngleLimit", _vAngleLimit)
	end

    local _oldX = _vCurEuler.x
    local _oldY = _vCurEuler.y

    ---@type BattleUnitCom_TagSelector
    local _tagCom = _unit:GetComponent(BattleUnitComponentType.TagSelector)
    local _axisLockType = _tagCom and _tagCom:GetTag(BattleUnitTagEnum.RotateAxisLockType) or LuaBehav_Define_RotateAxisLockType.None

    if _axisLockType == LuaBehav_Define_RotateAxisLockType.LockX then
        ---X轴锁了，不能横向旋转
        _hAngleLimit = 0
    elseif _axisLockType == LuaBehav_Define_RotateAxisLockType.LockY then
        ---Y轴锁了，不能纵向旋转
        _vAngleLimit = 0
    end
    
    if _netId == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "MOVE_UTILS.Rotate_AI start", "轴锁定类型", LogTools.GetEnumTableDesc(LuaBehav_Define_RotateAxisLockType, _axisLockType), "_hAngleLimit", _hAngleLimit, "_vAngleLimit", _vAngleLimit)
	end
    
    if _vAngleLimit >= 75 or _vAngleLimit < -75 then
        _vCurEuler.x = _oldX + _vAngleLimit * _v3CameraParam.y
    else
        if _hAngleLimit ~= 0 then   
            local _fRotateAngleH = _hAngleLimit < _fSensitivityX and _v3CameraParam.x * _hAngleLimit or _v3CameraParam.x * _fSensitivityX
            if _netId == ActionStateManage.checkNetId then
                LogTools.LogByLevel(LogLevel.log, "MOVE_UTILS.Rotate_AI", "水平转向", "_fRotateAngleH", _fRotateAngleH, "_vCurEuler.y", _vCurEuler.y, "_hAngleLimit", _hAngleLimit, "_fSensitivityX", _fSensitivityX)
            end
            _vCurEuler.y = _oldY + _fRotateAngleH
        else
            if _vAngleLimit ~= 0 then
                local _fRotateAngleV = _vAngleLimit < _fSensitivityY and _v3CameraParam.y * _vAngleLimit or _v3CameraParam.y * _fSensitivityY
                if _netId == ActionStateManage.checkNetId then
                    LogTools.LogByLevel(LogLevel.log, "MOVE_UTILS.Rotate_AI", "竖直转向", "_fRotateAngleV", _fRotateAngleV, "_vCurEuler.x", _vCurEuler.x, "_vAngleLimit", _vAngleLimit, "_fSensitivityY", _fSensitivityY)
                end
                _vCurEuler.x = _oldX + _fRotateAngleV
            end
        end
    end
    
    ---永远不动Z
    _vCurEuler.z = 0
	if _netId == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "MOVE_UTILS.Rotate_AI end", "finalEuler", _vCurEuler)
	end
    Quaternion.FromEuler(_vCurEuler, _qReceiveFinalRotation)

    ---保险起见，这里先还原回去，等真正SetRotation的时候自动计算
    _vCurEuler.x = _oldX
    _vCurEuler.y = _oldY
end

---AI移动
---@public
---@param _battleRoom BattleRoom
---@param _v3ReceiverVelocity Vector3 用于接收计算出的当前速度
---@param _v3ReceiverPosChange Vector3 用于接收计算出的位置变化
---@param _v3ReceiverAccelerate Vector3 用于接收计算出的当前加速度
---@param _moveParam Vector3 移动参数
---@param _currentVelocity Vector3 当前速度
---@param _qCurRotation Quaternion 当前朝向
---@param _stateParamAccInZ number stateParam配置的Z向加速度
---@param _maxVelocity number 最大速度
---@param _forceAcc Vector3 牵引力
---@param _dt number 时间
---@param _hitFixDir Vector3 撞墙修正的移动方向
function MOVE_UTILS.AiMove(_battleRoom, _v3ReceiverVelocity, _v3ReceiverPosChange, _v3ReceiverAccelerate, _moveParam,_currentVelocity,_qCurRotation,_stateParamAccInZ,_maxVelocity,_forceAcc,_dt, _hitFixDir, _specificMoveVelocity)

    ---有AI输入，或者撞墙数据
    if (_moveParam and not Vector3.IsZero(_moveParam)) or _hitFixDir then
        local _forwardInWorld = _cachedV3_1
        if _hitFixDir then
            --有撞墙修正方向的时候，直接用修正方向作为方向
            Vector3.Normalize(_hitFixDir, _forwardInWorld)
        else
            --在没有外力干扰下，AI移动永远都是朝前方
            --初始移动方向为当前forward的世界方向
            Vector3.MulQuat(Vector3.forward_global(), _qCurRotation, _forwardInWorld)
        end
        --归一化最为本帧初始的加速度方向
        Vector3.SetNormalize(_forwardInWorld)
        --加速度（每秒）= 当前朝向（归一化）* 表里固定第一项配置值
        Vector3.MulNumber(_forwardInWorld, _stateParamAccInZ, _v3ReceiverAccelerate)
        --速度 = 当前速度 + 加速度（每秒）* dt
        Vector3.Add(_currentVelocity, _v3ReceiverAccelerate * _dt, _v3ReceiverVelocity)
        local _curVelocityLenSqr = Vector3.SqrMagnitude(_v3ReceiverVelocity)
        ---判断下速度是否超过了最大速度
        if _curVelocityLenSqr > _maxVelocity * _maxVelocity then
            Vector3.MulNumber(_forwardInWorld, _maxVelocity, _v3ReceiverVelocity)
        end
        Vector3.MulNumber(_v3ReceiverVelocity, _dt, _v3ReceiverPosChange)
    end
    
    --计算是否有牵引力
    if not _hitFixDir and _forceAcc then
        Vector3.MulNumber(_forceAcc, _dt, _cachedV3_2)
        --外力提供的加速度，直接向量加到当前速度上
        --AI的当前速度只是其自身的速度状态，不被外力改变
        Vector3.Add(_v3ReceiverPosChange, _cachedV3_2, _v3ReceiverPosChange)
    end
    
    --是否有其他强制方向
    if not _hitFixDir and _specificMoveVelocity then
        Vector3.MulNumber(_specificMoveVelocity, _dt, _cachedV3_2)
        Vector3.Add(_v3ReceiverPosChange, _cachedV3_2, _v3ReceiverPosChange)
    end
end

--- 一般移动算法
---@public
---@param _battleRoom BattleRoom
---@param _v3ReceiverVelocity Vector3 用于接收计算出的当前速度
---@param _v3ReceiverPosChange Vector3 用于接收计算出的位置变化
---@param _v3ReceiverAccelerate Vector3 用于接收计算出的当前加速度
---@param _moveParam Vector3 移动参数
---@param _currentVelocity Vector3 当前速度
---@param _qCurRotation Quaternion 当前朝向
---@param _qMoveAcc Quaternion 加速度四元数
---@param _airFriction number 空气阻力
---@param _breakAccelerate number 刹车参数
---@param _maxVelocity number 最大速度
---@param _forceAcc Vector3 牵引力
---@param _dt number 时间
---@param _hitMoveDir Vector3 撞墙移动方向
---@return Vector3,Vector3,Vector3 当前速度,位置变化,加速度
function MOVE_UTILS.Move(_battleRoom, _v3ReceiverVelocity, _v3ReceiverPosChange, _v3ReceiverAccelerate, _moveParam,_currentVelocity,_qCurRotation,_qMoveAcc,_airFriction,_breakAccelerate,_maxVelocity,_forceAcc,_dt,_hitMoveDir)
    if _moveParam == nil and _forceAcc == nil then return end
    
    local _vector3Pool= _battleRoom.vector3Pool
    Vector3.Copy(_v3ReceiverVelocity, _currentVelocity)
    
    --local _forward = _qCurRotation * Vector3.forward_global()
    --local _moveForward = Vector3.ProjectOnPlane(_forward, Vector3.up_global())
    --local _moveRotation = Quaternion.FromToRotation(Vector3.forward_global(), _moveForward)
    
    local _forward = _vector3Pool:Pop()
    Vector3.MulQuat(Vector3.forward_global(), _qCurRotation, _forward)
    local _moveForward = _vector3Pool:Pop()
    Vector3.ProjectOnPlane(_forward, Vector3.up_global(), _moveForward)
    local _moveRotation = _battleRoom.quaternionPool:Pop()
    --Quaternion.FromToRotation(Vector3.forward_global(), _moveForward, _moveRotation)
    Quaternion.LookRotation(_moveForward, Vector3.up_global(), _moveRotation, _vector3Pool)
    
    ---摇杆输入值
    local _v3JoyInput = _forward
    Vector3.Set(_v3JoyInput, _moveParam.x, 0, _moveParam.y)
    
    --摇杆输入方向向量
    --摇杆输入的是本地空间向量
    --需要转化为世界空间向量，并归一化
    local _joyInputDir = _moveForward
    Vector3.MulQuat(_v3JoyInput, _moveRotation, _joyInputDir)
    Vector3.SetNormalize(_joyInputDir)
    local _joyInputMag = Vector3.SqrMagnitude(_joyInputDir) --摇杆输入量的大小
    
    --以摇杆方向作为当前加速度方向
    Vector3.Copy(_v3ReceiverAccelerate, _joyInputDir)
    
    --以摇杆方向计算最大速度（方向和大小）
    local maxVelocity = _vector3Pool:Pop(_joyInputDir)
    Vector3.MulNumber(_joyInputDir, _maxVelocity, maxVelocity)
    
    --如果有强制加速度，当前速度和最大速度都增加当前帧的强制速度值
    if _forceAcc then
        local _forceInFrame = _vector3Pool:Pop()
        Vector3.MulNumber(_forceAcc, _dt, _forceInFrame)
        Vector3.Add(_v3ReceiverVelocity, _forceInFrame)
        Vector3.Add(maxVelocity, _forceInFrame)
        _vector3Pool:Push(_forceInFrame)
    end
    
    if _joyInputMag > Mathf.Epsilon then --输入有效，产生变化
        local _tmpCurVelocity = _vector3Pool:Pop(_v3ReceiverVelocity)
        
        --计算当前速度(本帧的理论值)
        local _scaledMagnitude = MOVE_UTILS.GetScaledMagnitudeByQuadrant(_battleRoom, _v3JoyInput, _qMoveAcc)
        _scaledMagnitude = math.sqrt(_scaledMagnitude)
        Vector3.MulNumber(_joyInputDir, _scaledMagnitude, _v3ReceiverAccelerate)
        local _velocityChangeInDt = _vector3Pool:Pop()
        Vector3.MulNumber(_v3ReceiverAccelerate, _dt, _velocityChangeInDt)
        Vector3.Add(_tmpCurVelocity, _velocityChangeInDt)
        _vector3Pool:Push(_velocityChangeInDt)
        --print("MoveMove _tmpCurVelocity: " .. tostring(_tmpCurVelocity) .. ", _v3ReceiverAccelerate：" .. tostring(_v3ReceiverAccelerate) ..", _v3ReceiverVelocity: " ..tostring(_v3ReceiverVelocity) ..", _velocityChangeInDt: " ..tostring(_velocityChangeInDt) ..", _dt: " .._dt)
        Vector3.Copy(_v3ReceiverVelocity, _tmpCurVelocity)
        local _sqrMagTmpV = Vector3.SqrMagnitude(_tmpCurVelocity)
        local _sqrMagMaxV = Vector3.SqrMagnitude(maxVelocity)
        if _sqrMagTmpV < _sqrMagMaxV then
            Vector3.SetNormalize(_v3ReceiverVelocity)
            local velocityMag = Vector3.SqrMagnitude(_tmpCurVelocity)
            local _sqrtVelocityMag = math.sqrt(velocityMag)
            --空气阻力 F = CPSVV/2, 简化为 F = AirFrictionConfig * V * V，但是因为用速度的二次方，阻力增加太快，改为一次
            Vector3.MulNumber(_v3ReceiverVelocity, _sqrtVelocityMag - _airFriction * _sqrtVelocityMag * _dt)
        end
        Vector3.ClampMagnitude(_v3ReceiverVelocity, math.sqrt(_sqrMagMaxV))
        --print("MoveMove _tmpCurVelocity: " .. tostring(_tmpCurVelocity) .. ", math.sqrt(_sqrMagMaxV)：" .. math.sqrt(_sqrMagMaxV))
    else --输入过小，被忽略，仍按照当前状态移动
        local velocityMag = Vector3.SqrMagnitude(_v3ReceiverVelocity)
        local _velocitySqrtMag = math.sqrt(velocityMag)
        local inverseVelocityMag = (_breakAccelerate + _airFriction * _velocitySqrtMag) * _dt
        if velocityMag < inverseVelocityMag then
            Vector3.Set(_v3ReceiverVelocity, 0, 0, 0)
        else
            Vector3.SetNormalize(_v3ReceiverVelocity)
            Vector3.MulNumber(_v3ReceiverVelocity, _velocitySqrtMag - inverseVelocityMag)
        end
    end
    
    if _hitMoveDir then
        Vector3.Project(_v3ReceiverVelocity, _hitMoveDir, _v3ReceiverVelocity)
        --LogTools.LogByLevel(LogLevel.log, "_hitMoveDir", Vector3.Magnitude(_hitMoveDir), "_v3ReceiverVelocity", Vector3.Magnitude(_v3ReceiverVelocity))
        --local _dot = Vector3.Dot(_hitMoveDir, _v3ReceiverVelocity)
        --Vector3.MulNumber(_hitMoveDir, _dot, _v3ReceiverVelocity)
    end
    Vector3.MulNumber(_v3ReceiverVelocity, _dt, _v3ReceiverPosChange)

    _vector3Pool:Push(_v3JoyInput)
    _vector3Pool:Push(_joyInputDir)
    _vector3Pool:Push(maxVelocity)
    _battleRoom.quaternionPool:Push(_moveRotation)
end

--- 一般移动算法
---@public
---@param _battleRoom BattleRoom
---@param _v3ReceiverVelocity Vector3 用于接收计算出的当前速度
---@param _v3ReceiverPosChange Vector3 用于接收计算出的位置变化
---@param _v3ReceiverAccelerate Vector3 用于接收计算出的当前加速度
---@param _moveParam Vector3 移动参数
---@param _currentVelocity Vector3 当前速度
---@param _qCurRotation Quaternion 当前朝向
---@param _qMoveAcc Quaternion 加速度四元数
---@param _airFriction number 空气阻力
---@param _breakAccelerate number 刹车参数
---@param _maxVelocity number 最大速度
---@param _forceAcc Vector3 牵引力
---@param _dt number 时间
---@param _hitMoveDir Vector3 撞墙移动方向
---@return Vector3,Vector3,Vector3 当前速度,位置变化,加速度
function MOVE_UTILS.Move_FreeFly(_battleRoom, _v3ReceiverVelocity, _v3ReceiverPosChange, _v3ReceiverAccelerate, _moveParam,_currentVelocity,_qCurRotation,_qMoveAcc,_airFriction,_breakAccelerate,_maxVelocity,_forceAcc,_dt,_hitMoveDir)
    if _moveParam == nil and _forceAcc == nil then return end

    local _vector3Pool= _battleRoom.vector3Pool
    Vector3.Copy(_v3ReceiverVelocity, _currentVelocity)

    ---摇杆输入值
    local _v3JoyInput = _vector3Pool:Pop()
    Vector3.Set(_v3JoyInput, _moveParam.x, 0, _moveParam.y)

    --摇杆输入方向向量
    --摇杆输入的是本地空间向量
    --需要转化为世界空间向量，并归一化
    local _joyInputDir = _vector3Pool:Pop()
    Vector3.MulQuat(_v3JoyInput, _qCurRotation, _joyInputDir)
    Vector3.SetNormalize(_joyInputDir)
    local _joyInputMag = Vector3.SqrMagnitude(_joyInputDir) --摇杆输入量的大小

    --以摇杆方向作为当前加速度方向
    Vector3.Copy(_v3ReceiverAccelerate, _joyInputDir)

    --以摇杆方向计算最大速度（方向和大小）
    local maxVelocity = _vector3Pool:Pop(_joyInputDir)
    Vector3.MulNumber(_joyInputDir, _maxVelocity, maxVelocity)

    --如果有强制加速度，当前速度和最大速度都增加当前帧的强制速度值
    if _forceAcc then
        local _forceInFrame = _vector3Pool:Pop()
        Vector3.MulNumber(_forceAcc, _dt, _forceInFrame)
        Vector3.Add(_v3ReceiverVelocity, _forceInFrame)
        Vector3.Add(maxVelocity, _forceInFrame)
        _vector3Pool:Push(_forceInFrame)
    end

    if _joyInputMag > Mathf.Epsilon then --输入有效，产生变化
        local _tmpCurVelocity = _vector3Pool:Pop(_v3ReceiverVelocity)

        --计算当前速度(本帧的理论值)
        local _scaledMagnitude = MOVE_UTILS.GetScaledMagnitudeByQuadrant(_battleRoom, _v3JoyInput, _qMoveAcc)
        _scaledMagnitude = math.sqrt(_scaledMagnitude)
        Vector3.MulNumber(_joyInputDir, _scaledMagnitude, _v3ReceiverAccelerate)
        local _velocityChangeInDt = _vector3Pool:Pop()
        Vector3.MulNumber(_v3ReceiverAccelerate, _dt, _velocityChangeInDt)
        Vector3.Add(_tmpCurVelocity, _velocityChangeInDt)
        _vector3Pool:Push(_velocityChangeInDt)
        --print("MoveMove _tmpCurVelocity: " .. tostring(_tmpCurVelocity) .. ", _v3ReceiverAccelerate：" .. tostring(_v3ReceiverAccelerate) ..", _v3ReceiverVelocity: " ..tostring(_v3ReceiverVelocity) ..", _velocityChangeInDt: " ..tostring(_velocityChangeInDt) ..", _dt: " .._dt)
        Vector3.Copy(_v3ReceiverVelocity, _tmpCurVelocity)
        local _sqrMagTmpV = Vector3.SqrMagnitude(_tmpCurVelocity)
        local _sqrMagMaxV = Vector3.SqrMagnitude(maxVelocity)
        if _sqrMagTmpV < _sqrMagMaxV then
            Vector3.SetNormalize(_v3ReceiverVelocity)
            local velocityMag = Vector3.SqrMagnitude(_tmpCurVelocity)
            local _sqrtVelocityMag = math.sqrt(velocityMag)
            --空气阻力 F = CPSVV/2, 简化为 F = AirFrictionConfig * V * V，但是因为用速度的二次方，阻力增加太快，改为一次
            Vector3.MulNumber(_v3ReceiverVelocity, _sqrtVelocityMag - _airFriction * _sqrtVelocityMag * _dt)
        end
        Vector3.ClampMagnitude(_v3ReceiverVelocity, math.sqrt(_sqrMagMaxV))
        --print("MoveMove _tmpCurVelocity: " .. tostring(_tmpCurVelocity) .. ", math.sqrt(_sqrMagMaxV)：" .. math.sqrt(_sqrMagMaxV))
    else --输入过小，被忽略，仍按照当前状态移动
        local velocityMag = Vector3.SqrMagnitude(_v3ReceiverVelocity)
        local _velocitySqrtMag = math.sqrt(velocityMag)
        local inverseVelocityMag = (_breakAccelerate + _airFriction * _velocitySqrtMag) * _dt
        if velocityMag < inverseVelocityMag then
            Vector3.Set(_v3ReceiverVelocity, 0, 0, 0)
        else
            Vector3.SetNormalize(_v3ReceiverVelocity)
            Vector3.MulNumber(_v3ReceiverVelocity, _velocitySqrtMag - inverseVelocityMag)
        end
    end

    if _hitMoveDir then
        Vector3.Project(_v3ReceiverVelocity, _hitMoveDir, _v3ReceiverVelocity)
        --LogTools.LogByLevel(LogLevel.log, "_hitMoveDir", Vector3.Magnitude(_hitMoveDir), "_v3ReceiverVelocity", Vector3.Magnitude(_v3ReceiverVelocity))
        --local _dot = Vector3.Dot(_hitMoveDir, _v3ReceiverVelocity)
        --Vector3.MulNumber(_hitMoveDir, _dot, _v3ReceiverVelocity)
    end
    Vector3.MulNumber(_v3ReceiverVelocity, _dt, _v3ReceiverPosChange)

    _vector3Pool:Push(_v3JoyInput)
    _vector3Pool:Push(_joyInputDir)
    _vector3Pool:Push(maxVelocity)
end

--- 根据四元数获得三元向量值
---@private
---@param _battleRoom BattleRoom
---@param _vec3 Vector3 三元向量
---@param _quad Quaternion 四元数
---@return number 三元向量值
function MOVE_UTILS.GetScaledMagnitudeByQuadrant(_battleRoom, _vec3, _quad)
    local _vector3Pool = _battleRoom.vector3Pool
    local _poolVec = _vector3Pool:Pop()
    Vector3.Copy(_poolVec, _vec3)
    local _coefficientCache = _vector3Pool:Pop()
    if _poolVec.x >= 0 then
        if _poolVec.z > 0 then --第一象限
            _coefficientCache:Set(_quad.w, 0 ,_quad.x)
        else    --第四象限
            _coefficientCache:Set(_quad.w, 0 ,_quad.y)
        end
    else
        if _poolVec.z > 0 then --第二象限
            _coefficientCache:Set(_quad.z, 0 ,_quad.x)
        else    --第三象限
            _coefficientCache:Set(_quad.z, 0 ,_quad.y)
        end
    end

    local _ret = Vector3.SqrMagnitude(_poolVec:MulVec3(_coefficientCache))
    _vector3Pool:Push(_poolVec)
    _vector3Pool:Push(_coefficientCache)
    return _ret
end

--- 转向算法
---@public
---@param _battleRoom BattleRoom
---@param _qReceiveFinalRotation Quaternion 用于接收计算结果的四元数
---@param _qCurRotation Quaternion 当前旋转
---@param _v3CameraParam Vector3 旋转摇杆量
---@param _fSensitivityX number x方向灵敏度
---@param _fSensitivityY number y方向灵敏度
---@param _limitAngle Vector2 转向最大夹角
---@param _qTargetRotation Quaternion 目标朝向四元数
function MOVE_UTILS.Rotate(_battleRoom, _qReceiveFinalRotation, _qCurRotation,_v3CameraParam,_fSensitivityX,_fSensitivityY,_limitAngle, _hAngleLimit, _vAngleLimit,_dt)
    local _vector3Pool = _battleRoom.vector3Pool
    local _quaternionPool = _battleRoom.quaternionPool
    local _fRotateAngleH = _v3CameraParam.x * _fSensitivityX
    local _fRotateAngleV = _v3CameraParam.y * _fSensitivityY
    
    if _hAngleLimit then
        local _fix = _fRotateAngleH > 0 and 1 or -1
        _fRotateAngleH = Mathf.Min(math.abs(_fRotateAngleH), math.abs(_hAngleLimit)) * _fix
    end
    if _vAngleLimit then
        local _fix = _fRotateAngleV > 0 and 1 or -1
        _fRotateAngleV = Mathf.Min(math.abs(_fRotateAngleV), math.abs(_vAngleLimit)) * _fix
    end
    --LogTools.LogByLevel(LogLevel.log, "rotateFix", "MOVE_UTILS.Rotate", "_hAngleLimit", _hAngleLimit, "_vAngleLimit", _vAngleLimit, "_v3CameraParam.x * _fSensitivityX", _v3CameraParam.x * _fSensitivityX, "_v3CameraParam.y * _fSensitivityY", _v3CameraParam.y * _fSensitivityY, "_fRotateAngleH", _fRotateAngleH, "_fRotateAngleV", _fRotateAngleV)

    ---当前上方向转换到世界坐标，并归一化
    local _qCurRotationInversed = _quaternionPool:Pop()
    Quaternion.Inverse(_qCurRotation, _qCurRotationInversed)
    local _v3LocalUpInWorld = _vector3Pool:Pop()
    Vector3.MulQuat(Vector3.up_global(), _qCurRotationInversed, _v3LocalUpInWorld)
    Vector3.SetNormalize(_v3LocalUpInWorld)
    
    local _qRotateChangeH = _quaternionPool:Pop()
    Quaternion.AngleNormalizedAxis(_fRotateAngleH, _v3LocalUpInWorld, _qRotateChangeH)
    local _qRotateChangeV = _quaternionPool:Pop()
    Quaternion.AngleNormalizedAxis(_fRotateAngleV, Vector3.right_global(), _qRotateChangeV)
    local _qRotateChangeAll = _quaternionPool:Pop()
    Quaternion.MulQuan(_qRotateChangeH, _qRotateChangeV, _qRotateChangeAll)
    local _qCalcFinalRotation = _quaternionPool:Pop()
    Quaternion.MulQuan(_qCurRotation, _qRotateChangeAll, _qCalcFinalRotation)
    _quaternionPool:Push(_qRotateChangeAll)
    
    
    if _hAngleLimit or _vAngleLimit then
        
        Quaternion.Copy(_qReceiveFinalRotation, _qCalcFinalRotation)

    else
        local _v3CalcFinalForward = _vector3Pool:Pop()
        Vector3.MulQuat(Vector3.forward_global(), _qCalcFinalRotation, _v3CalcFinalForward)
        local _v3CurRight = _vector3Pool:Pop()
        Vector3.MulQuat(Vector3.right_global(), _qCurRotation, _v3CurRight)
        local _fAngleVFromWorldUpToFinalForward = Vector3.AngleAroundAxis(Vector3.up_global(), _v3CalcFinalForward, _v3CurRight, _vector3Pool)
        local _v3CalcFinalUp = _vector3Pool:Pop()
        Vector3.MulQuat(Vector3.up_global(), _qCalcFinalRotation, _v3CalcFinalUp)
        local _bFinalUpPointWorldUp = (Vector3.Dot(_v3CalcFinalUp, Vector3.up_global()) > 0) --最终是否仍然朝上

        if _fAngleVFromWorldUpToFinalForward > _limitAngle.x and _fAngleVFromWorldUpToFinalForward < _limitAngle.y and _bFinalUpPointWorldUp then
            ---计算结果在俯仰范围之内，直接使用计算结果
            Quaternion.Copy(_qReceiveFinalRotation, _qCalcFinalRotation)
        else
            ---超出俯仰范围，只进行水平旋转
            Quaternion.MulQuan(_qCurRotation, _qRotateChangeH, _qReceiveFinalRotation)
        end

        _vector3Pool:Push(_v3CalcFinalForward)
        _vector3Pool:Push(_v3CurRight)
        _vector3Pool:Push(_v3CalcFinalUp)
    end

    _quaternionPool:Push(_qRotateChangeH)
    _quaternionPool:Push(_qRotateChangeV)
    _quaternionPool:Push(_qCalcFinalRotation)
    _quaternionPool:Push(_qCurRotationInversed)
    
    _vector3Pool:Push(_v3LocalUpInWorld)
end

--- 刹车算法
---@public
---@param _currentVelocity Vector3 当前速度
---@param _brakeAccelerate Vector3 刹车参数
---@param _airFriction number 空气阻力
---@param _dt number 时间
---@return Vector3 刹车之后速度
function MOVE_UTILS.Brake(_currentVelocity,_brakeAccelerate,_airFriction,_dt)
    local currentVelocity = _currentVelocity:Clone();
    local velocityMag = currentVelocity.magnitude
    local inversiveVelocityMag = (_brakeAccelerate + _airFriction * velocityMag) * _dt
    currentVelocity = currentVelocity.normalized:Mul(velocityMag - inversiveVelocityMag)

    if velocityMag < inversiveVelocityMag then
        currentVelocity = Vector3.New(0,0,0);
    end
    return currentVelocity;
end

--- 正四向闪避的方向分解线
local DashRawLimit = { 45, 90 + 45, 180 + 45, 270 + 45};
local DashLimit = nil;
--- 计算闪避方向分界线
local function CalDashCache()
    local cacheFlash = {}
    for i = 1, #DashRawLimit do
        local ind2 = i + 1
        if ind2 > #DashRawLimit then
            ind2 = 1
        end
        local dir =  Vector2.Normalize(Vector2.New(Mathf.Cos(DashRawLimit[i] * Mathf.Deg2Rad) + Mathf.Cos(DashRawLimit[ind2] * Mathf.Deg2Rad),Mathf.Sin(DashRawLimit[i] * Mathf.Deg2Rad) + Mathf.Sin(DashRawLimit[ind2] * Mathf.Deg2Rad)))
        local limit = Vector2.Dot(dir, Vector2.New(Mathf.Cos(DashRawLimit[i] * Mathf.Deg2Rad), Mathf.Sin(DashRawLimit[i] * Mathf.Deg2Rad)))
        cacheFlash[i] = Vector3.New(dir.x, dir.y, limit)
    end
    DashLimit = cacheFlash
end
CalDashCache()

--- 进入闪避
---@param _moveParam Vector3 摇杆参数
---@param _currentDirection Quaternion 当前朝向
---@param _startDashVelocity number 闪避初始速度
---@return Vector3 根据参数转换的初始速度
function MOVE_UTILS.EnterDash(_moveParam,_currentDirection,_startDashVelocity)

    local moveJoystickOffset = Vector2.New(_moveParam.x, _moveParam.y)
    local dirIndex = 1

    if moveJoystickOffset ~= Vector2.zero then
        while dirIndex + 1 <= #DashLimit and DashLimit[dirIndex + 1].z - Vector2.Dot(moveJoystickOffset, Vector2.New(DashLimit[dirIndex].x, DashLimit[dirIndex].y)) >= 0.00001 do
            dirIndex = dirIndex + 1
        end
    else
        moveJoystickOffset.x = 1
    end

    --local _forward = _currentDirection * Vector3.forward_global()
    --local _moveForward = Vector3.ProjectOnPlane(_forward, Vector3.up_global())
    --local _moveRotation = Quaternion.FromToRotation(Vector3.forward_global(), _moveForward)
    
    local _forward = _cachedV3_1
    Vector3.MulQuat(Vector3.forward_global(), _currentDirection, _forward)
    local _moveForward = _cachedV3_2
    Vector3.ProjectOnPlane(_forward, Vector3.up_global(), _moveForward)
    local _moveRotation = _cachedQuan_1
    --Quaternion.FromToRotation(Vector3.forward_global(), _moveForward, _moveRotation)
    Quaternion.LookRotation(_moveForward, Vector3.up_global(), _moveRotation, nil)

    local curVelocityDir = _moveRotation
    local requestedDir
    --摇杆产生的方向
    if dirIndex == 1 then --前
        requestedDir = (curVelocityDir * Vector3.forward).normalized
    elseif dirIndex == 2 then --左
        requestedDir = (curVelocityDir * Vector3.left).normalized
    elseif dirIndex == 3 then --后
        requestedDir = (curVelocityDir * Vector3.back).normalized
    elseif dirIndex == 4 then --右
        requestedDir = (curVelocityDir * Vector3.right).normalized
    end

    local velocity = requestedDir * _startDashVelocity;
    return velocity,dirIndex;
end

--- 进入闪避
---@param _moveParam Vector3 摇杆参数
---@param _currentDirection Quaternion 当前朝向
---@param _startDashVelocity number 闪避初始速度
---@return Vector3 根据参数转换的初始速度
function MOVE_UTILS.EnterDash_FreeFly(_moveParam,_currentDirection,_startDashVelocity)

    local moveJoystickOffset = Vector2.New(_moveParam.x, _moveParam.y)
    local dirIndex = 1

    if moveJoystickOffset ~= Vector2.zero then
        while dirIndex + 1 <= #DashLimit and DashLimit[dirIndex + 1].z - Vector2.Dot(moveJoystickOffset, Vector2.New(DashLimit[dirIndex].x, DashLimit[dirIndex].y)) >= 0.00001 do
            dirIndex = dirIndex + 1
        end
    else
        moveJoystickOffset.x = 1
    end

    local curVelocityDir = _currentDirection
    local requestedDir
    --摇杆产生的方向
    if dirIndex == 1 then --前
        requestedDir = (curVelocityDir * Vector3.forward).normalized
    elseif dirIndex == 2 then --左
        requestedDir = (curVelocityDir * Vector3.left).normalized
    elseif dirIndex == 3 then --后
        requestedDir = (curVelocityDir * Vector3.back).normalized
    elseif dirIndex == 4 then --右
        requestedDir = (curVelocityDir * Vector3.right).normalized
    end

    local velocity = requestedDir * _startDashVelocity;
    return velocity,dirIndex;
end