---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2022/3/28 22:37

require "Lib/class"
require "Battle/Logic/Buff/BattleBuffEffect"

---@class PropBattleBuffEffect : BattleBuffEffect
---@field buffInstanceId number 配置Id
---@field castParam table 最终参数
---@field customParam table 自定义参数
---@field nextTriggerTime number 下次触发时间
---@field triggerCount number 触发次数
PropBattleBuffEffect = class(BattleBuffEffect, 'PropBattleBuffEffect');

function PropBattleBuffEffect:ctor(_buffInstanceId)

    self.buffInstanceId = _buffInstanceId;
    self.castParam = nil;
    self.customParam = nil;
    self.nextTriggerTime = 0;
    self.triggerCount = 0;
    self.__unitPropAddCache = 0  --暂时先记一下，现在改起来太麻烦了

    self.storeNum = 0;
end

---触发buff
---@public
---@param _battleObject BattleObjectBase 战斗物体
---@param _battleBuff BattleBuff buff实体
---@param _stackNum number 堆叠数量
---@param _isUnitChangeLeader boolean 是否为玩家buff换人操作
function PropBattleBuffEffect:Trigger(_battleObject, _battleBuff, _stackNum,_isUnitChangeLeader)
    ----LogTools.LogByLevel(LogLevel.log, "PropBattleBuffEffect", "Trigger")
    ---@type BuffAndActionInstance
    local buffAndActionInstance = _battleObject:GetBattleRoom().inputDataSource:GetDict("BuffAndActionInstance",self.buffInstanceId);
    ---@type BuffAndActionTemplate
    local buffTemplate = _battleObject:GetBattleRoom().inputDataSource:GetDict("BuffAndActionTemplate",buffAndActionInstance.templateId)
    local _behindParam = buffTemplate.behindParam
    local _propId = _behindParam[1]
    local _propName = ProtoEnumTool.GetPropertyKey(_propId)

    if _isUnitChangeLeader and _battleObject:GetObjectId() == self.triggerObjectId then
        return;
    end

    if not _isUnitChangeLeader then
        self.triggerCount = self.triggerCount + 1;
    end
    ---@type BattleUnitCom_UnitProp
    local _unitPropCom = _battleObject:GetParentUnit():GetComponent(BattleUnitComponentType.UnitProp)
    if _unitPropCom and _unitPropCom:CheckUnitProp(_propName) then
        --这类属性填的是改变的变化值
        local add = self:GetCastParam(_battleObject)*(1+_battleBuff.upPercent[buffTemplate.metaType]);
        if buffTemplate.behindParam[5] and buffTemplate.behindParam[5] ~= 0 and add > buffTemplate.behindParam[5] then
            add = buffTemplate.behindParam[5]*(1+_battleBuff.upPercent[buffTemplate.metaType]);
        end
        if _isUnitChangeLeader then
            if buffAndActionInstance.storeTrigger == 1 then
                self.storeNum = add*_stackNum*self.triggerCount;
            else
                self.storeNum = add*_stackNum;
            end
            add = self.storeNum;
        else
            self.storeNum = self.storeNum + add*_stackNum;
            add = add * _stackNum;
        end
        if _behindParam[2] == 1 then --终值增加数值
            self.__unitPropAddCache = _unitPropCom:IncreasePropByName(_propName, add)
        else --终值增加百分比
            local _cur = _unitPropCom:GetPropByName(_propName)
            self.__unitPropAddCache = _unitPropCom:IncreasePropByName(_propName, _cur*add)
        end
        --LogTools.LogByLevel(LogLevel.log, "sprint", "self.__unitPropAddCache", self.__unitPropAddCache)
        return
    end

    ---@type BattleObjCom_Property
    local _propComp = _battleObject:GetComponent(BattleObjectComponentType.Property);
    if not _propComp then return end

    if _propComp:CheckIsConsumeProp(_propId) then
        --能量类属性
        --颜良说这类属性填的值为改变到的数值
        local _curValue = _propComp:GetPropertyById(_propId)
        local add = self:GetCastParam(_battleObject)*(1+_battleBuff.upPercent[buffTemplate.metaType]);

        if buffTemplate.behindParam[5] and buffTemplate.behindParam[5] ~= 0 and add > buffTemplate.behindParam[5] then
            add = buffTemplate.behindParam[5]*(1+_battleBuff.upPercent[buffTemplate.metaType]);
        end
        if _isUnitChangeLeader then
            if buffAndActionInstance.storeTrigger == 1 then
                self.storeNum = add*_stackNum;
            else
                self.storeNum = add*_stackNum;
            end
            add = self.storeNum;
        else
            self.storeNum = add*_stackNum;
            add = add * _stackNum;
        end
        if _behindParam[2] == 1 then --设定数值
            _propComp:SetConsumeProp(_propId, add+_curValue)
        else --设定百分比
            _propComp:SetConsumeProp(_propId, add*_curValue)
        end
    else
        --面板类属性
        --这类属性填的是改变的变化值
        local add = self:GetCastParam(_battleObject)*(1+_battleBuff.upPercent[buffTemplate.metaType]);

        if buffTemplate.behindParam[5] and buffTemplate.behindParam[5] ~= 0 and add > buffTemplate.behindParam[5] then
            add = buffTemplate.behindParam[5]*(1+_battleBuff.upPercent[buffTemplate.metaType]);
        end
        if _isUnitChangeLeader then
            if buffAndActionInstance.storeTrigger == 1 then
                self.storeNum = add*_stackNum*self.triggerCount;
            else
                self.storeNum = add*_stackNum;
            end
            add = self.storeNum;
        else
            self.storeNum = self.storeNum + add*_stackNum;
            add = add * _stackNum;
        end
        if _behindParam[2] == 1 then --终值增加数值
            _propComp:AddAdditionValueById(_behindParam[1], add)
        else --终值增加百分比
            _propComp:AddAdditionPercentById(_behindParam[1], add)
        end
    end
end

---释放buff
---@public
---@param _battleObject BattleObjectBase 战斗物体
---@param _battleBuff BattleBuff buff实体
---@param _stackNum number 堆叠数量
function PropBattleBuffEffect:Release(_battleObject, _battleBuff, _stackNum)

    if _battleObject:GetObjectId() ~= self.triggerObjectId then
        return;
    end
    
    ----LogTools.LogByLevel(LogLevel.log, "PropBattleBuffEffect", "Release")
    ---@type BuffAndActionInstance
    local buffAndActionInstance = _battleObject:GetBattleRoom().inputDataSource:GetDict("BuffAndActionInstance",self.buffInstanceId);
    ---@type BuffAndActionTemplate
    local buffTemplate = _battleObject:GetBattleRoom().inputDataSource:GetDict("BuffAndActionTemplate",buffAndActionInstance.templateId)
    local _behindParam = buffTemplate.behindParam
    local _propId = _behindParam[1]

    ---先手动判断下如果是加当前体力的，BUFF释放的时候不移除效果
    ---后面让策划走需求加字段判断是否移除
    ---正昊说的
    if _propId == ProtoEnumTool.GetPropertyId(BattlePropertyEnum.Sprint_En_Cur) then
        self.__unitPropAddCache = 0
        self.storeNum = 0
        return
    end
    
    
    local _propName = ProtoEnumTool.GetPropertyKey(_propId)

    ---@type BattleUnitCom_UnitProp
    local _unitPropCom = _battleObject:GetParentUnit():GetComponent(BattleUnitComponentType.UnitProp)
    if _unitPropCom and _unitPropCom:CheckUnitProp(_propName) then
        _unitPropCom:DecreasePropByName(_propName, self.__unitPropAddCache)
        self.__unitPropAddCache = 0
        self.storeNum = 0
        return
    end

    ---@type BattleObjCom_Property
    local _propComp = _battleObject:GetComponent(BattleObjectComponentType.Property);
    if not _propComp then
        self.storeNum = 0
        return 
    end

    --改变当前值的buff没有清除效果，颜良说的
    if _propComp:CheckIsConsumeProp(_propId) then
        self.storeNum = 0
        return 
    end 

    if _behindParam[2] == 1 then --终值增加数值
        _propComp:AddAdditionValueById(_behindParam[1], self.storeNum*-1)
    else --终值增加百分比
        _propComp:AddAdditionPercentById(_behindParam[1], self.storeNum*-1)
    end
    self.storeNum = 0
end

---@public
---@return number buff类型Id
function PropBattleBuffEffect:GetId()
    return 10;
end

return PropBattleBuffEffect;
