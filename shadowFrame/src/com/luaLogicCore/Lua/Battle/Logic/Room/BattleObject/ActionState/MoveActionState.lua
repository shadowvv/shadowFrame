---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2021/12/20 18:12
--- 移动行为状态

require "Lib/class"
require "Battle/Utils/MoveUtils"
require "Battle/Logic/Room/BattleObject/ActionState/ActionState"

---@class MoveActionState:ActionState 普通移动
---@field battleRoom BattleRoom 战斗
---@field stateParam StateParameter 状态参数配置
---@field unitType number 单位类型
---@field moveParam Vector3 移动参数
---@field targetPos Vector3 移动目标点
MoveActionState = class(ActionState,'MoveActionState');

---@param _battleId number 战斗id
---@param _stateParamId number 状态参数配置Id
---@param _unitType number 单位类型
function MoveActionState:ctor(_battleId, _stateParamId,_unitType)
    self.battleRoom = GetBattleRoom(_battleId)
    self.stateParam = self.battleRoom.inputDataSource:GetDict("StateParameter", _stateParamId);
    self.unitType = _unitType;
    self.moveParam = nil;
    self.cameraParam = nil;
    self.hitWall = false;
    self.targetPos = nil

    self.hitPosition = nil;
    self.hitMoveDir = nil;
end

---@param _moveParam Vector3 移动参数
---@param _targetPos Vector3 移动目标点
---@param _hitPosition Vector3 碰撞位置
---@param _hitMoveDir Vector3 碰撞移动方向
function MoveActionState:Init(_moveParam,_targetPos,_hitWall,_hitPosition,_hitMoveDir)
    self.moveParam = _moveParam;
    self.targetPos = _targetPos;
    if _hitWall then
        self.hitWall = _hitWall;
    end
    self.hitPosition = _hitPosition;
    self.hitMoveDir = _hitMoveDir;
end

function MoveActionState:EnterAction(_actionStateManager)
    return true;
end

---@private
---@param _actionStateManager ActionStateManage
function MoveActionState:__DoAiMove(_actionStateManager,_dt,_netId,_objId, _specificMoveVelocity)

    ---有撞墙修正位置的时候，强制设置到该位置就完了
    if self.hitPosition then
        _actionStateManager:ResetPosition(self.hitPosition, _actionStateManager:GetRotation())
        self.hitPosition = nil
        --这里只重置了位置，修正方向还留着，下一帧再处理
        --self.hitMoveDir = nil
        return
    end

    local _fMaxVelocity = self.stateParam.maxVelocity * (1 + _actionStateManager:GetUnit():GetPropertyByName(BattlePropertyEnum.Speed_Add_Move))
    local _battleRoom = GetBattleRoom(_actionStateManager.battleId)
    local _vecPool = _battleRoom.vector3Pool

    ---有目标点的时候先判断当帧最大移动距离与目标点的距离
    ---当距离足够近的时候，先提前结束（直接设置的话，感觉容易出现跳的情况）
    if self.targetPos then
        ---本帧允许移动的最大距离
        local _maxPosChangeLen = _fMaxVelocity * _dt
        local _posVec = _vecPool:Pop()
        ---当前与目标点之间的距离
        Vector3.Sub(_actionStateManager:GetPosition(), self.targetPos, _posVec)
        local _sqrDisToTarget = Vector3.SqrMagnitude(_posVec)
        _vecPool:Push(_posVec)
        if _maxPosChangeLen * _maxPosChangeLen > _sqrDisToTarget then
            _actionStateManager:Exit(self)
            _actionStateManager:Idle()
            _battleRoom.battleLogicEventService:OnTriggerUnitReachPoint(_netId)
            return
        end
    end
    
    ---没有提前退出的情况，走计算公式
    local _v3CalcCurVelocity = _battleRoom.vector3Pool:Pop()   --计算得到的当前速度
    local _v3CalcPosChange = _battleRoom.vector3Pool:Pop()     --计算得到的位置变化
    local _v3CalcCurAcc = _battleRoom.vector3Pool:Pop()        --计算得到的当前加速度
    MOVE_UTILS.AiMove(_battleRoom, 
            _v3CalcCurVelocity,
            _v3CalcPosChange,
            _v3CalcCurAcc,
            self.moveParam,
            _actionStateManager:GetVelocity(),
            _actionStateManager:GetRotation(),
            self.stateParam.moveAccelerate[1],
            _fMaxVelocity,
            _actionStateManager:GetForceAcc(),
            _dt,
            self.hitMoveDir,
            _specificMoveVelocity
    )
    ---计算得到的位置变化，加到当前位置上
    Vector3.Add(_v3CalcPosChange, _actionStateManager:GetPosition(), _v3CalcPosChange)
    
    _actionStateManager:SetVelocity(_v3CalcCurVelocity)
    _actionStateManager:SetAccelerate(_v3CalcCurAcc)
    _actionStateManager:SetPosition(_v3CalcPosChange)
    _vecPool:Push(_v3CalcCurVelocity)
    _vecPool:Push(_v3CalcCurAcc)
    _vecPool:Push(_v3CalcPosChange)

    ---移动结束检查是否到达目标点
    ---这里直接return了，退出状态的时候会把最后一次移动消息发过去，这里不需要再发一次
    if Vector3.CloseEnough(self.targetPos, _actionStateManager:GetPosition(), _actionStateManager:GetUnit():GetCollisionRadius()) then
        _actionStateManager:Exit(self)
        _actionStateManager:Idle()
        _battleRoom.battleLogicEventService:OnTriggerUnitReachPoint(_netId)
        return
    end
    
    ---发送移动消息
    local battleUnitMoveOutput = {}
    battleUnitMoveOutput.v = _actionStateManager:GetVelocity()
    battleUnitMoveOutput.position = _actionStateManager:GetPosition()
    battleUnitMoveOutput.rotation = _actionStateManager:GetRotation()
    battleUnitMoveOutput.accelerate = _actionStateManager:GetAccelerate()
    battleUnitMoveOutput.moveParam = _actionStateManager.moveParam
    battleUnitMoveOutput.cameraParam = _actionStateManager.cameraParam
    battleUnitMoveOutput.airFriction = self.stateParam.airFriction
    battleUnitMoveOutput.breakAcc = self.stateParam.breakAccelerate
    battleUnitMoveOutput.maxVelocity = _fMaxVelocity
    battleUnitMoveOutput.forceAcc = _actionStateManager:GetForceAcc()
    battleUnitMoveOutput.type = self:GetId()
    local battleUnitMoveData = {}
    battleUnitMoveData.netId = _netId
    battleUnitMoveData.objId = _objId
    battleUnitMoveData.moveInfo = battleUnitMoveOutput
    _battleRoom.outputDataSource:AddBattleUnitMoveData(battleUnitMoveData)

    self.hitMoveDir = nil
end

function MoveActionState:DoAction(_actionStateManager,_dt,_netId,_objId, _specificMoveVelocity)
    if not _actionStateManager:GetUnit():CheckUnitType(BattleUnitType.Player) then
        self:__DoAiMove(_actionStateManager,_dt,_netId,_objId, _specificMoveVelocity)
        return
    end

    ---某些功能强制指定了移动方向
    if _specificMoveVelocity then
        _actionStateManager:SetVelocity(_specificMoveVelocity)
    end
    
    
    local _battleRoom = GetBattleRoom(_actionStateManager.battleId)

    local _v3FinalPosition = _battleRoom.vector3Pool:Pop(_actionStateManager:GetPosition())
    local _v3FinalVelocity = _battleRoom.vector3Pool:Pop(_actionStateManager:GetVelocity())
    local _v3FinalAccelerate = _battleRoom.vector3Pool:Pop(_actionStateManager:GetAccelerate())
    if self.hitPosition then
		Vector3.Copy(_v3FinalPosition, self.hitPosition)
    end
    
    local _fMaxVelocity = self.stateParam.maxVelocity * (1 + _actionStateManager:GetUnit():GetPropertyByName(BattlePropertyEnum.Speed_Add_Move))

    local _qMoveAcc = _battleRoom.quaternionPool:Pop()
    Quaternion.Set(_qMoveAcc, self.stateParam.moveAccelerate[1],self.stateParam.moveAccelerate[2],self.stateParam.moveAccelerate[3],self.stateParam.moveAccelerate[4])
    --当前位置
    local _v3CurPosReadOnly = _actionStateManager:GetPosition()
    --移动的目标位置
    local _v3TargetPosReadOnly = self.targetPos

    if not _v3TargetPosReadOnly or _v3TargetPosReadOnly ~= _v3CurPosReadOnly then

        local _v3CalcCurVelocity = _battleRoom.vector3Pool:Pop()   --计算得到的当前速度
        local _v3CalcPosChange = _battleRoom.vector3Pool:Pop()     --计算得到的位置变化
        local _v3CalcCurAcc = _battleRoom.vector3Pool:Pop()        --计算得到的当前加速度
        local _v3CalcFinalPos = _battleRoom.vector3Pool:Pop()      --计算得到的最终位置

        if _battleRoom.battleLevelManager.levelConfigManager:GetLevelInstanceXls().controlMode == 0 then
            MOVE_UTILS.Move(self.battleRoom,
                    _v3CalcCurVelocity,
                    _v3CalcPosChange,
                    _v3CalcCurAcc,
                    self.moveParam,
                    _actionStateManager:GetVelocity(),
                    _actionStateManager:GetRotation(),
                    _qMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    _actionStateManager:GetForceAcc(),
                    _dt,
                    self.hitMoveDir)
        else
            MOVE_UTILS.Move_FreeFly(self.battleRoom,
                    _v3CalcCurVelocity,
                    _v3CalcPosChange,
                    _v3CalcCurAcc,
                    self.moveParam,
                    _actionStateManager:GetVelocity(),
                    _actionStateManager:GetRotation(),
                    _qMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    _actionStateManager:GetForceAcc(),
                    _dt,
                    self.hitMoveDir)
        end
        
        Vector3.Add(_v3CurPosReadOnly, _v3CalcPosChange, _v3CalcFinalPos)
        
        if _v3TargetPosReadOnly then --有目标点的时候需要检查是否移动超过了目标
            local _dir1 = _battleRoom.vector3Pool:Pop()
            local _dir2 = _battleRoom.vector3Pool:Pop()
            Vector3.Sub(_v3TargetPosReadOnly, _v3CurPosReadOnly, _dir1)
            Vector3.Sub(_v3TargetPosReadOnly, _v3CalcFinalPos, _dir2)
            local _checkDot = Vector3.Dot(_dir1, _dir2)
            if _checkDot < 0 then --超过终点，以终点作为移动结果
                Vector3.Copy(_v3FinalPosition, _v3TargetPosReadOnly)
            else  --没超过终点，以计算得到的结果作为移动结果
                Vector3.Copy(_v3FinalPosition, _v3CalcFinalPos)
                Vector3.Copy(_v3FinalVelocity, _v3CalcCurVelocity)
                Vector3.Copy(_v3FinalAccelerate, _v3CalcCurAcc)
            end
            _battleRoom.vector3Pool:Push(_dir1)
            _battleRoom.vector3Pool:Push(_dir2)
        else --没有目标点的时候直接使用计算得到的结果作为移动结果
            Vector3.Copy(_v3FinalPosition, _v3CalcFinalPos)
            Vector3.Copy(_v3FinalVelocity, _v3CalcCurVelocity)
            Vector3.Copy(_v3FinalAccelerate, _v3CalcCurAcc)
        end

        _battleRoom.vector3Pool:Push(_v3CalcCurVelocity)
        _battleRoom.vector3Pool:Push(_v3CalcPosChange)
        _battleRoom.vector3Pool:Push(_v3CalcCurAcc)
        _battleRoom.vector3Pool:Push(_v3CalcFinalPos)
    end
    if not self.hitWall then
        _actionStateManager:SetPosition(_v3FinalPosition)
    end
    _actionStateManager:SetVelocity(_v3FinalVelocity)
    _actionStateManager:SetAccelerate(_v3FinalAccelerate)
    _battleRoom.vector3Pool:Push(_v3FinalPosition)
    _battleRoom.vector3Pool:Push(_v3FinalVelocity)
    _battleRoom.vector3Pool:Push(_v3FinalAccelerate)
    _battleRoom.quaternionPool:Push(_qMoveAcc)

    local reach = true;
    local check = self.targetPos ~= nil;
    if self.targetPos ~= nil and not Vector3.CloseEnough(self.targetPos, _actionStateManager:GetPosition(), _actionStateManager:GetUnit():GetCollisionRadius()) then
        --LogTools.LogByLevel(LogLevel.log, "checkMove", "not reach", "target", self.targetPos, "netId", _actionStateManager:GetUnit():GetNetId(), "dis", Vector3.Distance(self.targetPos, _actionStateManager:GetPosition()), "radius", _actionStateManager:GetUnit():GetCollisionRadius())
        reach = false;
    end
    if check and reach then
        _actionStateManager:Exit(self);
        _actionStateManager:Idle();
        _battleRoom.battleLogicEventService:OnTriggerUnitReachPoint(_netId);
        return;
    end
    if _actionStateManager:GetVelocity() == Vector3.zero_global() and self.moveParam == Vector3.zero_global() then
        _actionStateManager:Exit(self);
        _actionStateManager:Idle();
        return;
    end
    
    
    local battleUnitMoveOutput = {};
    battleUnitMoveOutput.v = _actionStateManager:GetVelocity();
    battleUnitMoveOutput.position = _actionStateManager:GetPosition()
    battleUnitMoveOutput.rotation = _actionStateManager:GetRotation()
    battleUnitMoveOutput.accelerate = _actionStateManager:GetAccelerate()
    battleUnitMoveOutput.moveParam = _actionStateManager.moveParam;
    battleUnitMoveOutput.cameraParam = _actionStateManager.cameraParam;
    battleUnitMoveOutput.airFriction = self.stateParam.airFriction;
    battleUnitMoveOutput.breakAcc = self.stateParam.breakAccelerate;
    battleUnitMoveOutput.maxVelocity = _fMaxVelocity;
    battleUnitMoveOutput.forceAcc = _actionStateManager:GetForceAcc();
    battleUnitMoveOutput.type = self:GetId();

    local battleUnitMoveData = {};
    battleUnitMoveData.netId = _netId;
    battleUnitMoveData.objId = _objId;
    battleUnitMoveData.moveInfo = battleUnitMoveOutput;

    _battleRoom.outputDataSource:AddBattleUnitMoveData(battleUnitMoveData);
    
    self.hitPosition = nil;
    self.hitMoveDir = nil;
end

-- 退出行为
---@param _actionStateManager ActionStateManage 行为管理器
---@param _isBreak boolean 是否为打断退出
---@param _isActive boolean 是否为主动打断
function MoveActionState:ExitAction(_actionStateManager,_isBreak,_isActive)

    _actionStateManager:SetVelocity(Vector3.zero_local());

    local maxVelocity = self.stateParam.maxVelocity * (1 + _actionStateManager:GetUnit():GetPropertyByName(BattlePropertyEnum.Speed_Add_Move));
    local battleUnitMoveOutput = {};
    battleUnitMoveOutput.v = _actionStateManager:GetVelocity();
    battleUnitMoveOutput.position = _actionStateManager:GetPosition();
    battleUnitMoveOutput.rotation = _actionStateManager:GetRotation();
    battleUnitMoveOutput.accelerate = Vector3.zero_local();
    battleUnitMoveOutput.moveParam = _actionStateManager.moveParam;
    battleUnitMoveOutput.cameraParam = _actionStateManager.cameraParam;
    battleUnitMoveOutput.airFriction = self.stateParam.airFriction;
    battleUnitMoveOutput.breakAcc = self.stateParam.breakAccelerate;
    battleUnitMoveOutput.maxVelocity = maxVelocity;
    battleUnitMoveOutput.forceAcc = _actionStateManager:GetForceAcc();
    battleUnitMoveOutput.type = 1;

    local battleUnitMoveData = {};
    battleUnitMoveData.netId = _actionStateManager:GetUnit():GetNetId();
    battleUnitMoveData.objId = _actionStateManager:GetUnit():GetCurrentHeroObjectId();
    battleUnitMoveData.moveInfo = battleUnitMoveOutput;

    self.battleRoom.outputDataSource:AddBattleUnitMoveData(battleUnitMoveData);
    
    self.moveParam = nil
    self.hitPosition = nil
    self.hitMoveDir = nil
end

-- 是否为主动状态
---@return boolean 是否为主动状态
function MoveActionState:IsActive()
    return true;
end

function MoveActionState:GetId()
    return 2;
end

---获得状态冲突表
---@return StateSwitchRule
function MoveActionState:GetSwitchRule()
    return self.battleRoom.inputDataSource:GetDict("StateSwitchRule",self:GetId());
end

-- 技能移动数据叠加逻辑部分 start ---------------------------------------------------------------------
---@param _actionStateManager ActionStateManage 行为管理器
---@param _battleRoom BattleRoom 战斗管理器
function MoveActionState:SkillAddMove(_actionStateManager,_battleRoom,_v3CalcCurVelocity,_v3CalcPosChange,
                                      _v3CalcCurAcc,_qMoveAcc,_fMaxVelocity,_dt)
    ---@type Vector3[]
    local _posChange = {}
    ---@type number[] 记录已经到时的ID
    local removeIds = {}
    
    for i,v in pairs(_actionStateManager.skillAddMove) do
        if _actionStateManager.skillAddMoveTime[i] and _actionStateManager.skillAddMoveTime[i] > 0 then
            _actionStateManager.skillAddMoveTime[i] = _actionStateManager.skillAddMoveTime[i] - _dt
            -- 将所有的技能位移和前面的普通位移相加
            local _skillVelocity = _battleRoom.vector3Pool:Pop()   --计算得到的当前速度
            local _skillPosChange = _battleRoom.vector3Pool:Pop()  --计算得到的位置变化
            local _skillCurAcc = _battleRoom.vector3Pool:Pop()     --计算得到的当前加速度
            self:SKillMoveCompute(_actionStateManager,_battleRoom,_skillVelocity,_skillPosChange,_skillCurAcc,
                    v,_qMoveAcc,_fMaxVelocity,_dt)
            
            table.insert(_posChange,_skillPosChange)
            
            _battleRoom.vector3Pool:Push(_skillVelocity)
            _battleRoom.vector3Pool:Push(_skillCurAcc)
        else
            table.insert(removeIds,i)
        end
    end
    
    for i,v in pairs(removeIds) do
        if _actionStateManager.skillAddMove[v] then
            _actionStateManager.skillAddMove[v] = nil
        end
        if _actionStateManager.skillAddMoveTime[v] then
            _actionStateManager.skillAddMoveTime[v] = nil
        end
        if _actionStateManager.skillAddMoveDirectional[v] then
           _battleRoom.quaternionPool:Push(_actionStateManager.skillAddMoveDirectional[v])
            _actionStateManager.skillAddMoveDirectional[v] = nil
        end
    end

    local isNil = true
    -- 没有了就结束此行为
    for i,v in pairs(_actionStateManager.skillAddMoveTime) do
        isNil = false
    end
    if isNil then
        _actionStateManager.hasSkillAddMove = false
    end
    
    for i,v in pairs(_posChange) do
        Vector3.Add(_v3CalcPosChange, v)
        _battleRoom.vector3Pool:Push(v)
    end
end

---@param _actionStateManager ActionStateManage 行为管理器
---@param _battleRoom BattleRoom 战斗管理器
function MoveActionState:SKillMoveCompute(_actionStateManager,_battleRoom,_skillVelocity,_skillPosChange,
                                          _skillCurAcc, _param,_qMoveAcc,_fMaxVelocity,_dt)
    -- 修改速度
    if _param.speedType == 1 then
        local newMove = Vector3.zero_local()
        local moveParam = Vector3.zero_local()
        local skillRotation = _battleRoom.quaternionPool:Pop()    -- 建立转向四元数
        -- 1:自身坐标系   2:世界坐标系   3:瞄准目标
        if _param.coordinateType == 1 then
            --TODO 自身坐标系待做
            Vector3.Set(newMove,_param.vector.x * _param.size,_param.vector.y * _param.size,
                    _param.vector.z * _param.size)

            -- 是否开启方向变换
            if _param.directional then
                skillRotation = Quaternion.Clone(_actionStateManager:GetRotation())
                -- 需要根据方向修改摇杆或者速度方向
                Vector3.MulQuat(newMove, skillRotation)
            else
                -- 记录下初始值
                if not _actionStateManager.skillAddMoveDirectional[_param.id] then
                    skillRotation = Quaternion.Clone(_actionStateManager:GetRotation())
                    _actionStateManager.skillAddMoveDirectional[_param.id] = skillRotation
                else
                    skillRotation = _actionStateManager.skillAddMoveDirectional[_param.id]
                end
                -- 需要根据方向修改摇杆或者速度方向
                Vector3.MulQuat(newMove, skillRotation)
            end
        elseif _param.coordinateType == 2 then
            -- 世界坐标系
            Vector3.Set(newMove,_param.vector.x * _param.size,_param.vector.y * _param.size,
                    _param.vector.z * _param.size)
        elseif _param.coordinateType == 3 then
            --TODO 瞄准目标待做
        end

        if _battleRoom.battleLevelManager.levelConfigManager:GetLevelInstanceXls().controlMode == 0 then
            MOVE_UTILS.Move(self.battleRoom,
                    _skillVelocity,
                    _skillPosChange,
                    _skillCurAcc,
                    moveParam,
                    newMove,
                    skillRotation,
                    _qMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    Vector3.zero_local(),
                    _dt)
            _battleRoom.quaternionPool:Push(skillRotation)
        else
            MOVE_UTILS.Move_FreeFly(self.battleRoom,
                    _skillVelocity,
                    _skillPosChange,
                    _skillCurAcc,
                    moveParam,
                    newMove,
                    skillRotation,
                    _qMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    Vector3.zero_local(),
                    _dt)
            _battleRoom.quaternionPool:Push(skillRotation)
        end
        
    end
    -- 修改加速度
    if _param.speedType == 2 then
        local newAcc = Vector3.New(_param.vector.x * _param.size,_param.vector.y * _param.size,
                _param.vector.z * _param.size)
        local _newMoveAcc = Quaternion.Clone(_qMoveAcc)    -- 克隆值用于计算
        local skillAcc = _battleRoom.quaternionPool:Pop()    -- 建立加速度四元数
        local skillRotation = _battleRoom.quaternionPool:Pop()    -- 建立转向四元数
        Quaternion.FromEuler(newAcc,skillAcc)    -- param值转四元数
        -- 1:自身坐标系   2:世界坐标系   3:瞄准目标
        if _param.coordinateType == 1 then
            --TODO 自身坐标系待做
            Quaternion.Set(_newMoveAcc, _newMoveAcc.x + skillAcc.x,
                    _newMoveAcc.y + skillAcc.y,
                    _newMoveAcc.z + skillAcc.z,
                    _newMoveAcc.w + skillAcc.w)
            
            -- 是否开启方向变换
            if _param.directional then
                skillRotation = Quaternion.Clone(_actionStateManager:GetRotation())
            else
                -- 记录下初始值
                if not _actionStateManager.skillAddMoveDirectional[_param.id] then
                    skillRotation = Quaternion.Clone(_actionStateManager:GetRotation())
                    _actionStateManager.skillAddMoveDirectional[_param.id] = skillRotation
                else
                    skillRotation = _actionStateManager.skillAddMoveDirectional[_param.id]
                end
            end
        elseif _param.coordinateType == 2 then
            -- 世界坐标系
            Quaternion.Set(_newMoveAcc, _newMoveAcc.x + skillAcc.x,
                    _newMoveAcc.y + skillAcc.y,
                    _newMoveAcc.z + skillAcc.z,
                    _newMoveAcc.w + skillAcc.w)
        elseif _param.coordinateType == 3 then
            --TODO 瞄准目标待做
        end
        if _battleRoom.battleLevelManager.levelConfigManager:GetLevelInstanceXls().controlMode == 0 then
            MOVE_UTILS.Move(self.battleRoom,
                    _skillVelocity,
                    _skillPosChange,
                    _skillCurAcc,
                    self.moveParam,
                    _actionStateManager:GetVelocity(),
                    skillRotation,
                    _newMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    Vector3.zero_local(),
                    _dt)
        else
            MOVE_UTILS.Move_FreeFly(self.battleRoom,
                    _skillVelocity,
                    _skillPosChange,
                    _skillCurAcc,
                    self.moveParam,
                    _actionStateManager:GetVelocity(),
                    skillRotation,
                    _newMoveAcc,
                    self.stateParam.airFriction,
                    self.stateParam.breakAccelerate,
                    _fMaxVelocity,
                    Vector3.zero_local(),
                    _dt)
        end
        
        --_battleRoom.quaternionPool:Push(_newMoveAcc)
        _battleRoom.quaternionPool:Push(skillAcc)
        _battleRoom.quaternionPool:Push(skillRotation)
    end
end
-- 技能移动数据叠加逻辑部分 end -----------------------------------------------------------------------
return MoveActionState;