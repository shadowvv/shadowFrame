---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2022/8/9 18:35

require "Lib/class"
require "Battle/Logic/Room/BattleField/OcTree/OcTreeNode"

---八叉树根节点
---@class OcTreeRoot : table
---@field root OcTreeNode 八叉树根节点
---@field allNodes OcTreeNode[] 所有节点
OcTreeRoot = class(nil, 'OcTreeRoot');

---八叉树常量
OCTREE_CONSTANCE = {
    --节点单位容量
    TREE_NODE_OBJECT_CAPACITY = 20;
    --八叉树初始深度
    TREE_INIT_DEPTH = 1;
    --八叉树最大深度
    TREE_MAX_DEPTH = 1;
}

function OcTreeRoot:ctor()
    self.root = nil;
    self.allNodes = {};
    self.objects = {};
end

---@public 初始化八叉树
---@param _battleFiledData table 战场基础数据
function OcTreeRoot:Init(_battleFiledData)
    local leftOuterBottom = Vector3.New(-500,-500,-500);
    local rightInnerTop = Vector3.New(500,500,500);
    self.root = OcTreeNode.New(0,1,leftOuterBottom,rightInnerTop,nil,self);
    self.allNodes[self.root.nodeId] = self.root;

    if OCTREE_CONSTANCE.TREE_INIT_DEPTH > 1 then
        self.root:GenerateNextNodes();
        ---@type OcTreeNode[]
        local leaf = self.root.nextNodes;

        for i = 1, OCTREE_CONSTANCE.TREE_INIT_DEPTH - 2 do
            ---@type OcTreeNode[]
            local tempNodes = {};
            for i, next in pairs(leaf) do
                next:GenerateNextNodes();
                for i, v in pairs(next.nextNodes) do
                    table.insert(tempNodes,v);
                end
            end
            leaf = tempNodes;
        end
    end
end

---@public 添加单位
---@param _object ObjectCollider 场景单位
function OcTreeRoot:AddObject(_object)
    local include = self.root:AddObject(_object,false);
    if not include then
        self.objects[_object:GetObjectId()] = _object;
    else
        self.objects[_object:GetObjectId()] = nil;
    end
end

---@public 移除单位
---@param _object ObjectCollider 场景单位
function OcTreeRoot:RemoveObject(_object)
    for i, v in pairs(_object.nodeIndex) do
        local node = self.allNodes[v]
        if node then
            node:RemoveObject(_object);
        end
    end
    _object.nodeIndex = {};
end

---@public 单位移动
---@param _object ObjectCollider 场景单位
---@param _positionChange Vector3 移动方向
---@param _rotationChange table 移动目标
---@return ObjectCollider[] 碰撞单位
function OcTreeRoot:ObjectMoveTest(_object,_positionChange,_rotationChange)

    ---@type ObjectCollider
    local targetObjectCollider = ObjectCollider.New();
    ---@type BaseCollider[]
    local targetCollider = {};
    for i, v in pairs(_object.originalCollider) do
        ---@type BaseCollider
        local tempCollider = v:Copy();
        tempCollider:Reset(_positionChange,_rotationChange)
        table.insert(targetCollider,tempCollider);
    end
    targetObjectCollider.collider = targetCollider;
    targetObjectCollider.nodeIndex = {};

    if _object.objectType == BattleUnitType.Monster and _object.templateXls.battleSmallHpType ~= 3 then
        self:UpdateCollider(_object,targetObjectCollider)
        return {};
    end

    local collisionObjects = self.root:ObjectMove(_object,targetObjectCollider);
    if #collisionObjects <= 0 then
        for i, nodeObject in pairs(self.objects) do
            if nodeObject:GetObjectId() ~= _object:GetObjectId() then
                if nodeObject.objectType ~= BattleUnitType.Monster or (nodeObject.objectType == BattleUnitType.Monster and nodeObject.templateXls.battleSmallHpType == 3) then
                    for i, targetCollider in pairs(targetCollider) do
                        for i, v in pairs(nodeObject.collider) do
                            if CollisionService:CheckObjectCollision(targetCollider,v) then
                                table.insert(collisionObjects,v);
                            end
                        end
                    end
                end
            end
        end
    end

    if #collisionObjects <= 0 then
        self:UpdateCollider(_object,targetObjectCollider)
    end
    return collisionObjects;
end

function OcTreeRoot:UpdateCollider(_object,_targetObjectCollider)
    self:RemoveObject(_object);

    _object.collider = _targetObjectCollider.collider;
    _object.nodeIndex = _targetObjectCollider.nodeIndex;
    if #_object.nodeIndex <= 0 then
        self.objects[_object:GetObjectId()] = _object;
    else
        for i, v in pairs(_object.nodeIndex) do
            self.allNodes[v]:AddObject(_object,true);
        end
    end
end

return OcTreeRoot;