---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2022/8/9 16:08

require "Lib/class"

---@class CollisionService : table
CollisionService = class(nil, 'CollisionService');

function CollisionService:ctor()

end

---@public
---检测单位是否在节点内
---@param _node OcTreeNode 八叉树节点
---@param _baseCollider BaseCollider 单位
---@return boolean
function CollisionService:CheckObjectInOrCrossNode(_node, _baseCollider)
    return self:CheckOBBBoxCollision(_node.OBBBox, _baseCollider);
end

---@public 检测碰撞体碰撞
---@param _leftObject BaseCollider
---@param _rightObject BaseCollider
---@return boolean
function CollisionService:CheckObjectCollision(_leftObject,_rightObject)
    return self:CheckOBBBoxCollision(_leftObject,_rightObject);
end

---@public
---OBB碰撞检测
---@param _leftOBB OBBBox
---@param _rightOBB OBBBox
---@return boolean
function CollisionService:CheckOBBBoxCollision(_leftOBB,_rightOBB)
    local leftX = _leftOBB.vertex[2] - _leftOBB.vertex[1];
    local leftY = _leftOBB.vertex[3] - _leftOBB.vertex[1];
    local leftZ = _leftOBB.vertex[4] - _leftOBB.vertex[1];
    local rightX = _rightOBB.vertex[2] - _rightOBB.vertex[1];
    local rightY = _rightOBB.vertex[3] - _rightOBB.vertex[1];
    local rightZ = _rightOBB.vertex[4] - _rightOBB.vertex[1];

    --local leftX = _leftOBB.axisX;
    --local leftY = _leftOBB.axisY;
    --local leftZ = _leftOBB.axisZ;
    --local rightX = _rightOBB.axisX;
    --local rightY = _rightOBB.axisY;
    --local rightZ = _rightOBB.axisZ;

    ---@type Vector3
    local cross1 = Vector3.Cross(leftX,rightX);
    ---@type Vector3
    local cross2 = Vector3.Cross(leftX,rightY);
    ---@type Vector3
    local cross3 = Vector3.Cross(leftX,rightZ);
    ---@type Vector3
    local cross4 = Vector3.Cross(leftY,rightX);
    ---@type Vector3
    local cross5 = Vector3.Cross(leftY,rightY);
    ---@type Vector3
    local cross6 = Vector3.Cross(leftY,rightZ);
    ---@type Vector3
    local cross7 = Vector3.Cross(leftZ,rightX);
    ---@type Vector3
    local cross8 = Vector3.Cross(leftZ,rightY);
    ---@type Vector3
    local cross9 = Vector3.Cross(leftZ,rightZ);

    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,leftX) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,leftY) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,leftZ) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,rightX) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,rightY) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,rightZ) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross1) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross2) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross3) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross4) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross5) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross6) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross7) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross8) then
        return false;
    end
    if not self:IsIntersectInAxis(_leftOBB.vertex,_rightOBB.vertex,cross9) then
        return false;
    end
    return true;
end

---@param _leftVertex Vector3[]
---@param _rightVertex Vector3[]
---@param _axis Vector3
function CollisionService:IsIntersectInAxis(_leftVertex,_rightVertex,_axis)
    ---@type number[]
    local range1 = self:VertexProject(_leftVertex,_axis);
    ---@type number[]
    local range2 = self:VertexProject(_rightVertex,_axis);

    if range1[1] > range2[2] or range2[1] > range1[2] then
        return false;
    end
    return true;
end

---@param _vertex Vector3[]
---@param _axis Vector3
function CollisionService:VertexProject(_vertex,_axis)
    local range = {};
    range[1] = math.maxinteger;
    range[2] = math.mininteger;
    for i, v in pairs(_vertex) do
        local dot = Vector3.Dot(v,_axis);
        range[1] = math.min(range[1],dot);
        range[2] = math.max(range[2],dot);
    end
    return range;
end

return CollisionService;