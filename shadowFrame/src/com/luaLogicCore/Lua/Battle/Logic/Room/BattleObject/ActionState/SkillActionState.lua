---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2022/2/14 15:03

require "Lib/class"
require "Battle/Logic/Room/BattleObject/ActionState/ActionState"

---@class SkillActionState : ActionState
---@field battleRoom BattleRoom 战斗
---@field stateParam StateParameter 状态参数配置
---@field unitType number 单位类型
---@field skillModel SkillModel 技能树
---@field currentNodes SkillBaseNode[] 当前帧节点
---@field nodeStartRunTimes number[] 节点执行时间
---@field nodeRunOvers number[] 节点执行结束
---@field loopInfos number[] 循环信息
SkillActionState = class(ActionState, 'SkillActionState');

---@param _battleId number 战斗id
---@param _stateParamId number 状态参数配置id
---@param _unitType number 单位类型
---@param _skillId number 技能Id
---@param _objectId number 释放的角色id
function SkillActionState:ctor(_battleId, _stateParamId, _unitType, _skillId, _objectId)
    self.battleRoom = GetBattleRoom(_battleId)
    self.stateParam = self.battleRoom.inputDataSource:GetDict("StateParameter", _stateParamId);
    self.unitType = _unitType;
    self.skillModel = self.battleRoom.inputDataSource:GetSkillModel(_skillId);
    self.currentNodes = {};
    self.nodeStartRunTimes = {};
    self.nodeRunOvers = {};
    self.loopInfos = {};
    self.objectId = _objectId;
    self.isBreak = false;
    self.isSkillCastNodeOver = true;

    self.skillType = 1;
    ---@type Skill
    local skillConfig = self.battleRoom.inputDataSource:GetDict("Skill",self.skillModel.skillId);
    if skillConfig then
        self.skillType = skillConfig.skillType;
    end
    self.switchRule = self.battleRoom.inputDataSource:GetDict("StateSwitchRule",self:GetId());
end

-- 切换行为,判断行为的参数正确性
---@param _actionStateManager ActionStateManage 行为管理器
---@return boolean 是否可进入行为
function SkillActionState:EnterAction(_actionStateManager)
    local _curHero = _actionStateManager:GetUnit():GetHeroObject(self.objectId);
    ---@type BattleObjCom_Skill
    local componentSkill = _curHero:GetComponent(BattleObjectComponentType.Skill);
    if not componentSkill:CheckCastSKill(self.skillModel.skillId) then
        return false;
    end

    --local moveState = _actionStateManager:GetCurrentMoveState();
    --if moveState and moveState:GetId() == SprintActionState:GetId() then
    --    ---@type Skill
    --    local skillConfig = self.battleRoom.inputDataSource:GetDict("Skill",self.skillModel.skillId);
    --    if skillConfig.skillType ~= SkillTypeEnum.NORMAL:GetId() then
    --        return false;
    --    end
    --end

    self:EnterNode(self.skillModel.startNodeId, TimeUtils.battleNow(_actionStateManager.battleId));
    self.skillInstId = self.battleRoom.idCreator:GetAndIncreaseSkillInstId();
    return true;
end

---进入节点
---@public
---@param _nodeId number 节点id
function SkillActionState:EnterNode(_nodeId, _now)
    self.currentNodes[_nodeId] = self:GetModeNode(_nodeId);
    self.nodeStartRunTimes[_nodeId] = _now;
    --LogTools.LogByLevel(LogLevel.log,"enter skill node",self.currentNodes[_nodeId].__cname);
end

---获得节点
---@protected
---@param _nodeId number 节点id
---@return SkillBaseNode 节点信息
function SkillActionState:GetModeNode(_nodeId)
    for i, v in pairs(self.skillModel.allNodes) do
        if v.nodeId == _nodeId then
            return v
        end
    end
    return nil
end

-- 执行行为
---@param _actionStateManager ActionStateManage 行为管理器
---@param _dt number 更新时间
---@param _netId number 单位id
---@param _objId number 单位对应实体id
function SkillActionState:DoAction(_actionStateManager, _dt, _netId,_objId)
    --if CheckLogLevel(LogLevel.log) then
    --    LogTools.LogByLevel(LogLevel.log, "SkillActionState", "DoAction", "_netId", _netId, "_objId", _objId, "skillId", self.skillModel.skillId)
    --end
    local battleSkillNodeInfos = {};
    --是否继续遍历节点
    local findNextNodes = true;
    while findNextNodes do

        findNextNodes = false;

        local over = true;
        for i, v in pairs(self.currentNodes) do
            over = false;
        end
        -- 没有下一批节点结束技能状态
        if over then
            --LogTools.LogByLevel(LogLevel.log,"netId:",_netId,"cast skill over");
            if self.isBreak then
                _actionStateManager:ExitBreakSkill();
            else
                _actionStateManager:Exit(self);
                _actionStateManager:Idle();
            end
            return;
        end

        local frameNodes = self.currentNodes;
        self.currentNodes = {};

        -- 处理当前节点
        for i, v in pairs(frameNodes) do
            if not self.nodeRunOvers[v.nodeId] then
                local runOver,nodeInfo = v:DoAction(_actionStateManager,_dt,_netId,self.skillModel,self);
                self.nodeRunOvers[v.nodeId] = runOver;
                --LogTools.LogByLevel(LogLevel.log,"netId:",_netId,"do skill node",v.__cname," is over:",self.nodeRunOvers[v.nodeId]);

                if nodeInfo ~= nil then
                    table.insert(battleSkillNodeInfos,nodeInfo);
                end
            end
        end

        -- 查找下一批节点
        for i, v in pairs(frameNodes) do
            if self.nodeRunOvers[v.nodeId] or v:AlwaysCheckOver() then
                if self.isSkillCastNodeOver == false and self.skillModel.skillCastOverNodeId == v.nodeId then
                    self.isSkillCastNodeOver = true;
                end
                v:CheckSpecialExitEvent(self.nodeStartRunTimes[v.nodeId], _netId, _actionStateManager.battleId,self.isSkillCastNodeOver);
                local nextNodes = v:CheckNextNodes(self.nodeStartRunTimes[v.nodeId], _netId, _actionStateManager.battleId);

                if nextNodes ~= nil then
                    local restore = true;
                    for i, next in pairs(nextNodes) do
                        -- 找到下一批节点，切换节点
                        if restore and not self.skillModel.allNodes[v.nodeId].once then
                            self.nodeStartRunTimes[v.nodeId] = nil;
                            self.nodeRunOvers[v.nodeId] = nil;
                        end
                        restore = false
                        self:EnterNode(next, TimeUtils.battleNow(_actionStateManager.battleId));
                        v:ExitNode(_actionStateManager);
                        findNextNodes = true;
                    end
                    if restore then
                        -- 没有满足条件的下一批节点，保留当前节点
                        self.currentNodes[v.nodeId] = v;
                    end
                else
                    --没有下一批节点
                    if not self.skillModel.allNodes[v.nodeId].once then
                        self.nodeStartRunTimes[v.nodeId] = nil;
                        self.nodeRunOvers[v.nodeId] = nil;
                        v:ExitNode(_actionStateManager);
                    end
                end
            else
                -- 节点没有做完,保留当前节点
                self.currentNodes[v.nodeId] = v;
            end
        end
    end

    local battleUnitSkill = {};
    battleUnitSkill.skillId = self.skillModel.skillId;
    battleUnitSkill.nodeInfo = battleSkillNodeInfos;

    local battleUnitKeyData = {};
    battleUnitKeyData.netId = _netId;
    battleUnitKeyData.objId = self.objectId;
    battleUnitKeyData.skillInfo = battleUnitSkill;

    self.battleRoom.outputDataSource:AddBattleUnitKeyData(battleUnitKeyData);
end

-- 退出行为
---@param _actionStateManager ActionStateManage 行为管理器
---@param _isBreak boolean 是否为打断退出
---@param _isActive boolean 是否为主动打断
function SkillActionState:ExitAction(_actionStateManager,_isBreak,_isActive)
    for i, v in pairs(self.currentNodes) do
        v:ExitNode(_actionStateManager);
    end
    if _isBreak then
        ---@type SkillBreakNode
        local breakNode = nil;
        for i, v in pairs(self.skillModel.breakNodeIds) do
            ---@type SkillBreakNode
            local tempNode = self.skillModel.allNodes[v];
            if breakNode == nil or _isActive == tempNode.isForceBreak then
                breakNode = tempNode;
            end
        end
        if breakNode then
            self.currentNodes = {};
            self.nodeStartRunTimes = {};
            self.nodeRunOvers = {};
            self.loopInfos = {};
            self:EnterNode(breakNode.nodeId, TimeUtils.battleNow(_actionStateManager.battleId));
            _actionStateManager:EnterSkillBreakNode(self);
            self.isBreak = true;
        end
    end
    local battleRoom = GetBattleRoom(_actionStateManager.battleId)
    battleRoom.battleUnitManager:UnitStopForceFaceTargetS2C(_actionStateManager:GetUnit():GetNetId());
    battleRoom.battleLogicEventService:OnTriggerSkillEndEvent(_actionStateManager:GetUnit():GetNetId(), _actionStateManager:GetUnit():GetCurrentHeroObjectId(), self.skillModel.skillId, _isBreak)
end

-- 行为状态Id
---@return number 行为状态Id 参照stateSwitchRule表
function SkillActionState:GetId()
    return 7;
end

-- 返回技能id
---@return number 技能Id
function SkillActionState:GetSkillId()
    return self.skillModel.skillId;
end

---获得状态冲突表
---@return StateSwitchRule
function SkillActionState:GetSwitchRule()
    return self.switchRule;
end

---修改状态冲突
---@param _switchRuleId number 冲突表id
function SkillActionState:ChangeSwitchRule(_switchRuleId)
    if _switchRuleId == 0 then
        self.switchRule = self.battleRoom.inputDataSource:GetDict("StateSwitchRule",self:GetId());
    else
        self.switchRule = self.battleRoom.inputDataSource:GetDict("MinStateSwitchRule",_switchRuleId);
    end
end

-- 打印Action
function SkillActionState:PrintActionLog()
    return self.__cname .. "|skillId[" .. tostring(self.skillModel.skillId) .. "]"
end

return SkillActionState;