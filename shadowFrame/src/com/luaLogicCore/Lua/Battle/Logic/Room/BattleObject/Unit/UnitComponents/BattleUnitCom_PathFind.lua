---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2022/02/21 14:13
--- Describe: 寻路组件，用于AI和移动之间的中间层
---

require "Battle/Logic/Room/BattleObject/Unit/BattleUnit_PathFindCaller"

---@class BattleUnitCom_PathFind : BattleUnitComponentBase
BattleUnitCom_PathFind = class(BattleUnitComponentBase, "BattleUnitCom_PathFind")
function BattleUnitCom_PathFind:ctor(_data)
	self:__ctor(BattleUnitComponentType.PathFind)
end

---@public
function BattleUnitCom_PathFind:Init(_battleUnit)
	self:__Init(_battleUnit)
	---@private
	self.__pathFindCnt = 0
	---@private
	self.__pathFindIndex = nil
	---路点集合
	---@private
	---@type Vector3[]
	self.__pathList = {}
	---下一个要移动到的目标点
	---@private
	---@type Vector3
	self.__nextPoint = nil
	---@private
	---@type boolean
	self.__open = false
	---@private
	---@type boolean
	self.__findPathHost = self:GetBattleRoom().behaviorProcessor:CheckMonsAIHost()
	---@private
	---@type BattleUnit_PathFindCaller
	self.__caller = nil

	---跳过寻路时用来占位的
	---@private
	---@type Vector3
	self.__skipTmpVec = Vector3.zero_local()
	---@private
	---@type Vector3
	self.__v3TargetPosCache = self:GetBattleRoom().vector3Pool:Pop()
	---@private
	---@type Vector3
	self.__tmpVector_1 = Vector3.zero_local()
	---@private
	---@type boolean
	self.__checkAreaMaxDis = _battleUnit:CheckUnitType(BattleUnitType.AreaTrigger) and _battleUnit.maxDis > -1
	local _bornPos = _battleUnit:GetBornPos()
	---@private
	---@type Vector3
	self.__lastTargetPointCache = Vector3.New(_bornPos.x, _bornPos.y, _bornPos.z)
	---@private
	---@type boolean
	self.__errTag = false
end

---@public
function BattleUnitCom_PathFind:Open(_bool)
	self.__open = _bool
	if _bool then
		self:__ClearCurPathList()
		if self.__nextPoint then
			self:GetBattleRoom().vector3Pool:Push(self.__nextPoint)
			self.__nextPoint = nil
		end
	end
end

---开始寻路
---AI控制权持有者一方调用，发起寻路请求
---@public
---@param _caller BattleUnit_PathFindCaller 调用者
---@param _skipPathFind boolean 是否跳过寻路过程
function BattleUnitCom_PathFind:StartPathFind(_caller, _skipPathFind)
	--LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StartPathFind", "_skipPathFind", _skipPathFind, "self:GetBattleRoom().indieGame", self:GetBattleRoom().indieGame)
	self:StopPathFind()

	if not _caller then return end
	self.__caller = _caller
	self.__skipPathFind = _skipPathFind
	if not self.__findPathHost then return end
	if not _caller:GetTargetPos(self.__v3TargetPosCache) then return end

	if _skipPathFind then
		self:__OnPathFindRequestBack({self.__skipTmpVec, self.__v3TargetPosCache})
		return
	end

	self:__CalculatePathFindIndex()
	local _PathFindRequest = {}
	_PathFindRequest.netId = self.__netId
	_PathFindRequest.from = self.__actionManager:GetPosition()
	_PathFindRequest.to = self.__v3TargetPosCache
	_PathFindRequest.gridSize = 3
	_PathFindRequest.requestId = self.__pathFindIndex

	if self:GetBattleRoom().indieGame then
		--LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StartPathFind 1")
		self:GetBattleRoom().outputDataSource:SendPathFindRequest_L2V(_PathFindRequest)
		--LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StartPathFind 2")
	else
		--LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StartPathFind 3")
		self:GetBattleRoom().outputDataSource:SendPathFindRequest_S2C(_PathFindRequest)
		--LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StartPathFind 4")
	end
	if self.__netId == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "BattleUnitCom_PathFind", "StartPathFind 3 _PathFindRequest", dumpTableEx(_PathFindRequest))
	end
end

---结束寻路
---@public
function BattleUnitCom_PathFind:StopPathFind()
	----LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StopPathFind", "start", "_tagOnly", _tagOnly, "self.__pathFindIndex", self.__pathFindIndex)
	if not self.__findPathHost then return end

	self:__ClearCurPathList()
	if self.__nextPoint then
		self:GetBattleRoom().vector3Pool:Push(self.__nextPoint)
		self.__nextPoint = nil
	end

	if not self.__pathFindIndex then return end
	local _PathFindRequestCancel = {}
	_PathFindRequestCancel.netId = self.__netId
	_PathFindRequestCancel.requestId = self.__pathFindIndex
	self.__pathFindIndex = nil
	
	if self:GetBattleRoom().indieGame then
		self:GetBattleRoom().outputDataSource:CancelPathFindRequest_L2V(_PathFindRequestCancel)
	else
		self:GetBattleRoom().outputDataSource:CancelPathFindRequest_S2C(_PathFindRequestCancel)
	end
	----LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "StopPathFind", "end")
end

---寻路请求返回
---这个讲道理现在只会被持有levelAi控制权一方收到
---@public
---@param _PathFindResult table battle.PathFindResult
function BattleUnitCom_PathFind:OnPathFindRequestBack(_PathFindResult)
	if self:GetUnit():GetNetId() == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "BattleUnitCom_PathFind", "CheckPathFind", "self.__pathFindIndex", self.__pathFindIndex, "_PathFindResult", dumpTableEx(_PathFindResult), "netId", self:GetUnit():GetNetId())
	end
	if not self.__pathFindIndex or _PathFindResult.requestId ~= self.__pathFindIndex then return end
	self.__pathFindIndex = nil
	
	self:__OnPathFindRequestBack(_PathFindResult.pointList)
end

---@private
---@param _pointList Vector3[]
function BattleUnitCom_PathFind:__OnPathFindRequestBack(_pointList)
	self:UpdatePathPointList(_pointList)
	
	local _MonsterSyncPathPointList_S2C = {}
	_MonsterSyncPathPointList_S2C.netId = self.__netId
	_MonsterSyncPathPointList_S2C.posList = _pointList
	self:GetBattleRoom().outputDataSource:SyncPathPointListS2C(_MonsterSyncPathPointList_S2C)
end
------------------------------------------------------------------------------------------------------------------------
---生成寻路id
---@private 
function BattleUnitCom_PathFind:__CalculatePathFindIndex()
	local _cnt = self.__pathFindCnt + 1
	if _cnt == 10000 then _cnt = 1 end
	self.__pathFindIndex = self.__netId * 10000 + _cnt
	self.__pathFindCnt = _cnt
end

------------------------------------------------------------------------------------------------------------------------
---收到服务器路点同步
---@public
---@param _pointList Vector3[]
function BattleUnitCom_PathFind:UpdatePathPointList(_pointList)
	--if self.__netId == ActionStateManage.checkNetId then
	--	LogTools.LogByLevel(LogLevel.logErr, "CheckAiMove", "CheckAiMove", "BattleUnitCom_PathFind", "CheckPathFind", "UpdatePathPointList", "self.__open", self.__open, "_pointList", dumpTableEx(_pointList))
	--end

	local _pool = self:GetBattleRoom().vector3Pool
	self:__ClearCurPathList()

	if not _pointList then return end
	local _pathList = self.__pathList
	local _len = #_pointList
	if _len > 1 then
		for i = 2, #_pointList do
			local _v = _pool:Pop(_pointList[i])
			table.insert(_pathList, _v)
		end
	end

	self:__OnMoveToPathPoint()
end

---@public
function BattleUnitCom_PathFind:Update(_deltaTime)
	if not self.__caller then return end
	if not self:__CheckUpdate(_deltaTime) then return end

	if self.__findPathHost and self.__caller:CheckRefindPath(_deltaTime) then
		self.__caller:CallPathFind()
	else
		self:__CheckArrivePoint()
		self:__CountAiMoveInput(_deltaTime)
	end
end

---@private
function BattleUnitCom_PathFind:__CheckUpdate(_deltaTime)
	if not self.__open then return false end
	if self:GetBattleRoom():CheckPauseLevelNormalLogic() then return false end
	if not self.__behavCom then
		---@type BattleUnitCom_Behav
		self.__behavCom = self.__unit:GetComponent(BattleUnitComponentType.Behav)
		if not self.__behavCom then return false end
	end
	if self.__behavCom:CheckAIPaused() then return false end
	return true
end

---@public
function BattleUnitCom_PathFind:Clear()
	self:StopPathFind()
	
	self.__pathFindCnt = nil
	self.__pathFindIndex = nil
	self.__pathList = nil
	self.__nextPoint = nil
	self.__unit = nil
	self.__netId = nil
	self.__open = nil
	self.__skipPathFind = nil
end
------------------------------------------------------------------------------------------------------------------------

---碰到障碍物
---@public
---@param _hitPos Vector3 撞墙修正位置
---@param _hitDir Vector3 撞墙修正移动方向
---@param _isEdge boolean 是否是撞到边界
function BattleUnitCom_PathFind:OnHitBlock(_hitPos, _hitDir, _isEdge)

	if self.__caller then
		self.__caller:OnHitBlock(_hitPos, _hitDir, _isEdge)
	end
	
	--寻路移动，如果不是撞到边界，会在moveActionState里修正移动,这里只需要处理撞边界的情况
	if not _isEdge then return end
	
	self:__ClearCurPathList()
	if self.__nextPoint then
		self:GetBattleRoom().vector3Pool:Push(self.__nextPoint)
		self.__nextPoint = nil
	end
	--寻路移动结束
	--self:GetBattleRoom().battleLogicEventService:OnTriggerUnitReachPoint(self.__netId)
	--if self.__caller then
	--	self.__caller:FindPathCallBack()
	--end
end


---移动达到路点的回调
---@private
function BattleUnitCom_PathFind:__OnMoveToPathPoint()
	--if self.__netId == ActionStateManage.checkNetId then
	--	LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "CheckLuaBehav", "BattleUnitCom_PathFind", "__OnMoveToPathPoint xxxx", "self.__pathList", dumpTableEx(self.__pathList))
	--end

	if self.__nextPoint then
		Vector3.Copy(self.__lastTargetPointCache, self.__nextPoint)
	end
	
	local _point = self.__pathList[1]
	if not _point then
		--寻路移动结束
		if self.__nextPoint then
			self:GetBattleRoom().vector3Pool:Push(self.__nextPoint)
			self.__nextPoint = nil
		end
		self:GetBattleRoom().battleLogicEventService:OnTriggerUnitReachPoint(self.__netId)
		self.__caller:FindPathCallBack()
	else
		local _poolVec = self.__nextPoint
		self.__nextPoint = _point
		self:GetBattleRoom().vector3Pool:Push(_poolVec)
		table.remove(self.__pathList, 1)
	end
end

---检查是否到达当前目标路点
---@private
function BattleUnitCom_PathFind:__CheckArrivePoint()
	----LogTools.LogByLevel(LogLevel.log, "BattleUnitCom_PathFind", "__CheckArrivePoint", "self.__nextPoint", self.__nextPoint, "self.__rotateModel", self.__rotateModel)

	if not self.__nextPoint then return end

	local _actionManager = self.__actionManager
	if Vector3.CloseEnough(self.__nextPoint, _actionManager:GetPosition(), _actionManager:GetUnit():GetCollisionRadius()) then
		if self.__netId == ActionStateManage.checkNetId then
			LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "BattleUnitCom_PathFind:__CheckArrivePoint CloseEnough", "self.__nextPoint", self.__nextPoint, "_actionManager:GetPosition()", _actionManager:GetPosition(), "_actionManager:GetUnit():GetCollisionRadius()", _actionManager:GetUnit():GetCollisionRadius())
		end
		self:__OnMoveToPathPoint()
	end
end

---驱动移动状态
---@private
function BattleUnitCom_PathFind:__CountAiMoveInput(_deltaTime)
	if not self.__nextPoint then return end
	local _actionManager = self.__actionManager
	if not _actionManager then return end

	if _actionManager:CheckHasForceAcc() then
		return
	end

	local _tmpVector = self.__tmpVector_1
	if self.__checkAreaMaxDis then
		Vector3.Copy(_tmpVector, self:GetUnit():GetBornPos())
		Vector3.Sub(_tmpVector, _actionManager:GetPosition())
		if Vector3.SqrMagnitude(_tmpVector) > self:GetUnit().poweredMaXDis then
			_actionManager:Exit(_actionManager:GetCurrentMoveState(), false)
			return
		end
	end
	
	Vector3.Copy(_tmpVector, self.__nextPoint)
	Vector3.Sub(_tmpVector, _actionManager:GetPosition())
	if not _actionManager:AiMove(self.__nextPoint, _tmpVector, false) then
		self:__OnMoveToPathPoint()
	end
end

---@private
function BattleUnitCom_PathFind:__ClearCurPathList()
	local _pool = self:GetBattleRoom().vector3Pool
	local _pathList = self.__pathList
	for _key, _point in pairs(_pathList) do
		if _point then
			_pool:Push(_point)
			_pathList[_key] = nil
		end
	end
end


---@public
---@return Vector3
function BattleUnitCom_PathFind:GetCurNexPoint()
	if self:GetUnit():GetNetId() == ActionStateManage.checkNetId then
		LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "BattleUnitCom_PathFind:GetCurNexPoint", "self.__nextPoint", self.__nextPoint)
	end
	return self.__nextPoint
end

return BattleUnitCom_PathFind