---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hejincheng.
--- DateTime: 2022/3/23 11:22

require "Lib/class"
require "Battle/Logic/Room/Element/ElementBall"

---@class ElementIceWindBall : ElementBall
---@field id number 冰风id
---@field maxRadius number 扩展半径
---@field maxDistance number 最大传导距离
---@field spreadTime number 传导时间
---@field maxCount number 最大传导次数
---@field initTime number 闪电球初始时间
---@field curBattleUnit BattleUnitBase 闪电球当前所在单位
---@field castUnit BattleUnitBase 释放者
---@field buffGroupId number buff id
---@field customParam table[] buff参数
---@field targetBattleUnit BattleUnitBase 闪电球传导目标单位
ElementIceWindBall = class(ElementBall, 'ElementIceWindBall');

---@public
---@param _battleUnit BattleUnitBase
---@param _castUnit BattleUnitBase
---@param _buffGroupIds number buff id
---@param _buffParam table behindParam
---@param _generateInfo table buff创建透传信息
function ElementIceWindBall:ctor(_battleUnit, _castUnit, _buffGroupIds, _buffParam, _generateInfo)
    ---@type number
    local _maxRadius = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_RADIUS_INDEX]
    ---@type number
    local _eachMaxDistance = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_DISTANCE_INDEX]
    ---@type number
    local _maxCount = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_COUNT_INDEX]
    ---@type number
    self.spreadSpeed = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_SPREAD_SPEED_INDEX]
    ---@type number
    self.spreadAccSpeed = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_SPREAD_ACC_SPEED_INDEX]
    ---@type number
    self.maxSpeed = _buffParam[BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_BALL_MAX_SPEED_INDEX]
    -- 如果最大速度还没初始速度快，就改成初始速度
    self.maxSpeed = Mathf.Max(self.spreadSpeed, self.maxSpeed)
    -- 当前速度
    self.curSpeed = self.spreadSpeed
    -- 记录当前速度值的时间戳
    self.speedRecordTime = TimeUtils.battleNow(_battleUnit.battleId)

    -- 特效id
    ---@type BattleDefault
    local _endEffectConfig = _battleUnit:GetBattleRoom().inputDataSource:GetDict("BattleDefault", BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_END_EFFECT_ID_INDEX)
    local _endEffectId = 0
    if _endEffectConfig then
        _endEffectId = _endEffectConfig.value
    else
        if CheckLogLevel(LogLevel.logErr) then
            LogTools.LogByLevel(LogLevel.logErr, "ElementBall", "BattleDefault", BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_END_EFFECT_ID_INDEX, "endEffectId nil")
        end
    end
    self.endEffectId = _endEffectId

    self:__Init(true, _battleUnit, _castUnit, _buffGroupIds, _generateInfo, _buffParam, _maxRadius, _eachMaxDistance, 0, 0, _maxCount, BATTLE_ELEMENT_CONST.ELEMENT_ICE_WIND_EFFECT_ID_INDEX)

    if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
        local _castUnitLog = "[" .. self.battleRoom.battleUnitManager:GetBattleUnitTypeName(self.castUnit:GetUnitType()) .. "][" .. self.castUnit:GetNetId() .. "][" .. tostring(self.castUnit:GetCurrentHeroObject():GetDicId()) .. "]"
        LogTools.LogByLevel(LogLevel.log, "元素", _castUnitLog .. "创建" .. self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "Buff组", dumpTableEx(_buffGroupIds), "最大半径", _maxRadius, "最大距离", _eachMaxDistance, "传播初始速度", self.spreadSpeed, "传播加速度", self.spreadAccSpeed, "最大传播速度", self.maxSpeed, "最大传导次数", _maxCount)
    end
end

-- 元素球log名字
---@protected
---@return string
function ElementIceWindBall:GetElementBallLogName()
    return "冰风球"
end


-- 记录传导到达数据
---@protected
function ElementIceWindBall:__RecordReach()
    -- 重置目标
    local distance = 0

    if self.curBattleUnit:GetActionManager() and self.targetBattleUnit:GetActionManager() then
        distance = Vector3.Distance(self.curBattleUnit:GetActionManager().position, self.targetBattleUnit:GetActionManager().position)
    end
    self.curBattleUnit = self.targetBattleUnit

    self.targetBattleUnit = nil
    self.reachedBattleUnits[tostring(self.curBattleUnit:GetNetId())] = self.curBattleUnit:GetNetId()
    --传导次数
    self.curCount = self.curCount + 1
    --传导距离
    self.curDistance = self.curDistance + distance
    --重置开始传导时间
    self.reachTargetTime = 0
    -- 计算时间
    -- Vt=V0+at
    self.curSpeed = self.curSpeed + self.spreadAccSpeed * self.spreadTime / 1000
    self.curSpeed = Mathf.Min(self.curSpeed, self.maxSpeed)
    if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
        local _curBattleUnitLog = "[" .. self.battleRoom.battleUnitManager:GetBattleUnitTypeName(self.curBattleUnit:GetUnitType()) .. "][" .. self.curBattleUnit:GetNetId() .. "][" .. self.curBattleUnit:GetCurrentHeroObjectId() .. "][" .. tostring(self.curBattleUnit:GetCurrentHeroObject():GetDicId()) .. "]"
        LogTools.LogByLevel(LogLevel.log, "元素", self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "传导到" .. _curBattleUnitLog, "传导次数", self.curCount, "传导距离", distance, "当前速度", self.curSpeed)
    end
end

-- 获取传导时间
---@protected
function ElementIceWindBall:__GetSpreadTime()
    local _targetPosition = self.targetBattleUnit:GetActionManager().position
    local _distance = Vector3.Distance(self.fromPosition, _targetPosition)

    if self.curSpeed >= self.maxSpeed then
        -- s = vt
        -- 已达到最大速度，按最大速度匀速运动
        local time = _distance / self.curSpeed * 1000
        if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
            LogTools.Debug()
            LogTools.LogByLevel(LogLevel.log, "元素", self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "<color=#FF00FF>最大速度匀速运动[公式:s = vt -> t=s/v]</color>",
                    "\n时间[" .. tostring(time) .. "] = 距离[" .. tostring(_distance) .. "] / 速度[" .. tostring(self.curSpeed) .. "]")
        end
        return time
    end

    -- t1 = (vm-v0)/a
    local t1 = (self.maxSpeed - self.curSpeed) / self.spreadAccSpeed
    -- s1 = v0t + at^2/2
    local s1 = self.curSpeed * t1 + self.spreadAccSpeed * t1 * t1 / 2

    if s1 >= _distance then
        -- 全程加速
        -- s=v0t+1/2*at^2
        -- t=(v0^2+2as)^1/2 -v0)/a
        local time = ((Mathf.Sqrt(self.curSpeed * self.curSpeed + 2 * self.spreadAccSpeed * _distance) - self.curSpeed) / self.spreadAccSpeed) * 1000
        if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
            LogTools.LogByLevel(LogLevel.log, "元素", self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "<color=#FF00FF>全程加速运动[公式:s=v0t+1/2*at^2 -> t=(v0^2+2as)^1/2 -v0)/a]</color>",
                    "\n时间[" .. tostring(time) .. "] = (根号(初速度[" .. tostring(self.curSpeed) .. "]^2 + 2 * 加速度[" .. tostring(self.spreadAccSpeed) .. "] * 距离[" .. tostring(_distance) .. "]) - 初速度[" .. tostring(self.curSpeed) .. "]) / 加速度[" .. tostring(self.spreadAccSpeed) .. "]")
        end
        return time
    else
        -- 先加速，再匀速
        -- s1 = v0t1 + 1/2at1^2(同上)
        -- s2 = vmt2
        -- s = s1 + s2
        -- t2 = (s-s1)/vm
        local t2 = (_distance - s1) / self.maxSpeed
        local time = (t1 + t2) * 1000
        if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
            LogTools.LogByLevel(LogLevel.log, "元素", self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "<color=#FF00FF>先加速后匀速运动[公式:s=v0t1 + 1/2at1^2 + vmt2] -> t2=(s-s1)/vm", "s1 = v0t1 + 1/2at1^2", "s2 = vmt2</color>",
                    "\n加速时间[" .. tostring(t1) .. "] = (最大速度[" .. tostring(self.maxSpeed) .. "] - 初速度[" .. tostring(self.curSpeed) .. "]) / 加速度[" .. tostring(self.spreadAccSpeed) .. "]",
                    "\n加速距离[" .. tostring(s1) .. "] = 初速度[" .. tostring(self.curSpeed) .. "] * 加速时间[" .. tostring(t1) .. "] + 加速度[" .. tostring(self.spreadAccSpeed) .. "] * 加速时间[" .. tostring(t1) .. "]^2 / 2",
                    "\n匀速时间[" .. tostring(t2) .. "] = (距离[" .. tostring(_distance) .. "] - 加速距离[" .. tostring(s1) .. "])/2",
                    "\n总时间[" .. tostring(time) .. "] = 加速时间["..tostring(t1).."] + 匀速时间["..tostring(t2).."]"
            )
        end
        return time
    end
end

-- 记录传导数据
---@protected
---@param _targetUnit BattleUnitBase
function ElementIceWindBall:__RecordSpread(_targetUnit)
    self.fromPosition = self.curBattleUnit:GetActionManager().position
    self.fromObjId = self.curBattleUnit:GetCurrentHeroObjectId()
    self.targetBattleUnit = _targetUnit

    self.spreadTime = self:__GetSpreadTime()
    ---@type number 传导到达时间
    self.reachTargetTime = TimeUtils.battleNow(_targetUnit.battleId) + self.spreadTime

    if LogTools.ElementBallLog and CheckLogLevel(LogLevel.log) then
        local _distance = Vector3.Distance(self.fromPosition, self.targetBattleUnit:GetActionManager().position)
        local _curBattleUnitLog = "[" .. self.battleRoom.battleUnitManager:GetBattleUnitTypeName(self.curBattleUnit:GetUnitType()) .. "][" .. self.curBattleUnit:GetNetId() .. "][" .. self.curBattleUnit:GetCurrentHeroObjectId() .. "][" .. tostring(self.curBattleUnit:GetCurrentHeroObject():GetDicId()) .. "]"
        local _targetObjectLog = "[" .. self.battleRoom.battleUnitManager:GetBattleUnitTypeName(self.targetBattleUnit:GetUnitType()) .. "][" .. self.targetBattleUnit:GetNetId() .. "][" .. self.targetBattleUnit:GetCurrentHeroObjectId() .. "][" .. tostring(self.targetBattleUnit:GetCurrentHeroObject():GetDicId()) .. "]"
        LogTools.LogByLevel(LogLevel.log, "元素", self:GetElementBallLogName() .. "[" .. tostring(self.id) .. "]", "开始传导", _curBattleUnitLog .. " -> " .. _targetObjectLog, "当前速度:" .. tostring(self.curSpeed), "传导距离:" .. tostring(_distance), "预计传导时间:" .. tostring(self.spreadTime) .. "ms")
    end
end

-- 寻找下一个目标
-- 随机选择目标
---@protected
---@return BattleUnitBase 筛选出来的目标
function ElementIceWindBall:__SelectNextTarget()
    if not self.curBattleUnit then
        return
    end

    local curPosition = self.curBattleUnit:GetActionManager().position
    -- 满足条件的目标
    local targets = {}

    -- 筛选出符合条件的最近的目标
    for _, _campType in pairs(BattleUnitCampType) do
        if BattleUnitCom_Camp.CheckCampHurtable(self.castFirstCamp, _campType) then
            -- 可攻击阵营
            local _unitList = self.battleRoom.battleUnitManager:GetUnitListByCampType(_campType, false)
            for _, _unit in pairs(_unitList) do
                if _unit then
                    ---@type number 距离
                    local _targetDistance = Vector3.Distance(_unit:GetActionManager().position, curPosition)
                    if self.curBattleUnit:GetNetId() ~= _unit:GetNetId() and self:__CheckTargetCondition(_unit, _targetDistance) then
                        table.insert(targets, _unit)
                    end
                end
            end
        end
    end

    if #targets == 0 then
        return
    end
    -- 随机选择目标
    local targetIndex = self.battleRoom.randomUtil:RandomInt(1, #targets)
    return targets[targetIndex]
end

------------------------------------------------------------------------------------------------------------------------

-- 传导到目标
---@public
function ElementIceWindBall:OnStartSpread()
    if self.fromObjId == 0 then
        -- 没有起始点，就不用推客户端了
        return
    end
    local elementData = {
        createIceWinBall = {
            id = self.id,
            targetObjId = self.targetBattleUnit:GetCurrentHeroObjectId(),
            fromObjId = self.fromObjId,
            targetObjPos = self.targetBattleUnit:GetActionManager():GetPosition(),
            fromObjPos = self.fromPosition,
            spreadSpeed = self.curSpeed,
            spreadAccSpeed = self.spreadAccSpeed,
            effectId = self.effectId,
            endEffectId = self.endEffectId,
            spreadMaxSpeed = self.maxSpeed
        }
    }
    -- 输出数据
    local outputData = {
        elementFieldInfo = elementData
    }
    self.battleRoom.outputDataSource:AddBattleFieldData(outputData)
end

return ElementIceWindBall;