---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2021/12/20 18:12
--- 行为控制器

require "Battle/Logic/Room/BattleObject/ActionState/ActionState"
require "Battle/Logic/Room/BattleObject/ActionState/IdleActionState"
require "Battle/Logic/Room/BattleObject/ActionState/MoveActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ChangeLeaderActionState"
require "Battle/Logic/Room/BattleObject/ActionState/DashActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ReloadPreActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ReloadAfterActionState"
require "Battle/Logic/Room/BattleObject/ActionState/SprintActionState"
require "Battle/Logic/Room/BattleObject/ActionState/SkillActionState"
require "Battle/Logic/Room/BattleObject/ActionState/SpawnActionState"
require "Battle/Logic/Room/BattleObject/ActionState/DeadActionState"
require "Battle/Logic/Room/BattleObject/ActionState/BeHitActionState"
require "Battle/Logic/Room/BattleObject/ActionState/BeatDownActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ExileActionState"
require "Battle/Logic/Room/BattleObject/ActionState/TrappedActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ChangePeriodActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ReviveActionState"
require "Battle/Logic/Room/BattleObject/ActionState/TurnActionState"
require "Battle/Logic/Room/BattleObject/ActionState/RepelActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ObjectDeadActionState"
require "Battle/Logic/Room/BattleObject/ActionState/NormalSkillActionState"
require "Battle/Logic/Room/BattleObject/ActionState/ActiveSkillActionState"
require "Battle/Logic/Room/BattleObject/ActionState/JiZouSkillActionState"

---@class ActionStateManage : table
---@field currentStates ActionState[] 战斗单位当前行为
---@field stateChange number[] 状态改变id集合
---@field battleUnit BattleUnitBase 所属Unit
---@field moveParam Vector3 移动摇杆参数
---@field cameraParam Vector3 镜头摇杆参数
---@field hitWall boolean 客户端发送是否撞墙
---@field position Vector3 位置
---@field rotation Quaternion 朝向
---@field velocity Vector3 速度
---@field scale Vector3 缩放比例
---@field changeLeaderTime number 角色切换时间ms,检查换人cd用
---@field blockKeys number[] 输入屏蔽
---@field hasExitAction boolean 是否有状态退出,判断按键缓存用
---@field forceAcc Vector3 拖拽向量
---@field hasSkillAddMove Vector3 是否有技能影响位移
---@field skillAddMoveTime number[] 技能影响位移时间记录
ActionStateManage = class(nil, 'ActionStateManage');

---@type string[] 状态与index映射
ACTION_STATE_DICT_PARAM_MAP = {"idle","move","dodge","dash","repel","trapped","normalSkill","hitted","beatDown","born","die","revive","exile","changePeriod","changeLeader","turn","reLoad","objDead","reloadEnd","activeSkill","jiZouSkill"};
---@type number 技能打断剩余节点运行id
BREAK_SKILL_ACTION_ID = 999;
function ActionStateManage:ctor(_battleId)
    ---@type number
    self.battleId = _battleId
    self.battleRoom = GetBattleRoom(self.battleId)

    local idleActionState = IdleActionState.New(self.battleId);
    self.currentStates = {};
    self.currentStates[idleActionState:GetId()] = idleActionState;
    self.stateChange = {};
    self.currentLeaderUseTime = 0;
    self.leaderUseTimes = {};
    self.changeLeaderTime = 0

    self.battleUnit = nil;
    self.moveParam = Vector3.zero_local();
    self.cameraParam = Vector3.zero_local();
    self.hitWall = false;
    self.canEnterDash = true;

    self.position = Vector3.zero_local()
    self.rotation = Quaternion.identity_Local()
    self.velocity = Vector3.zero_local()
    self.accelerate = Vector3.zero_local()
    self.forceAcc = nil;

    self.scale = nil;
    self.blockKeys = {};
    self.hasExitAction = false;

    self.hasSkillAddMove = false
    self.skillAddMoveTime = {}
    self.skillAddMove = {}
    self.skillAddMoveDirectional = {}

    self.__moveParamCache = Vector3.up_local()
    self.__rotateParamCache = Vector3.zero_local()
    self.__tmpVector_1 = Vector3.zero_local()
    self.__tmpVector_2 = Vector3.zero_local()
    self.__tmpQuan_1 = Quaternion.identity_Local()
    self.__tmpQuan_2 = Quaternion.identity_Local()
end

--- 初始化行为控制器
---@public
---@param _battleUnit BattleUnitBase
---@param _position Vector3 位置
---@param _rotation Quaternion 朝向
---@param _velocity Vector3 速度
function ActionStateManage:Init(_battleUnit, _position, _rotation, _velocity, _scale)
    self:__Init(_battleUnit, _position, _rotation, _velocity, _scale)
end

---@protected
---@param _battleUnit BattleUnitBase
---@param _position Vector3 位置
---@param _rotation Quaternion 朝向
---@param _velocity Vector3 速度
function ActionStateManage:__Init(_battleUnit, _position, _rotation, _velocity, _scale)
    self.battleUnit = _battleUnit;
    self.position = _position or Vector3.zero_local()
    self.rotation = _rotation or Quaternion.identity_Local()
    self.velocity = _velocity or Vector3.zero_local()
    self.scale = _scale or Vector3.one_local()
    self.euler = _rotation and Quaternion.ToEulerAngles(_rotation) or Vector3.zero_local()

    for i, v in pairs(_battleUnit:GetAllObjectDic()) do
        if not v:CheckDead() then
            ---@type BattleObjCom_Collider
            local colliderCom = v:GetComponent(BattleObjectComponentType.Collider);
            if colliderCom then
                colliderCom:CreateCollider(_position,_rotation);
            end
        end
    end
end

--- 尝试进入行为状态
---@private
---@param _stateId number 请求进入行为的Id
---@param _param number 行为参数
---@param _skipCheckStateId number 跳过行为检测
---@return boolean 是否可进入
function ActionStateManage:TryEnter(_stateId,_param,_skipCheckStateId)
    ----LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"try enter",ACTION_STATE_DICT_PARAM_MAP[_stateId]);

    local targetConfig = self.battleRoom.inputDataSource:GetDict("StateSwitchRule",_stateId);
    if targetConfig == nil then
        --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"try enter false",ACTION_STATE_DICT_PARAM_MAP[_stateId],"config == nil");
        return false;
    end

    for i, v in pairs(self.currentStates) do
        --LogTools.LogByLevel(LogLevel.log, "ActionStateManage:TryEnter", "current stateId", i)
        local tempConfig = v:GetSwitchRule();
        if i ~= BREAK_SKILL_ACTION_ID then
            if tempConfig ~= nil or v:GetId() ~= _skipCheckStateId then
                local paramName = ACTION_STATE_DICT_PARAM_MAP[targetConfig.id];
                if paramName ~= nil then
                    if tempConfig[paramName] == 0 then
                        --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"try enter false",ACTION_STATE_DICT_PARAM_MAP[_stateId],"config == 0","paramName",paramName,"currentState",ACTION_STATE_DICT_PARAM_MAP[v:GetId()]);
                        return false;
                    end
                end
            end
        end
    end
    ----LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"try enter",ACTION_STATE_DICT_PARAM_MAP[_stateId],"true");
    return true;
end

--- 进入行为状态
---@private
---@param _state ActionState 进入的行为
---@param _objectId number|nil 角色
---@param _param number 行为参数
---@return boolean 是否可进入
function ActionStateManage:Enter(_state, _objectId,_param)

    --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"enter action",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()]);

    if _state == nil then
        return false
    end

    local targetConfig = self.battleRoom.inputDataSource:GetDict("StateSwitchRule",_state:GetId());
    if targetConfig == nil then
        --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"enter action false",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()],"config == nil");
        return false;
    end

    if _objectId == nil then
        -- 不传默认当前角色
        _objectId = self:GetUnit():GetCurrentHeroObjectId()
    end

    local canEnter,param = _state:EnterAction(self, self.currentStates, _objectId);
    if not canEnter then
        --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"enter action false",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()]);
        return false;
    end

    self.battleRoom.battleLogicEventService:OnChangeStateEvent(_state.GetId(),false,self:GetUnit():GetNetId(),_objectId)
    
    ---@type ActionState[]
    local exitStates = {};
    for i, v in pairs(self.currentStates) do
        local tempConfig = v:GetSwitchRule();
        if i ~= BREAK_SKILL_ACTION_ID and tempConfig ~= nil then
            local paramName = ACTION_STATE_DICT_PARAM_MAP[targetConfig.id];
            if paramName ~= nil then
                if tempConfig[paramName] == 2 then
                    table.insert(exitStates,v);
                end
            end
        end
    end

    local isSame = false;
    for i, v in pairs(exitStates) do
        if v:GetId() == _state:GetId() then
            isSame = true;
        end
        self:Exit(v,true,_state:IsActive(),isSame);
        isSame = false;
    end
    --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"enter action true",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()]);

    local stateChange = {};
    stateChange.isLeave = 0;
    stateChange.stateId = _state:GetId();
    if param then
        stateChange.param = param;
    end
    table.insert(self.stateChange,stateChange);
    
    ---@type BattleObjCom_PlayMode
    local playMode = self:GetUnit():GetCurrentHeroObject():GetComponent(BattleObjectComponentType.PlayMode);
    if not playMode then
        return true;
    end
    ---@type PlayMode
    local currentPlayModeConfig = self.battleRoom.inputDataSource:GetDict("PlayMode",playMode.currentMode);
    if not currentPlayModeConfig then
        return true;
    end
    ---@type PlayerModeSwitchRule
    local modeConfig = self.battleRoom.inputDataSource:GetDict("PlayerModeSwitchRule",currentPlayModeConfig.playerModeSwitchBack);
    if modeConfig then
        local paramName = ACTION_STATE_DICT_PARAM_MAP[_state:GetId()];
        if paramName ~= nil and modeConfig[paramName] == 1 then
            if playMode and currentPlayModeConfig.modeType ~= BATTLE_OBJECT_PLAY_MODE_TYPE.normal then
                playMode:ChangeMode(1);
            end
        end
    end

    return true;
end

--- 推出行为状态
---@public
---@param _state ActionState 退出的行为
---@param _isBreak boolean 是否为打断退出
---@param _isActive boolean 是否为主动打断
---@param _isSame boolean 是否因为同一个状态
function ActionStateManage:Exit(_state,_isBreak,_isActive,_isSame)
    --LogTools.LogByLevel(LogLevel.log, "ActionStateManage:Exit", "_state", _state, "_isBreak", _isBreak, "_isActive", _isActive)
    if not _state then return end
    --LuaProfiler.BeginSample("ActionStateManage:Exit")
    --if _isBreak then
    --    --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"exit action break",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()]);
    --else
    --    --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"exit action",ACTION_STATE_DICT_PARAM_MAP[_state:GetId()]);
    --end

    if not _isSame then
        local stateChange = {};
        stateChange.isLeave = 1;
        stateChange.stateId = _state:GetId();
        table.insert(self.stateChange,stateChange);
    end
    
    if _state:GetId() ~= nil then
        self.currentStates[_state:GetId()] = nil;
    else
        --LogTools.LogByLevel(LogLevel.log,"_state:GetId() is nil");
    end

    _state:ExitAction(self,_isBreak,_isActive);
    self.battleRoom.battleLogicEventService:OnChangeStateEvent(_state.GetId(),true,self:GetUnit():GetNetId(),self:GetUnit():GetCurrentHeroObjectId())

    self.hasExitAction = true;
    --LuaProfiler.EndSample("ActionStateManage:Exit")
end

--- 当前帧有没有退出状态
---@public
---@return boolean 当前帧有没有退出状态
function ActionStateManage:HasExitAction()
    return self.hasExitAction;
end

--- 执行行为
---@public
---@param _dt number 更新时间
---@param _netId number 单位Id
---@param _objId number 物体Id
function ActionStateManage:DoAction(_dt,_netId,_objId)
    self.hasExitAction = false;

    ---@type ActionState[]
    local tempStates = {};
    for i, v in pairs(self.currentStates) do
        tempStates[i] = v;
    end

    ---@type number
    local _startUpdateTime = 0
    ---@type boolean
    local checkAction = SERVER_LIB and SERVER_LIB.performanceService:executeTimeCheck(PerformanceType.ACTION)
    for i, v in pairs(tempStates) do
        if self:GetUnit():GetUnitType() ~= BattleUnitType.Player or (not v:IsMoveAction() and v:GetId() ~= TurnActionState:GetId()) then
            -- 服务器时间统计
            if checkAction then
                _startUpdateTime = TimeUtils.nowExact()
            end

            v:DoAction(self, _dt, _netId, _objId);

            -- 服务器时间统计
            if checkAction then
                SERVER_LIB.performanceService:checkCommonExecuteTime(PerformanceType.ACTION, "Action[" .. v:PrintActionLog() .. "]", 0, self.battleId, _startUpdateTime, TimeUtils.nowExact())
            end
        end
    end
    self.battleRoom.outputDataSource:BroadCastMoveOutputData(-1, _dt);
    self.currentLeaderUseTime = self.currentLeaderUseTime + _dt;
    if not self.leaderUseTimes[_objId] then
        self.leaderUseTimes[_objId] = 0;
    end
    self.leaderUseTimes[_objId] = self.leaderUseTimes[_objId] + _dt;
end

--- 执行行为
---@public
---@param _dt number 更新时间
---@param _netId number 单位Id
---@param _objId number 物体Id
function ActionStateManage:DoMoveAction(_dt,_netId,_objId)

    self.hasExitAction = false;

    ---@type ActionState[]
    local tempStates = {};
    for i, v in pairs(self.currentStates) do
        tempStates[v:GetId()] = v;
    end
    if tempStates[TurnActionState:GetId()] then
        local v = tempStates[TurnActionState:GetId()];
        v:DoAction(self,_dt,_netId,_objId);
    end
    for i, v in pairs(tempStates) do
        if v:IsMoveAction() then
            v:DoAction(self,_dt,_netId,_objId);
        end
    end
    self.battleRoom.outputDataSource:BroadCastMoveOutputData(self.battleRoom.idCreator:GetAndIncreaseMoveFrameId(), _dt);
end

---@public
---广播状态变化
function ActionStateManage:BroadCastStateChanged()
    if #self.stateChange <= 0 then
        return;
    end
    
    --LogTools.LogByLevel(LogLevel.log, "ActionStateManage:BroadCastStateChanged", "frameId", LOOPER.GetFrameId(), "netId", self:GetUnit():GetNetId(), "self.stateChange", dumpTableEx(self.stateChange))
    
    local battleUnitKeyData = {};
    battleUnitKeyData.netId = self:GetUnit():GetNetId();
    battleUnitKeyData.objId = self:GetUnit():GetCurrentHeroObjectId();
    battleUnitKeyData.stateChange = self.stateChange;
    self.battleRoom.outputDataSource:AddBattleUnitKeyData(battleUnitKeyData);

    self.stateChange = {};
end

--- 进入出生状态
---@public
function ActionStateManage:Spawn()
    if self:TryEnter(SpawnActionState:GetId()) then
        ---@type SpawnActionState
        local state = SpawnActionState.New(self.battleId, self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(state) then
            self.currentStates[state:GetId()] = state;
        end
    end
end

--- 进入死亡状态
---@public
---@param _deadType number 死亡类型
function ActionStateManage:Dead(_deadType)
    if self:TryEnter(DeadActionState:GetId()) then
        ---@type DeadActionState
        local state = DeadActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        state:Init(_deadType)
        if self:Enter(state) then
            self:BroadCastStateChanged()
            self.currentStates[state:GetId()] = state;
        end
    end
end

--- 进入死亡状态
---@public
function ActionStateManage:ObjectDead(_objId, _deadType)
    if self:TryEnter(ObjectDeadActionState:GetId()) then
        ---@type ObjectDeadActionState
        local state = ObjectDeadActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType())
        state:Init(_objId, _deadType)
        if self:Enter(state) then
            self:BroadCastStateChanged()
            self.currentStates[state:GetId()] = state;
        end
    end
end

--- 进入移动
---@public
---@param _moveParam Vector3 移动摇杆参数
---@param _cameraParam Vector3 镜头摇杆参数
---@param _isDash boolean 是否为闪避
---@param _hitWall boolean 是否撞墙
---@param _isBufferKey boolean 缓存按键
---@param _position Vector3 玩家重置位置
---@param _moveDir Vector3 玩家移动方向
function ActionStateManage:Move(_moveParam,_cameraParam,_isDash,_hitWall,_isBufferKey,_position,_moveDir)
    if _moveParam then
        _moveParam = Vector3.New(_moveParam.x,_moveParam.y,_moveParam.z);
    end
    if _cameraParam then
        _cameraParam = Vector3.New(_cameraParam.x,_cameraParam.y,_cameraParam.z);
    end
    if _position then
        if not self.transfer then
            _position = Vector3.New(_position.x,_position.y,_position.z);
            self:SetPosition(_position);
            self.transfer = false;
        end
    end
    if _moveDir then
        _moveDir = Vector3.New(_moveDir.x,_moveDir.y,_moveDir.z);
    end

    self:EnterTurn(_cameraParam);
    if _isDash ~= nil and _isDash == false and not _isBufferKey then
        self.canEnterDash = true;
    end

    ---@type ActionState
    local moveState = self:GetCurrentMoveState();
    --玩家没有移动
    if moveState == nil then
        if _moveParam == nil then
            _moveParam = Vector3.zero_local();
        end
        if _cameraParam == nil then
            _cameraParam = Vector3.zero_local();
        end

        self.moveParam = _moveParam;
        self.cameraParam = _cameraParam;
        if _hitWall ~= nil then
            self.hitWall = _hitWall;
        end

        if _isDash ~= nil and _isDash then
            --进入闪避
            self:EnterDash(_moveParam,_cameraParam,_hitWall,_position,_moveDir);
        else
            --一般移动
            if _moveParam == Vector3.zero_local() and _isBufferKey == false then
                return;
            end
            self:EnterCommonMove(_moveParam,nil,_hitWall,_position,_moveDir);
        end
        return;
    end

    if _moveParam == nil then
        _moveParam = moveState.moveParam;
    end
    if _cameraParam == nil and moveState.cameraParam then
        _cameraParam = moveState.cameraParam;
    end

    self.moveParam = _moveParam;
    self.cameraParam = _cameraParam;
    if _hitWall ~= nil then
        self.hitWall = _hitWall;
        moveState.hitWall = _hitWall;
    end

    moveState.hitPosition = _position;
    moveState.hitMoveDir = _moveDir;

    --维持当前移动方式，改变方向
    if _isDash == nil then
        --闪避不能中途改变方向,但因为后续要继承移动参数所以也要改变
        moveState.moveParam = _moveParam;
        if moveState.cameraParam and _cameraParam then
            moveState.cameraParam = _cameraParam;
        end
        return;
    end

    -- 进入闪避
    if _isDash then
        if moveState:GetId() == DashActionState:GetId() or _isBufferKey then
            return;
        end
        self:EnterDash(_moveParam,_cameraParam,_hitWall,_position,_moveDir);
        return;
    end

    if not _isDash and _isBufferKey == false then
        if moveState:GetId() == DashActionState:GetId() then
            --阻止闪避切冲刺
            moveState.canEnterSprint = false;
            return;
        end
    end
end

--- 换弹
---@param _autoReload boolean 是否自动换弹
function ActionStateManage:Reload(_autoReload)
    if self:TryEnter(ReloadPreActionState:GetId()) then
        ---@type ReloadPreActionState
        local reloadState = ReloadPreActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType());
        reloadState:Init(false, _autoReload);
        if self:Enter(reloadState) then
            self.currentStates[reloadState:GetId()] = reloadState;
        end
    end
end

--- 立即换弹(啥判断，表现都没有，就是改属性)
function ActionStateManage:ReloadImmediately()
    --- @type BattleObjCom_Weapon
    local componentWeapon = self.battleUnit:GetCurrentHeroObject():GetComponent(BattleObjectComponentType.Weapon)
    if componentWeapon then
        -- 执行换弹
        componentWeapon:Reload();
    end
end

--- 强制换弹（不判断状态）
---@param _autoReload boolean 是否自动换弹
function ActionStateManage:ReloadForce(_autoReload)
    ---@type ReloadPreActionState
    local reloadState = ReloadPreActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType());
    reloadState:Init(true, _autoReload);
    if self:Enter(reloadState) then
        self.currentStates[reloadState:GetId()] = reloadState;
    end
end

ActionStateManage.checkNetId = nil

---@public
---@param _targetVectorInWorld Vector3 目标朝向向量(世界坐标系) --注意是向量，不是欧拉角
---@param _skipCheckAngle boolean 是否跳过最小角检查
function ActionStateManage:AiRotate(_targetVectorInWorld, _skipCheckAngle)
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "=========================> ActionStateManage:AiRotate start")
    end
    local _vectorPool = self.battleRoom.vector3Pool
    local _rotateParam = self.__rotateParamCache

    local _qTargetRotation = self.__tmpQuan_1
    local _targetEuler = self.__tmpVector_1
    Quaternion.LookRotation(_targetVectorInWorld, Vector3.up_global(), _qTargetRotation, _vectorPool)
    Quaternion.ToEulerAngles(_qTargetRotation, _targetEuler)
    Vector3.FormatEuler(_targetEuler)
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "ActionStateManage:AiRotate", "_targetEuler", _targetEuler, "self.euler", self.euler)
    end
    local _checkAngle = _skipCheckAngle and 0 or self:GetUnit():GetComponent(BattleUnitComponentType.Behav):GetAtkAngle()

    
    ---------------------------------------计算横向旋转角度-------------------------------------------
    local _hAngle = _targetEuler.y - self.euler.y
    if _hAngle < -180 then
        _hAngle = _hAngle + 360
    elseif _hAngle > 180 then
        _hAngle = _hAngle - 360
    end
    local _absAngleH = math.abs(_hAngle)
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "ActionStateManage:AiRotate", "_absAngleH", _absAngleH, "_checkAngle", _checkAngle, "_hAngle", _hAngle)
    end
    if _absAngleH < _checkAngle then
        _rotateParam.x = 0
        _absAngleH = 0
    elseif _hAngle > 0 then
        _rotateParam.x = 1
    elseif _hAngle < 0 then
        _rotateParam.x = -1
    else
        _rotateParam.x = 1
    end
    ---------------------------------------横向旋转计算结束-------------------------------------------
    
    ---------------------------------------计算纵向旋转角度-------------------------------------------
    local _vAngle = _targetEuler.x - self.euler.x
    if _vAngle < -180 then
        _vAngle = _vAngle + 360
    elseif _vAngle > 180 then
        _vAngle = _vAngle - 360
    end
    local _absAngleV = math.abs(_vAngle)
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "ActionStateManage:AiRotate", "_absAngleV", _absAngleV, "_checkAngle", _checkAngle, "_vAngle", _vAngle)
    end

    if _absAngleV < _checkAngle then
        _rotateParam.y = 0
    elseif _vAngle > 0 then
        _rotateParam.y = 1
    else
        _rotateParam.y = -1
    end
    ---------------------------------------纵向旋转计算结束-------------------------------------------
    

    if _rotateParam.x == 0 and _rotateParam.y == 0 then
        return false
    end
    
    ---@type TurnActionState
    local _turnState = self.currentStates[TurnActionState:GetId()]
    if _turnState then
        _turnState.cameraParam = _rotateParam
        _turnState.hAngleLimit = _absAngleH
        _turnState.vAngleLimit = _absAngleV
    else
        self:EnterTurn(_rotateParam, _absAngleH, _absAngleV)
    end
    
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "====================> ActionStateManage:AiRotate end", "_rotateParam", _rotateParam, "_absAngleH", _absAngleH, "_absAngleV", _absAngleV)
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
    end
    return true
end

---@public
---@param _targetPos Vector3 目标点
---@param _targetDir Vector3 目标朝向
---@param _skipCheckAngle boolean 是否跳过角度范围检查
function ActionStateManage:AiMove(_targetPos, _targetDir, _skipCheckAngle)
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "=========================> ActionStateManage:AiMove start", "_targetPos", _targetPos, "self.position", self.position)
    end
    local _hasRotate = _targetDir and self:AiRotate(_targetDir, _skipCheckAngle) or false
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "是否发生旋转", _hasRotate)
    end
    if not _hasRotate then
        self:Exit(self.currentStates[TurnActionState:GetId()])
    end
    
    local _hasMove = _targetPos and _targetPos ~= self.position or false
    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "是否发生移动", _hasMove)
    end
    if _hasMove then

        if _targetPos then
            self.__moveParamCache.z = 1
        else
            self.__moveParamCache.z = 0
        end
        
        ---@type MoveActionState
        local _moveState = self:GetCurrentMoveState()
        if _moveState then
            self.moveParam = self.__moveParamCache
            self.cameraParam = self.__rotateParamCache
            _moveState.moveParam = self.__moveParamCache
            _moveState.cameraParam = self.__rotateParamCache
            _moveState.targetPos = _targetPos
            _moveState.hitWall = false
            _moveState.hitPosition = self.hitPosition
            _moveState.hitMoveDir = self.hitMoveDir
        else
            self:EnterCommonMove(self.__moveParamCache, _targetPos,false,self.hitPosition,self.hitMoveDir)
        end
    else
        self:Exit(self:GetCurrentMoveState(), false)
    end
    
    self.hitPosition = nil
    self.hitMoveDir = nil

    if self.battleUnit:GetNetId() == ActionStateManage.checkNetId then
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove", "====================> ActionStateManage:AiMove end")
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
        LogTools.LogByLevel(LogLevel.log, "CheckAiMove")
    end
    return _hasMove or _hasRotate
end

--- 闪避
---@private
---@param _moveParam Vector3 移动摇杆参数
---@param _cameraParam Vector3 镜头摇杆参数
---@param _hitWall boolean 是否撞墙
---@param _hitPosition Vector3 碰撞位置
---@param _hitMoveDir Vector3 碰撞移动方向
function ActionStateManage:EnterDash(_moveParam,_cameraParam,_hitWall,_hitPosition,_hitMoveDir)
    if self:TryEnter(DashActionState:GetId()) and self.canEnterDash then
        local dashState = DashActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        dashState:Init(_moveParam,_cameraParam,_hitWall,_hitPosition,_hitMoveDir);
        if self:Enter(dashState) then
            self.currentStates[dashState:GetId()] = dashState;
        end
    end
end

--- 冲刺
---@private
---@param _moveParam Vector3 移动摇杆参数
---@param _hitWall boolean 是否撞墙
---@param _hitPosition Vector3 碰撞位置
---@param _hitMoveDir Vector3 碰撞移动方向
function ActionStateManage:EnterSprint(_moveParam,_hitWall,_hitPosition,_hitMoveDir)
    if self:TryEnter(SprintActionState:GetId()) then
        ---@type SprintActionState
        sprintState = SprintActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        sprintState:Init(_moveParam,_hitWall,_hitPosition,_hitMoveDir);
        if self:Enter(sprintState) then
            self.currentStates[sprintState:GetId()] = sprintState;
        end
    end
end

--- 普通移动
---@private
---@param _moveParam Vector3 移动摇杆参数
---@param _targetPos Vector3 目标点
---@param _hitWall boolean 是否撞墙
---@param _hitPosition Vector3 碰撞位置
---@param _hitMoveDir Vector3 碰撞移动方向
function ActionStateManage:EnterCommonMove(_moveParam,_targetPos,_hitWall,_hitPosition,_hitMoveDir)
    --LuaProfiler.BeginSample("EnterCommonMove")
    if self:TryEnter(MoveActionState:GetId()) then
        ---@type MoveActionState
        local moveState = MoveActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        moveState:Init(_moveParam,_targetPos,_hitWall,_hitPosition,_hitMoveDir);
        if self:Enter(moveState) then
            self.currentStates[moveState:GetId()] = moveState;
        end
    end
    --LuaProfiler.EndSample("EnterCommonMove")
end

---@public 获得当前移动状态
function ActionStateManage:GetCurrentMoveState()
    if self.currentStates[MoveActionState:GetId()] ~= nil then
        return self.currentStates[MoveActionState:GetId()];
    end
    if self.currentStates[DashActionState:GetId()] ~= nil then
        return self.currentStates[DashActionState:GetId()];
    end
    if self.currentStates[SprintActionState:GetId()] ~= nil then
        return self.currentStates[SprintActionState:GetId()];
    end
    return nil;
end

--- 转向
---@private
---@param _cameraParam Vector3 镜头摇杆参数
---@param _targetQuan Quaternion 目标旋转量
function ActionStateManage:EnterTurn(_cameraParam, _hAngle, _vAngle)
    --LuaProfiler.BeginSample("EnterTurn")
    if _cameraParam == nil then
        _cameraParam = Vector3.zero_local()
    end

    self.cameraParam = _cameraParam;

    local turn = self.currentStates[TurnActionState:GetId()];
    if turn ~= nil then
        turn:Init(_cameraParam, _hAngle, _vAngle);
        --LuaProfiler.EndSample("EnterTurn")
        return;
    else
        if _cameraParam == Vector3.zero_local() then
            return;
        end
        if self:TryEnter(TurnActionState:GetId()) then
            ---@type TurnActionState
            local turnActionState = TurnActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
            turnActionState:Init(_cameraParam, _hAngle, _vAngle);
            if self:Enter(turnActionState) then
                self.currentStates[turnActionState:GetId()] = turnActionState;
            end
        end
    end
    --LuaProfiler.EndSample("EnterTurn")
end

--- 转向目标
---@param _targetQuaternion Quaternion 目标旋转量
function ActionStateManage:TurnToTarget(_targetQuaternion)

    self.rotation = Quaternion.New(_targetQuaternion.x,_targetQuaternion.y,_targetQuaternion.z,_targetQuaternion.w);

    local battleUnitMoveOutput = {};
    battleUnitMoveOutput.v = self.velocity;
    battleUnitMoveOutput.position = self.position;
    battleUnitMoveOutput.rotation = self.rotation;
    battleUnitMoveOutput.accelerate = Vector3.zero_global();
    battleUnitMoveOutput.moveParam = self.moveParam;
    battleUnitMoveOutput.cameraParam = self.cameraParam;
    battleUnitMoveOutput.type = 16;

    local battleUnitMoveData = {};
    battleUnitMoveData.netId = self:GetUnit():GetNetId();
    battleUnitMoveData.objId = self:GetUnit():GetCurrentHeroObjectId();
    battleUnitMoveData.moveInfo = battleUnitMoveOutput;

    self.battleRoom.outputDataSource:AddBattleUnitMoveData(battleUnitMoveData);

end

--- 玩家撞墙
---@public
---@param _hitWallFrameId number 碰撞帧数
function ActionStateManage:PlayerHitWall(_hitWallFrameId)
    self.hitWall = true;
    if _hitWallFrameId then
        local moveData = self.battleRoom.outputDataSource:TraceBack(self:GetUnit():GetNetId(),_hitWallFrameId);
        if moveData then
            self:SetPosition(moveData.position);
            self:SetVelocity(moveData.v);
            self:SetRotation(moveData.currentDirection);
        end
    end
    ---@type ActionState
    local moveState = self:GetCurrentMoveState();
    if moveState then
        moveState.hitWall = true;
    end
end

--- 玩家撞墙
---@public
---@param _position Vector3 位置
---@param _moveDir Vector3 移动方向
function ActionStateManage:BattleUnitHitWall(_position,_moveDir)
    ---@type ActionState
    local moveState = self:GetCurrentMoveState();
    if moveState then
        moveState.hitPosition = _position;
        moveState.hitMoveDir = _moveDir;
    else
        self.hitPosition = _position;
        self.hitMoveDir = _moveDir;
    end
end

function ActionStateManage:GetForceAcc()
    return self.forceAcc;
end

--
function ActionStateManage:CheckHasForceAcc()
    return self.forceAcc and Vector3.SqrMagnitude(self.forceAcc) > 0
end

---@public
---添加牵引力
---@param _forceDir Vector3 牵引力方向
---@param _force number 牵引力
function ActionStateManage:AddForceAcc(_forceDir,_force)
    ---@type BattleUnitCom_Buff
    local unitBuffCom = self:GetUnit():GetComponent(BattleUnitComponentType.Buff);
    if unitBuffCom and unitBuffCom:IsEndure() then
        return;
    end

    ---@type BattleObjectBase
    local object = self:GetUnit():GetCurrentHeroObject();
    ---@type BattleObjCom_Buff
    local buffCom = object:GetComponent(BattleObjectComponentType.Buff)
    if buffCom and buffCom:IsEndure() then
        return;
    end
    local forceAcc = _forceDir.normalized:Mul(_force);
    self.forceAcc = forceAcc;
    if forceAcc ~= Vector3.zero_local() then
        local moveActionState = self:GetCurrentMoveState();
        if moveActionState == nil then
            self:ForceMove(self.forceAcc);
        end
    end
end

---@public
---移除牵引力
function ActionStateManage:RemoveForceAcc()
    self.forceAcc = nil;
end

--- 普通移动
---@private
function ActionStateManage:ForceMove()
    if self:TryEnter(MoveActionState:GetId()) then
        ---@type MoveActionState
        local moveState = MoveActionState.New(self.battleId, self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        moveState:Init(Vector3.zero_local());
        if self:Enter(moveState) then
            self.currentStates[moveState:GetId()] = moveState;
        end
    end
end

--- 技能增加移动
---@public
function ActionStateManage:SkillAddMove(_param)
    self.hasSkillAddMove = true
    if not self.skillAddMove[_param.id] then
        self.skillAddMove[_param.id] = _param
        self.skillAddMoveTime[_param.id] = _param.time
    end

    local moveActionState = self:GetCurrentMoveState();
    if moveActionState == nil then
        if self:TryEnter(MoveActionState:GetId()) then
            ---@type MoveActionState
            local moveState = MoveActionState.New(self.battleId, self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
            moveState:Init(Vector3.zero_local());
            if self:Enter(moveState) then
                self.currentStates[moveState:GetId()] = moveState;
            end
        end
    end
end

--- 移除技能增加移动
---@public
function  ActionStateManage:RemoveSkillAddMove(_id)
    if self.skillAddMoveTime[_id] then
        self.skillAddMoveTime[_id] = nil
        self.skillAddMove[_id] = nil
        if self.skillAddMoveDirectional[_id] then
            self.battleRoom.quaternionPool:Push(self.skillAddMoveDirectional[_id])
            self.skillAddMoveDirectional[_id] = nil
        end

        local isNil = true
        -- 没有了就结束此行为
        for i,v in pairs(self.skillAddMove) do
            isNil = false
        end
        if isNil then
            self.hasSkillAddMove = false
        end
    end
end

--- 进入空闲
---@public
function ActionStateManage:Idle()
    if self:TryEnter(IdleActionState:GetId()) then
        ---@type IdleActionState
        local idleState = IdleActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(idleState) then
            self.currentStates[idleState:GetId()] = idleState;
        end
    end
end

--- 进入放逐
---@public
function ActionStateManage:Exile()
    if self:TryEnter(ExileActionState:GetId()) then
        ---@type ExileActionState
        local exileState = ExileActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(exileState) then
            self.currentStates[exileState:GetId()] = exileState;
        end
    end
end

---进入trapped状态
---@public
---@param _trappedType number 被困类型
---@param _trappedTime number 被困时间
function ActionStateManage:Trapped(_trappedType,_trappedTime);
    ---@type TrappedActionState
    local trappedState = self.currentStates[TrappedActionState:GetId()];
    if trappedState then
        trappedState.runTime = 0;
        trappedState.trappedType = _trappedType;
        trappedState.trappedTime = _trappedTime;
        return;
    end
    if self:TryEnter(TrappedActionState:GetId()) then
        ---@type TrappedActionState
        local trappedState = TrappedActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType(),_trappedType,_trappedTime);
        if self:Enter(trappedState) then
            self.currentStates[trappedState:GetId()] = trappedState;
        end
    end
end

--- 进入切换角色
---@param _objectId number 角色id
---@param _inputType PlayerChangeLeaderInputType 触发换人的类型
function ActionStateManage:PlayerChangeLeader(_objectId, _inputType, _force)
    --LogTools.LogByLevel(LogLevel.log, "CheckDead", "ActionStateManage", "PlayerChangeLeader", "_objectId", _objectId, "_castJizou", _castJizou)
    local newLeader = self:GetUnit():GetHeroObject(_objectId)
    if not newLeader then
        return
    end
    -- 1.先执行极奏换人（不用管技能的状态，技能check不过则不放技能）
    -- 先tryEnter切角色状态机
    if not _force and not self:TryEnter(ChangeLeaderActionState:GetId()) then
        if CheckLogLevel(LogLevel.log) then
            LogTools.LogByLevel(LogLevel.log, "ActionStateManage", "PlayerChangeLeader", "Try Enter ChangeLeaderActionState false")
        end
        return
    end
    ---@type ChangeLeaderActionState
    local changeLeaderState = ChangeLeaderActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType(), _objectId);
    -- Enter切角色状态机
    if not self:Enter(changeLeaderState) then
        if CheckLogLevel(LogLevel.log) then
            LogTools.LogByLevel(LogLevel.log, "ActionStateManage", "PlayerChangeLeader", "Enter ChangeLeaderActionState false")
        end
        return
    end
    -- 极奏换人比较特殊，这里直接把人切换了，避免后面乱七八糟的objectId的问题
    changeLeaderState:DoAction(self, nil, self:GetUnit():GetNetId(), _objectId)

    -- 2.再释放极奏
    if _inputType == PlayerChangeLeaderInputType.Jizou then
        local jizouSkillId = newLeader:GetDataInstanceXls().jizouSkillGroup
        ---@type Skill
        local skillConfig = self.battleRoom.inputDataSource:GetDict("Skill", jizouSkillId);
        ---@type BattleObjCom_Skill
        local skillComp = newLeader:GetComponent(BattleObjectComponentType.Skill);
        if skillComp then
            jizouSkillId = skillComp:GetFinalSkill(skillConfig.skillType, jizouSkillId);
        end
        if CheckLogLevel(LogLevel.log) then
            LogTools.LogByLevel(LogLevel.log, "ActionStateManage", "PlayerChangeLeader", "Cast Skill", "jizouSkillId", jizouSkillId)
        end
        -- 切完人放极奏
        self:CastSkill(jizouSkillId)
    end

    --LogTools.LogByLevel(LogLevel.log, "CheckDead", "ActionStateManage", "PlayerChangeLeader end")
    --if CheckLogLevel(LogLevel.log) then
    --    LogTools.LogByLevel(LogLevel.log, "ActionStateManage", "PlayerChangeLeader", "self.currentStates", dumpTableEx(self.currentStates))
    --end
end


--- 释放技能
---@public
---@param _skillId number 技能Id
function ActionStateManage:CastSkill(_skillId)
    local _curHero = self.battleUnit:GetCurrentHeroObject();
    ---@type Skill
    local skillConfig = self.battleRoom.inputDataSource:GetDict("Skill",_skillId);
    ---@type BattleObjCom_Skill
    local skillComp = _curHero:GetComponent(BattleObjectComponentType.Skill);
    if skillComp then
        local skillType = 1;
        if skillConfig then
            _skillId = skillComp:GetFinalSkill(skillConfig.skillType,_skillId);
            skillType = skillConfig.skillType;
        end
        if not self.battleRoom.inputDataSource:GetSkillModel(_skillId) then
            return;
        end
        if skillType == SkillTypeEnum.NORMAL:GetId() then
            if self:TryEnter(NormalSkillActionState:GetId(),skillType) then
                ---@type SkillActionState
                local skillActionState = NormalSkillActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType(), _skillId, _curHero:GetObjectId());
                if self:Enter(skillActionState,nil,skillType) then
                    self.currentStates[skillActionState:GetId()] = skillActionState;
                end
            end
        elseif skillType == SkillTypeEnum.ACTIVE:GetId() then
            if self:TryEnter(ActiveSkillActionState:GetId(),skillType) then
                ---@type SkillActionState
                local skillActionState = ActiveSkillActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType(), _skillId, _curHero:GetObjectId());
                if self:Enter(skillActionState,nil,skillType) then
                    self.currentStates[skillActionState:GetId()] = skillActionState;
                end
            end
        elseif skillType== SkillTypeEnum.JI_ZOU:GetId() then
            if self:TryEnter(JiZouSkillActionState:GetId(),skillType) then
                ---@type SkillActionState
                local skillActionState = JiZouSkillActionState.New(self.battleId, self.battleUnit:GetStateParamId(), self.battleUnit:GetUnitType(), _skillId, _curHero:GetObjectId());
                if self:Enter(skillActionState,nil,skillType) then
                    self.currentStates[skillActionState:GetId()] = skillActionState;
                end
            end
        end
    end
end

--- 退出技能行为状态
---@public
---@param _isBreak boolean 是否打断
---@param _isActive boolean 是否主动
---@param _breakSKillId number|nil 退出的技能id
function ActionStateManage:ExitSkill(_isBreak,_isActive,_breakSKillId)
    --LogTools.LogByLevel(LogLevel.log,"ActionStateManage:ExitSkill", "netId:",self:GetUnit():GetNetId(),"exit skill action", "_isBreak", _isBreak, "_isActive", _isActive, "_breakSKillId", _breakSKillId)
    ---@type SkillActionState
    local skillState = self.currentStates[NormalSkillActionState:GetId()];
    if not skillState then
        skillState = self.currentStates[ActiveSkillActionState:GetId()];
    end
    if not skillState then
        skillState = self.currentStates[JiZouSkillActionState:GetId()];
    end
    
    if skillState ~= nil then
        if _breakSKillId and skillState.skillModel.skillId ~= _breakSKillId then
            return;
        end
        local isBreak = false;
        if _isBreak then
            isBreak = _isBreak;
        end
        local isActive = true;
        if _isActive then
            isActive = _isActive;
        end
        self:Exit(skillState,isBreak,isActive);
    end
end

---技能结束状态
---@param _skillState SkillActionState 技能状态
function ActionStateManage:EnterSkillBreakNode(_skillState)
    self.currentStates[BREAK_SKILL_ACTION_ID] = _skillState;
end

---技能结束状态
function ActionStateManage:ExitBreakSkill()
    self.currentStates[BREAK_SKILL_ACTION_ID] = nil;
end

--- 屏蔽按键
---@param _blockKeys number[] 屏蔽的按键
function ActionStateManage:AddBlockKey(_blockKeys)
    if #_blockKeys <= 0 then
        self.blockKeys = {};
        return;
    end
    for i, v in pairs(_blockKeys) do
        self.blockKeys[v] = true;
    end
end

--- 屏蔽按键
---@param _blockKeys number[] 屏蔽的按键
function ActionStateManage:RemoveBlockKey(_blockKeys)
    for i, v in pairs(_blockKeys) do
        self.blockKeys[v] = nil;
    end
end

--- 进入击退
---@public
---@param _repelId number 击退配置id
---@param _repelDirection Vector3 击退方向
function ActionStateManage:EnterRepel(_repelId,_repelDirection)
    if self:TryEnter(RepelActionState:GetId()) then
        ---@type RepelActionState
        local repelActionState = RepelActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType(),_repelDirection,_repelId);
        if self:Enter(repelActionState) then
            self.currentStates[repelActionState:GetId()] = repelActionState;
        end
    end
end

--- 进入被击
---@public
function ActionStateManage:EnterBeHit()
    if self:TryEnter(BeHitActionState:GetId()) then
        ---@type BeHitActionState
        local beHitActionState = BeHitActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(beHitActionState) then
            self.currentStates[beHitActionState:GetId()] = beHitActionState;
        end
    end
end

--- 进入击倒
---@public
function ActionStateManage:EnterBeatDown()
    if self:TryEnter(BeatDownActionState:GetId()) then
        ---@type BeatDownActionState
        local beatDownActionState = BeatDownActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(beatDownActionState) then
            self.currentStates[beatDownActionState:GetId()] = beatDownActionState;
        end
    end
end

--- 进入被击
---@public
function ActionStateManage:EnterBeHit()
    if self:TryEnter(BeHitActionState:GetId()) then
        ---@type BeHitActionState
        local beHitActionState = BeHitActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(beHitActionState) then
            self.currentStates[beHitActionState:GetId()] = beHitActionState;
        end
    end
end

--- 进入复活
---@public
function ActionStateManage:EnterRevive()
    if self:TryEnter(ReviveActionState:GetId()) then
        ---@type ReviveActionState
        local reviveActionState = ReviveActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(reviveActionState) then
            self.currentStates[reviveActionState:GetId()] = reviveActionState;
        end
    end
end

--- 进入切换阶段
---@public
function ActionStateManage:EnterChangePeriod()
    if self:TryEnter(ChangePeriodActionState:GetId()) then
        ---@type ChangePeriodActionState
        local changePeriodActionState = ChangePeriodActionState.New(self.battleId,self.battleUnit:GetStateParamId(),self.battleUnit:GetUnitType());
        if self:Enter(changePeriodActionState) then
            self.currentStates[changePeriodActionState:GetId()] = changePeriodActionState;
        end
    end
end

--- 退出所有状态
---@public
function ActionStateManage:OnBossAnimation()
    ---@type BattleObjectBase
    local object = self:GetUnit():GetCurrentHeroObject();
    ---@type BattleObjCom_PlayMode
    local playModeCom = object:GetComponent(BattleObjectComponentType.PlayMode);
    playModeCom:OnBossAnimation();
end

--- 判断单位释放在状态中
---@public
---@param _stateId number 状态id
---@return boolean 是否在状态中
function ActionStateManage:CheckInState(_stateId)
    return self.currentStates[_stateId] ~= nil;
end

---重置位置和朝向
---@public
---@param _position Vector3 位置
---@param _rotation Quaternion 朝向
function ActionStateManage:ResetPosition(_position,_rotation)
    local moveState = self:GetCurrentMoveState();
    if moveState then
        self:Exit(moveState,true,true);
    end

    self:__SetPosition(_position)
    if _rotation then
        self:__SetRotation(_rotation)
    end
    self.transfer = true;

    self.moveParam = Vector3.zero_local();
    self.cameraParam = Vector3.zero_local();
    self:SetVelocity(Vector3.zero_local());

    local battleUnitMoveOutput = {};
    battleUnitMoveOutput.v = Vector3.zero_local();
    battleUnitMoveOutput.position = self:GetPosition();
    battleUnitMoveOutput.rotation = self:GetRotation();
    battleUnitMoveOutput.accelerate = Vector3.zero_local();
    battleUnitMoveOutput.moveParam = self.moveParam;
    battleUnitMoveOutput.cameraParam = self.cameraParam;
    battleUnitMoveOutput.type = 100;

    local battleUnitMoveData = {};
    battleUnitMoveData.netId = self:GetUnit():GetNetId();
    battleUnitMoveData.objId = self:GetUnit():GetCurrentHeroObjectId();
    battleUnitMoveData.moveInfo = battleUnitMoveOutput;
    self.battleRoom.outputDataSource:AddBattleUnitMoveData(battleUnitMoveData);
end

---@public
---改变瞄准模式
---@param _modeId number 模式Id
function ActionStateManage:ChangePlayMode(_modeId)
    ---@type BattleObjCom_PlayMode
    local playMode = self:GetUnit():GetCurrentHeroObject():GetComponent(BattleObjectComponentType.PlayMode);
    if not playMode then
        return;
    end
    ---@type PlayMode
    local targetPlayModeConfig = self.battleRoom.inputDataSource:GetDict("PlayMode",_modeId);
    if not targetPlayModeConfig then
        return;
    end
    ---@type PlayerModeSwitchRule
    local modeConfig = self.battleRoom.inputDataSource:GetDict("PlayerModeSwitchRule", targetPlayModeConfig.playerModeSwitchEnter);
    if not modeConfig then
        return;
    end
    for i, v in pairs(self.currentStates) do
        local paramName = ACTION_STATE_DICT_PARAM_MAP[v:GetId()];
        if paramName ~= nil and modeConfig[paramName] == 0 then
            --LogTools.LogByLevel(LogLevel.log,"netId:",self:GetUnit():GetNetId(),"try enter false",ACTION_STATE_DICT_PARAM_MAP[_stateId],"config == 0","paramName",paramName,"currentState",ACTION_STATE_DICT_PARAM_MAP[v:GetId()]);
            return;
        end
    end
    playMode:ChangeMode(_modeId);
end

---stateParameterId发生变化
---@public
function ActionStateManage:OnStateParamIdChanged(_newId)
    for _, _state in pairs(self.currentStates) do
        _state:OnStateParamIdChanged(_newId)
    end
end

---获得行为管理器绑定的战斗单位
---@public
---@return BattleUnitBase 行为管理器绑定的unit
function ActionStateManage:GetUnit()
    return self.battleUnit;
end

---获得位置
---@public
---@return Vector3 位置
function ActionStateManage:GetPosition()
    return self.position;
end

---获得朝向
---@public
---@return Quaternion 朝向
function ActionStateManage:GetRotation()
    return self.rotation;
end

---获取当前欧拉角
---@public
---@return Vector3
function ActionStateManage:GetEuler()
    return self.euler
end

---获得速度
---@public
---@return Vector3 速度
function ActionStateManage:GetVelocity()
    return self.velocity;
end

---获得加速度
---@publicF
---@return Vector3 加速度
function ActionStateManage:GetAccelerate()
    return self.accelerate
end

---获得缩放
---@public
---@return Vector3 速度
function ActionStateManage:GetScale()
    return self.scale
end

---设置位置
---@public
---@param _position Vector3 位置
function ActionStateManage:SetPosition(_position)
    self:__SetPosition(_position)
end

---@private
function ActionStateManage:__SetPosition(_position)
    Vector3.Set(self.position, _position.x, _position.y, _position.z)
end

---设置朝向
---@public
---@param _rotation Quaternion 朝向
function ActionStateManage:SetRotation(_rotation)
    self:__SetRotation(_rotation)
end

---@private
function ActionStateManage:__SetRotation(_rotation)
    Quaternion.Set(self.rotation, _rotation.x, _rotation.y, _rotation.z, _rotation.w)
    Quaternion.ToEulerAngles(_rotation, self.euler)
    Vector3.FormatEuler(self.euler)
end

---设置速度
---@public
---@param _velocity Vector3 速度
function ActionStateManage:SetVelocity(_velocity)
    self:__SetVelocity(_velocity)
end

---@private
function ActionStateManage:__SetVelocity(_velocity)
    Vector3.Set(self.velocity, _velocity.x, _velocity.y, _velocity.z)
end

---设置加速度
---@public
---@param _velocity Vector3 加速度
function ActionStateManage:SetAccelerate(_accelerate)
    self:__SetAccelerate(_accelerate)
end

---@private
function ActionStateManage:__SetAccelerate(_accelerate)
    Vector3.Set(self.accelerate, _accelerate.x, _accelerate.y, _accelerate.z)
end

---设置缩放
---@public
---@param _velocity Vector3 速度
function ActionStateManage:SetScale(_scale)
    self.scale = _scale
end

---服务器逻辑核生成用于发送给前端逻辑核的全量信息
---@public
function ActionStateManage:GetCreateSyncMessage_S2C()
    local stateChanges = {};
    for i, _state in pairs(self.currentStates) do
        local stateChange = {};
        stateChange.isLeave = 0;
        stateChange.stateId = _state:GetId();
        table.insert(stateChanges,stateChange);
    end
    return stateChanges;
end

---前端逻辑核用服务器发来的全量信息刷新自身数据
---@public
function ActionStateManage:OnReceiveCreateSyncMessage_S2C(_message)

end

---前端逻辑核生成用于发送给表现的层全量信息
---@public
function ActionStateManage:GetCreateSyncMessage_L2V(_message)
    return _message.stateChange;
end

return ActionStateManage;