---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zhaopuyang.
--- DateTime: 2021/12/16 11:03
--- 客户端输入数据接收器

require "Lib/class"
require "Battle/Logic/Room/Component/InputDataSource"

---@class ClientInputDataSource : InputDataSource 客户端输入数据接收器
ClientInputDataSource = class(InputDataSource, 'ClientInputDataSource');

function ClientInputDataSource:ctor(_battleId)
    self.battleId = _battleId
end

--- 初始化
---@public
function ClientInputDataSource:Init(_battlePlayerInfo)
    self:__Init(_battlePlayerInfo);
    self.isIndieGame = GetBattleRoom(_battleId).indieGame;
end

--- 接收协议接口
---@public
---@param _uid number 发送协议的玩家id，如果是战斗房间消息该值为nil
---@param _id number 协议id
---@param _msgTable table 协议
---@param _arriveNetIoTime number 到达网络事件
function ClientInputDataSource:OnReceiveMessage(_uid, _id, _msgTable, _arriveNetIoTime)
    --LogTools.LogByLevel(LogLevel.log, "ClientInputDataSource", "ClientInputDataSource", "_uid", _uid, "_id", _id, "_msgTable", dumpTableEx(_msgTable))
    ---@type BattleRoomMessage
    local battleRoomMessage = BattleRoomMessage.New();
    local proto = PROTO_CODE_MAP[tostring(_id)];
    if proto ~= nil then
        if proto:GetType() == PROTO_MESSAGE_TYPE.InitRoom then
        elseif proto:GetType() == PROTO_MESSAGE_TYPE.Room then
            if self.isIndieGame then
                battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
                self:AddRoomMessage(battleRoomMessage)
            else
                COMMAND.SendCommandToServerLogic(_id,proto:GetName(),_msgTable);
            end
        elseif proto:GetType() == PROTO_MESSAGE_TYPE.tick then
            if self.isIndieGame then
                battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
                self:AddRoomMessage(battleRoomMessage)
            else
                COMMAND.SendCommandToServerLogic(_id,proto:GetName(),_msgTable);
            end
        elseif proto:GetType() == PROTO_MESSAGE_TYPE.player then
            if self.isIndieGame then
                if proto:GetId() == PROTO_CODE_ENUM.PLAYER_PRESS_KEY:GetId() and _msgTable.key == nil then
                    battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
                    proto.callBack(battleRoomMessage);
                else
                    battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
                    self:AddPlayerMessage(_uid, battleRoomMessage)
                end
            else
                COMMAND.SendCommandToServerLogic(_id,proto:GetName(),_msgTable);
            end
        elseif proto:GetType() == PROTO_MESSAGE_TYPE.logicOutput then
            battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
            self:AddRoomMessage(battleRoomMessage)
        elseif proto:GetType() == PROTO_MESSAGE_TYPE.broadcast then
            battleRoomMessage:Init(_uid, _id, self.battleId, _msgTable, _arriveNetIoTime);
            self:AddRoomMessage(battleRoomMessage)
        end
    end
end

--- 获得dict表
---@public
---@param _dictName string 表名
---@param _id number 表key
---@return table 表数据
function ClientInputDataSource:GetDict(_dictName, _id)
    if TableDic[_dictName] == nil then
        return nil;
    end
    return TableDic[_dictName][tostring(_id)]
end

--- 读取dict
---@public
---@param _dictName string 表名
---@param _id string 表key(String类型)
---@return table 表数据
function ClientInputDataSource:GetDictByString(_dictName, _id)
    if TableDic[_dictName] == nil then
        return nil;
    end
    return TableDic[_dictName][_id]
end

--- 读取skillValue
---@public
---@param _skillId number 技能Id
---@param _level number 技能等级
---@return table 表数据
function ClientInputDataSource:GetSkillValue(_skillId, _level)
    local valueDic = COMPLEX_DATA.skillValueDic[tostring(_skillId)]
    if valueDic == nil then
        return nil
    end
    return valueDic[tostring(_level)]
end

--- 读取skillValue
---@public
---@param _skillId number 技能Id
---@param _level number 技能等级
---@return table 表数据
function ClientInputDataSource:GetTalentSkill(_skillId, _level)
    local valueDic = COMPLEX_DATA.talentSkillDic[tostring(_skillId)]
    if valueDic == nil then
        return nil
    end
    return valueDic[tostring(_level)]
end

-- 根据怪物掉落id获取掉落数据
---@param monsterFallId number 怪物掉落id
---@type function
---@return table
---@public
function ClientInputDataSource:getMonsterFallDataList(monsterFallId)
    return COMPLEX_DATA.monsterFallDic[tostring(monsterFallId)]
end

-- 根据触发id和附着id获取元素反应
---@param triggerId number 触发元素id
---@param attachId number 附着元素id
---@type function
---@return ElementalReaction
---@public
function ClientInputDataSource:getEleReactByTrigIdAndAttachId(triggerId, attachId)
    local triggerDic = COMPLEX_DATA.elementReactionTriggerDic[tostring(triggerId)]
    if triggerDic == nil then
        return
    end
    return triggerDic[tostring(attachId)]
end

-- 根据怪物掉落id获取掉落数据
---@param fallObjectId number 掉落物id
---@param elementType number 元素类型
---@type function
---@return FallObject
---@public
function ClientInputDataSource:getFallObjectByIdAndElement(fallObjectId, elementType)
    local fallObjectDic = COMPLEX_DATA.fallObjectElementDic[tostring(fallObjectId)]
    if fallObjectDic == nil then
        return
    end
    return fallObjectDic[tostring(elementType)]
end

-- 根据距离获取伤害系数
---@param weaponDistanceType number 武器类型
---@param distance number 距离
---@type function
---@return number
---@public
function ClientInputDataSource:getDistanceRatioByRangeIndex(weaponDistanceType, distance)
    local distanceRatioDic = COMPLEX_DATA.weaponDistanceRatioDic[tostring(weaponDistanceType)]
    if distanceRatioDic == nil then
        return 1
    end

    local distanceSplit = TableDic["BattleDefault"][BATTLE_WEAPON_CONST.DISTANCE_DICT_ID].value6
    if distanceSplit == nil then
        return 1
    end

    local rangeIndex = 1
    for range = 1, #distanceSplit - 1 do
        local left = distanceSplit[range]
        local right = distanceSplit[range + 1]
        if distance >= left and distance <= right then
            rangeIndex = range
        end
    end

    local ratio = distanceRatioDic[tostring(rangeIndex)]
    if not ratio then
        return rangeIndex
    end
    return ratio
end

-- 根据元素id和附着量获取元素强度
---@param elementId number 元素id
---@param attachNum number 附着元素量
---@type function
---@return ElementStrength
---@public
function ClientInputDataSource:getEleStrengthByEleIdAndAttachId(elementId, attachNum)
    local strengthDic = COMPLEX_DATA.elementStrengthDic[tostring(elementId)]
    if strengthDic == nil then
        return
    end
    local strength = strengthDic[tostring(attachNum)]
    if strength ~= nil then
        return strength
    end
    for k, _strength in pairs(strengthDic) do
        -- 随便return一个
        return _strength
    end
end

-- 根据类型获取关卡常量
---@param type string 常量类型
---@type function
---@return LevelConstant
---@public
function ClientInputDataSource:getLevelConstantByType(type)
    return COMPLEX_DATA.levelConstantDic[type]
end

-- 获取elementValue数据
---@public
---@return ElementValue
function ClientInputDataSource:GetElementValueComplexData(_buffInstanceId, _level)
    local _elementValueTable = COMPLEX_DATA.elementValueTableDic[_buffInstanceId]
    if not _elementValueTable then return nil end

    local _ret = _elementValueTable[1]
    for i = 1, #_elementValueTable do
        ---@type ElementValue
        local _elementValue = _elementValueTable[i]
        if _elementValue.leaderLevel == _level then
            return _elementValue
        elseif _elementValue.leaderLevel > _level then
            return _ret
        else
            _ret = _elementValue
        end
    end
    return _ret
end

-- 获取伤害距离衰减下标
---@public
---@param _weaponType number 攻击方武装类型ID
---@param _dis number 测算的距离的平方值
---@param _propChangeValue number 攻击方 Skill_Active_CD_Reduce 属性值
---@return number
function ClientInputDataSource:GetHurtDisReduceParamCnt(_weaponType, _dis, _propChangeValue)
    
    local _list = COMPLEX_DATA.HurtDisReduceDic[_weaponType]
	--LogTools.LogByLevel(LogLevel.log, "HurtChannel", "_list", dumpTableEx(_list), "_dis", _dis)

    local _down = 0
    local _up = 0
    for _hurtDisReduceEnum, _powerDisTabs in pairs(_list) do
        for _, _powerDisTab in pairs(_powerDisTabs) do
            _down = _powerDisTab.down
            if _down > 0 then
                _down = _down + _propChangeValue
                if _down < 0 then _down = 0 end
                _down = _down * _down
            end
            _up = _powerDisTab.up
            if _up < math.maxinteger then
                _up = _up + _propChangeValue
                if _up < 0 then _up = 0 end
                _up = _up * _up
            end
            if _dis >= _down and _dis < _up then
                return _hurtDisReduceEnum
            end
        end
    end
    
    return HurtDisReduceEnum.highAttenuationDis
end

--- 读取战前剧情
---@public
---@param _mainLevelId number 技能Id
---@return table 战前剧情id
function ClientInputDataSource:GetMainLevelPreBattlePlots(_mainLevelId)
    return COMPLEX_DATA.mainLevelPrePlotsDic[tostring(_mainLevelId)]
end

--- 读取战前剧情
---@public
---@param _multiPveBossLevelId number 关卡id
---@return table 战前剧情id
function ClientInputDataSource:GetMultiPveBossLevelPreBattlePlots(_multiPveBossLevelId)
    return COMPLEX_DATA.multiPveBossLevelPrePlotsDic[tostring(_multiPveBossLevelId)]
end

-- 获取伤害距离衰减下标
---@public
---@return BountyMissionsLevelStage
function ClientInputDataSource:GetBountyMissionLevelStage(_levelInstanceId, _level)
    
    local _list = COMPLEX_DATA.bountyMissionLevelStageTableDic[_levelInstanceId]
    if not _list then return nil end

    local _ret = _list[1]
    ---@type BountyMissionsLevelStage
    local _tab
    for i = 1, #_list do
        _tab = _list[i]
        if _tab.lv < _level then
            _ret = _tab
        end
    end

    return _ret
end

-- 获取怪物属性修正
---@public
---@param _group number
---@param _classify number
---@param _playerNum number
function ClientInputDataSource:GetLevelMemberFix(_group, _classify, _playerNum)
    --LogTools.LogByLevel(LogLevel.logErr, "ClientInptDataSource:GetLevelMemberFix", "_group", _group, "_classify", _classify, "_playerNum", _playerNum)
    local _groupDic = COMPLEX_DATA.levelMemberDic[_group]
    if not _groupDic then
        return {1, 1, 1, 1, 1}
    end
    
    local _classifyTab = _groupDic[_classify]
    if not _classifyTab then
        return {1, 1, 1, 1, 1}
    end

    return _classifyTab[_playerNum] or {1, 1, 1, 1, 1}
end

-- 修正属性上下限
---@public
---@param _propId number 属性ID
---@param _value number 属性原始值
function ClientInputDataSource:FormatPropLimit(_propId, _value)
    local _tab = COMPLEX_DATA.propLimitDic[_propId]
    --LogTools.LogByLevel(LogLevel.logErr, "ClientInptDataSource:FormatPropLimit", "_propId", _propId, "_value", _value, "_tab", _tab)
    if not _tab then return _value end
    --LogTools.LogByLevel(LogLevel.logErr, "ClientInptDataSource:FormatPropLimit", "_propId", _propId, "_value", _value, "_tab[1]", _tab[1], "_tab[2]", _tab[2])
    if #_tab < 2 then return _value end
    if _tab[1] == 0 and _tab[2] == 0 then return _value end
    return Mathf.Clamp(_value, _tab[1], _tab[2])
end

-- 获取赛季关卡数据
---@public
---@param _levelInstanceId number 关卡id
---@param _season number 赛季
---@return SeasonReplaceLevel
function ClientInputDataSource:GetSeasonReplaceLevelByLevelIdAndSeason(_levelInstanceId, _season)
    local levelDic = COMPLEX_DATA.seasonReplaceLevelDic[tostring(_levelInstanceId)]
    if not levelDic then
        return
    end
    return levelDic[tostring(_season)]
end

return ClientInputDataSource;