---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2022/02/17 14:20
--- Describe: 伤害通道
---

---@class HurtChannel : table
HurtChannel = class(nil, "HurtChannel")
function HurtChannel:ctor(_battleId)
	self.battleId = _battleId
	self.battleRoom = GetBattleRoom(self.battleId)
end
function HurtChannel:Init(_data) end

---伤害通道
---@public
---@param _snapShot SnapShotData 攻击方属性快照
---@param _hurtStackData HurtStackData
function HurtChannel:OnHurt(_hurtStackData)
	--if _hurtStackData.defNetId == 1 then return end
	--if _hurtStackData.defNetId == ActionStateManage.checkNetId then return end

	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		_hurtStackData:Log()
	end

	if _hurtStackData.directHurtNum then
		_hurtStackData.hurtNum = _hurtStackData.directHurtNum
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次为直接指定伤害", "最终伤害数值", _hurtStackData.hurtNum)
		end
		self:__CalcSpreadHurtFix(_hurtStackData)
	else
		self:__SwitchHurtChannel(_hurtStackData)
		self:__CalcSpreadHurtFix(_hurtStackData)
		self:__CalcSkillTypeHurtAdd(_hurtStackData)
		self:__CalcEleWeakCommonHurtAdd(_hurtStackData)
		self:__CalcBlockHurt(_hurtStackData)
		self:__CalcStackNumAndCritical(_hurtStackData)
		self:__CalcSpecificSkillFix(_hurtStackData)
		self:__CalcDisReduce(_hurtStackData)
		self:__CalcReactionFix(_hurtStackData)
		self:__CalcSkillFinalFix(_hurtStackData)
	end
	self:__DealElementAttach(_hurtStackData)

	--if _hurtStackData.snapShotData:GetNetId() == 1 then
	--	_hurtStackData.hurtNum = 10000
	--end
	self:__RealDealHurt(_hurtStackData)

	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "伤害通道结束", "伤害计算值", _hurtStackData.hurtNum, "本次伤害是否被屏蔽", _hurtStackData.damageMask, "主伤害目标netID", _hurtStackData.mainDefUnit and _hurtStackData.mainDefUnit:GetNetId(), "主伤害目标objID", _hurtStackData.mainDefObj and _hurtStackData.mainDefObj:GetObjectId(), "主伤害数值", _hurtStackData.defObjPropCom and _hurtStackData.hurtNum or 0, "主伤害目标剩余血量", _hurtStackData.mainDefObjPropCom and _hurtStackData.mainDefObjPropCom:GetHp(), "连带伤害目标netID", _hurtStackData.extraDefUnit and _hurtStackData.extraDefUnit:GetNetId(), "连带伤害目标objID", _hurtStackData.extraDefObj and _hurtStackData.extraDefObj:GetObjectId(), "连带伤害数值", _hurtStackData.extraHurtNum, "连带伤害目标剩余血量", _hurtStackData.extraDefObjPropCom and _hurtStackData.extraDefObjPropCom:GetHp())
		--LogTools.LogByLevel(LogLevel.log, "CheckHurt", "守方当前阶段", _hurtStackData.defObjPropCom:GetCurStage(), "守方当前阶段血量", _hurtStackData.defObjPropCom:GetCurStageLeftHp(), "阶段总数", _hurtStackData.defObjPropCom:GetMaxStage())
		LogTools.LogByLevel(LogLevel.log, "CheckHurt")
	end
end

---走对应伤害通道
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__SwitchHurtChannel(_hurtStackData)
	if _hurtStackData.hurtChannelType == HurtChannelType.Element then
		self:__OnElementHurt(_hurtStackData)
	elseif _hurtStackData.hurtChannelType == HurtChannelType.Normal then
		self:__OnNormalHurt(_hurtStackData)
	elseif _hurtStackData.hurtChannelType == HurtChannelType.EleBreakExplode then
		self:__OnElementBreakExplodeHurt(_hurtStackData)
	elseif _hurtStackData.hurtChannelType == HurtChannelType.ReactionElement then
		self:__OnElementReactiveHurt_EleType(_hurtStackData)
	elseif _hurtStackData.hurtChannelType == HurtChannelType.ReactionPhysic then
		self:__OnElementReactiveHurt_PhysicType(_hurtStackData)
	end
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "伤害公式结果", _hurt)
	end
end

---计算技能类型对应的伤害加成
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcSkillTypeHurtAdd(_hurtStackData)
	local _snapShotData = _hurtStackData.snapShotData
	if _snapShotData:GetIsEleBreakTrig() then
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次伤害来源于元素击破，跳过技能类型伤害加成")
			return
		end	
	end
	
	local _skillTypeHurtAdd = _snapShotData:GetSkillTypeHurtAdd()
	_hurtStackData.hurtNum = _hurtStackData.hurtNum * (1 + _skillTypeHurtAdd)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "技能类型", _hurtStackData.snapShotData:GetHurtSkillType(), "技能类型伤害加成", _skillTypeHurtAdd, "技能类型修正后伤害", _hurtStackData.hurtNum)
	end
end

---计算传导带来的伤害修正系数
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcSpreadHurtFix(_hurtStackData)
	local _eleSpreadCount, _eleSpreadHurtFix = _hurtStackData.snapShotData:GetEleSpreadHurtFix()
	_hurtStackData.hurtNum = _hurtStackData.hurtNum * _eleSpreadHurtFix
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "目标netId", _hurtStackData.defNetId, "来源ID", _hurtStackData.snapShotData:GetSourceId(), "传导次数（默认0）", _eleSpreadCount, "传导带来的伤害修正系数（默认1）", _eleSpreadHurtFix, "传导修正后伤害", _hurtStackData.hurtNum)
	end
end

---计算元素弱点通用伤害加成
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcEleWeakCommonHurtAdd(_hurtStackData)
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _weakEleTypeList = _hurtStackData.defObjPropCom:GetEleWeakTypeList()
	local _eleTypeWeakHurtAdd = 1
	local _atkEleWeakTypeCommonHurtAdd = 0
	for _, _weakEleId in pairs(_weakEleTypeList) do
		_atkEleWeakTypeCommonHurtAdd = _atkSnapShot:GetEleTypeWeakHurtAdd(_weakEleId)
		_eleTypeWeakHurtAdd = _eleTypeWeakHurtAdd * (1 + _atkEleWeakTypeCommonHurtAdd)
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "计算元素弱点通用伤害加成", "受击方弱点类型ID", _weakEleId, "攻方弱点类型通用伤害加成", _atkEleWeakTypeCommonHurtAdd)
		end
	end
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		if 0 == #_weakEleTypeList then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "计算元素弱点通用伤害加成", "受击方没有配置元素弱点类型")
		end
	end
	
	_hurtStackData.hurtNum = _hurtStackData.hurtNum * _eleTypeWeakHurtAdd
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "计算元素弱点通用伤害加成", "最终加成比例", _eleTypeWeakHurtAdd, "加成后伤害", _hurtStackData.hurtNum)
	end
end

---计算部位伤害加成
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcBlockHurt(_hurtStackData)

	local _hurtNum = _hurtStackData.hurtNum
	if _hurtNum == 0 then return end
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "分块前伤害", _hurtNum)
	end

	--根据不同伤害类型获取分块修正系数
	local _blockFix = _hurtStackData.isReaction and _hurtStackData.defBlockCom:GetBlockReactHurtParam(_hurtStackData.defBlockId) or _hurtStackData.defBlockCom:GetBlockNormalHurtParam(_hurtStackData.defBlockId)
	
	if _hurtStackData.isWeakHurt then
		--弱点伤害加成
		_hurtNum = _hurtNum * _blockFix * (1 + _hurtStackData.snapShotData:GetWeakHurtAdd())
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次命中弱点", "分块伤害系数", _blockFix, "分块后伤害", _hurtNum)
		end
	else
		--没有击中弱点
		_hurtNum = _hurtNum * _blockFix
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次没有命中弱点", "分块伤害系数", _blockFix, "分块后伤害", _hurtNum)
		end
	end

	_hurtStackData.hurtNum = _hurtNum
end

---计算堆叠和暴击
---@private
---@param _hurtStackData HurtStackData 
function HurtChannel:__CalcStackNumAndCritical(_hurtStackData)

	if _hurtStackData.hurtNum == 0 then return end
	
	local _hurtNum = _hurtStackData.hurtNum * (_hurtStackData.stackNum or 1)

	if not _hurtStackData.directHurtNum then
		_hurtStackData.isCritical = self:__CheckHasCrit(_hurtStackData.snapShotData)
		if _hurtStackData.isCritical then
			_hurtNum = self:__OnCriticalHurt(_hurtStackData.snapShotData, _hurtNum)
		end
	end

	_hurtStackData.hurtNum = _hurtNum
end

---指定技能伤害修正
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcSpecificSkillFix(_hurtStackData)
	
	local _snapShotData = _hurtStackData.snapShotData
	if _snapShotData:GetIsEleBreakTrig() then
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次伤害来源于元素击破，跳过指定技能伤害修正")
			return
		end	
	end
	
	local _fromSkillId = _snapShotData:GetOriginalHeroSkillId()
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "__CalcSkillFix", "初始技能ID", _fromSkillId)
	end
	
	local _skillExtraDamage = 0
	local _atkObjBuffCom = _snapShotData:GetObjBuffCom()
	if _atkObjBuffCom and _fromSkillId and _fromSkillId > 0 then
		_skillExtraDamage = _atkObjBuffCom:CorrectExtraDamage(_snapShotData:GetOriginalHeroSkillId(), _defObject)
	end
	
	_hurtStackData.hurtNum = _hurtStackData.hurtNum  + _skillExtraDamage
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "_fromSkillId", _fromSkillId, "技能额外伤害终值增加(obj层)", _skillExtraDamage)
	end
end

---计算伤害距离衰减
---@private
---@param _snapShotData SnapShotData
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcDisReduce(_hurtStackData)
	if _hurtStackData.hurtNum == 0 then return end
	
	_hurtStackData.hurtNum = _hurtStackData.hurtNum * _hurtStackData.disReduceParam
end

---计算元素反应伤害修正
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CalcReactionFix(_hurtStackData)
	if _hurtStackData.hurtChannelType ~= HurtChannelType.ReactionElement then return end
	if _hurtStackData.hurtNum == 0 then return end

	local _reactionId = _hurtStackData.reactId
	local _defObj = _hurtStackData.defObj
	local _hurtNum = _hurtStackData.hurtNum
	local _atkBuffFix = 0
	local _defBuffFix = 0

	local _atkUnitBuffCom = _hurtStackData.snapShotData:GetUnitBuffCom()
	if _atkUnitBuffCom then
		_atkBuffFix = _atkUnitBuffCom:CorrectTargetElementDamage(_defObj, _reactionId)
	end
	local _defUnitBuffCom = _hurtStackData.defUnitBuffCom
	if _defUnitBuffCom then
		_defBuffFix = _defUnitBuffCom:CorrectElementBeDamage(_reactionId)
	end
	_hurtNum = _hurtNum * (1 + _defBuffFix + _atkBuffFix)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "_reactionId", _reactionId, "防御方buff元素反应伤害变化率(unit层)", _defBuffFix, "攻击方buff元素反应伤害变化率(unit层)", _atkBuffFix)
	end

	_atkBuffFix = 0
	_defBuffFix = 0

	local _atkObjBuffCom = _hurtStackData.snapShotData:GetObjBuffCom()
	if _atkObjBuffCom then
		_atkBuffFix = _atkObjBuffCom:CorrectTargetElementDamage(_defObj, _reactionId)
	end
	local _defObjBuffCom = _hurtStackData.defObjBuffCom
	if _defObjBuffCom then
		_defBuffFix = _defObjBuffCom:CorrectElementBeDamage(_reactionId)
	end
	_hurtNum = _hurtNum * (1 + _defBuffFix + _atkBuffFix)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "_reactionId", _reactionId, "防御方buff元素反应伤害变化率(obj层)", _defBuffFix, "攻击方buff元素反应伤害变化率(obj层)", _atkBuffFix)
	end

	_hurtStackData.hurtNum = _hurtNum
end

---计算技能最终伤害修正
---@private
---@param _hurtStackData HurtStackData 
function HurtChannel:__CalcSkillFinalFix(_hurtStackData)

	if _hurtStackData.hurtNum == 0 then return end

	local _snapShotData = _hurtStackData.snapShotData
	if _snapShotData:GetIsEleBreakTrig() then
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次伤害来源于元素击破，跳过技能最终伤害修正")
			return
		end	
	end

	local _fromSkillId = _snapShotData:GetOriginalHeroSkillId()
	if not _fromSkillId or -1 == _fromSkillId then return end

	local _hurtNum = _hurtStackData.hurtNum
	local _defObj = _hurtStackData.defObj
	local _atkBuffFix = 0
	local _defBuffFix = 0

	local _atkUnitBuffCom = _snapShotData:GetUnitBuffCom()
	if _atkUnitBuffCom then
		_atkBuffFix = _atkUnitBuffCom:CorrectTargetDamage(_defObj, _fromSkillId)
	end
	local _defUnitBuffCom = _hurtStackData.defUnitBuffCom
	if _defUnitBuffCom then
		_defBuffFix = _defUnitBuffCom:CorrectBeDamage(_fromSkillId)
	end
	_hurtNum = _hurtNum * (1 + _defBuffFix + _atkBuffFix)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "_fromSkillId", _fromSkillId, "防御方buff最终伤害变化率(unit层)", _defBuffFix, "攻击方buff最终伤害变化率(unit层)", _atkBuffFix)
	end

	_atkBuffFix = 0
	_defBuffFix = 0

	local _atkObjBuffCom = _snapShotData:GetObjBuffCom()
	if _atkObjBuffCom then
		_atkBuffFix = _atkObjBuffCom:CorrectTargetDamage(_defObj, _fromSkillId)
	end
	local _defObjBuffCom = _hurtStackData.defObjBuffCom
	if _defObjBuffCom then
		_defBuffFix = _defObjBuffCom:CorrectBeDamage(_fromSkillId)
	end
	_hurtNum = _hurtNum * (1 + _defBuffFix + _atkBuffFix)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "_fromSkillId", _fromSkillId, "防御方buff最终伤害变化率(obj层)", _defBuffFix, "攻击方buff最终伤害变化率(obj层)", _atkBuffFix)
	end

	_hurtStackData.hurtNum = _hurtNum
end

---元素附着
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__DealElementAttach(_hurtStackData)
	if _hurtStackData.hurtChannelType ~= HurtChannelType.Element then return end
	if _hurtStackData.hurtNum == 0 then return end
	local _atkSnapShot = _hurtStackData.snapShotData
	local _elementCom = _hurtStackData.defElementCom
	
	---是否屏蔽本次伤害
	local _maskDamage = false
	---@type BattleElementType
	local _addElementType = _atkSnapShot:GetAddElementType()
	if _elementCom and _addElementType and (_addElementType ~= BattleElementTypeEnum.PHYSIC and _addElementType ~= BattleElementTypeEnum.NONE) then
		local _addElementNum = _atkSnapShot:GetAddRandedElementNum()
		--_addElementNum = 10000
		if _addElementNum > 0 then
			---@type ElementStackEffect
			local _ElementStackEffect = _elementCom:AddElement(_addElementType, _addElementNum, _atkSnapShot:GetHurtParam(), _hurtStackData.hurtNum, _atkSnapShot:GetNetId(), _atkSnapShot:GetObjId(), _hurtStackData.defBlockId, _atkSnapShot:GetCanTriggerElementReact(), _atkSnapShot:GetOriginalHeroSkillId(), _hurtStackData.elementSourceType, _hurtStackData.elementSourceId)
			_maskDamage = (_ElementStackEffect and _ElementStackEffect.denyOriginalDamage == 1)
			_hurtStackData.trigEvent = _hurtStackData.trigEvent and (not _ElementStackEffect or _ElementStackEffect.trigEventMask ~= 1)
			if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
				LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	发生添加元素", "部位ID", _hurtStackData.defBlockId, "添加元素类型", _addElementType:GetName(), "添加元素数量", _addElementNum, "原始技能ID", _atkSnapShot:GetOriginalHeroSkillId())
			end
		end
	end
	
	_hurtStackData.damageMask = _maskDamage
	if _maskDamage and LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	触发特殊类型元素反应，本次元素伤害被屏蔽")
	end
end

---处理掉血
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__RealDealHurt(_hurtStackData)

	if _hurtStackData.damageMask then return end
	local _hurtNum = _hurtStackData.hurtNum
	if 0 == _hurtNum then return end

	--先扣覆盖护罩
	---@type BattleUnitCom_CoverShield
	local _unitShieldCom = _hurtStackData.mainDefUnit and _hurtStackData.mainDefUnit:GetComponent(BattleUnitComponentType.CoverShield)
	if _unitShieldCom and _unitShieldCom:GetCurValue() > 0 then
		_hurtNum = _unitShieldCom:OnCoverShieldHurt(_hurtNum)
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "覆盖护罩计算后主目标剩余伤害", _hurtNum)
		end
		---这里覆盖护罩的伤害也被记录在了伤害信息里，但英雄并没有掉血，所以表现上可能会比较奇怪，策划并没有给方案
		if 0 == _hurtNum then return end
	end

	local _atkNetId = _hurtStackData.snapShotData:GetNetId()
	--先记录最后一次伤害来源
	---@type BattleUnitCom_TagSelector
	local _tagCom = _hurtStackData.mainDefUnit and _hurtStackData.mainDefUnit:GetComponent(BattleUnitComponentType.TagSelector)
	if _tagCom then
		_tagCom:SetTag(BattleUnitTagEnum.LastHurtFromNetID, _atkNetId)
	end
	_tagCom = _hurtStackData.extraDefUnit and _hurtStackData.extraDefUnit:GetComponent(BattleUnitComponentType.TagSelector)
	if _tagCom then
		_tagCom:SetTag(BattleUnitTagEnum.LastHurtFromNetID, _atkNetId)
	end

	if _hurtStackData.mainDefObjPropCom then
		_hurtStackData.mainDefObjPropCom:ChangeHp(-_hurtNum)
		local _defBlockCom = _hurtStackData.defBlockCom
		if _defBlockCom then
			_defBlockCom:OnBlockDamage(_hurtStackData.defBlockId, -_hurtNum, _atkNetId, _hurtStackData.snapShotData:GetObjId())
		end
	end

	local _extraHurtNum = 0
	--计算连带伤害
	if _hurtStackData.extraDefUnit then
		_extraHurtNum = _hurtNum * _hurtStackData.extraHurtParam
		_hurtStackData.extraHurtNum = _extraHurtNum
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次伤害有连带伤害对象", "连带伤害目标netId", _hurtStackData.extraDefUnit:GetNetId(), "连带伤害目标objId", _hurtStackData.extraDefObj:GetObjectId(), "连带伤害衰减系数", _hurtStackData.extraHurtParam, "连带伤害初始值", _extraHurtNum)
		end
		
		---有连带受伤时，也需要先扣除连带受伤对象的覆盖护罩
		_unitShieldCom = _hurtStackData.extraDefUnit:GetComponent(BattleUnitComponentType.CoverShield)
		if _unitShieldCom and _unitShieldCom:GetCurValue() > 0 then
			_extraHurtNum = _unitShieldCom:OnCoverShieldHurt(_extraHurtNum)
			if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
				LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "覆盖护罩计算后剩余连带伤害", _extraHurtNum)
			end
		end
		if _extraHurtNum > 0 then
			_hurtStackData.extraDefObjPropCom:ChangeHp(-_extraHurtNum)
		end
	else
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "本次伤害没有连带伤害对象")
		end
	end

	--处理仇恨值
	self:__CountHurtHatred(_hurtStackData, _hurtNum, _extraHurtNum)
end
------------------------------------------------------------------------------------------------------------------------

---治疗通道
---@public
---@param _snapShotData SnapShotData
---@param _defUnit BattleUnitBase 受击方unit
---@param _defObject BattleObjectBase 受击方object
---@param _stackNum number 堆叠倍率
function HurtChannel:OnCure(_snapShotData, _defUnit, _defObject, _stackNum)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "治疗通道开始", "攻方NetId", _snapShotData:GetNetId(), "守方NetId", _defUnitNetId, "守方ObjId", _defObject:GetObjectId(), "堆叠层数", _stackNum)
	end

	---@type BattleUnitCom_Camp
	local _defCampCom = _defUnit:GetComponent(BattleUnitComponentType.Camp)
	if not _defCampCom then return nil end
	if not BattleUnitCom_Camp.CheckCampCurable(_snapShotData:GetFirstCamp(), _defCampCom:GetFirstCamp()) then
		----LogTools.LogByLevel(LogLevel.log, "HurtChannel", "OnHurt", "camp can not hurt !!!")
		return nil
	end
	
	---@type BattleObjCom_Property
	local _defProperty = _defObject:GetComponent(BattleObjectComponentType.Property)
	if not _defProperty then return nil end
	
	local _unitHurtInfoS2C = {}
	_unitHurtInfoS2C.netId = _defUnit:GetNetId()
	_unitHurtInfoS2C.objectId = _defObject:GetObjectId()
	_unitHurtInfoS2C.fromNetId = _snapShotData:GetNetId()
	_unitHurtInfoS2C.fromObjId = _snapShotData:GetObjId()
	_unitHurtInfoS2C.type = 2

	local _oldHp = _defProperty:GetHp()
	local _cureNum = self:__OnCure(_snapShotData, _defProperty) --计算出来的是正值
	
	local _fromSkillId = _snapShotData:GetOriginalHeroSkillId()
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "OnCure", "初始技能ID", _fromSkillId)
	end
	local _skillExtraCure = 0
	local _atkObjBuffCom = _snapShotData:GetObjBuffCom()
	if _atkObjBuffCom and _fromSkillId and _fromSkillId > 0 then
		_skillExtraCure = _atkObjBuffCom.buffCom:CorrectTargetHeal(_defObject, _fromSkillId)
	end
	_cureNum = _cureNum * (1 + _skillExtraCure)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "OnCure", "施法者额外治疗加成", _skillExtraCure)
	end
	_cureNum = _cureNum * _stackNum
	_defProperty:ChangeHp(_cureNum)
	local _defCurHp = _defProperty:GetHp()

	--local _showNum = math.ceil(_cureNum)  --血量恢复显示向上取整(向上取整放到最后处理)
	if 0 == _cureNum then return nil end
	_unitHurtInfoS2C.isCritical = false --治疗永远没有暴击
	_unitHurtInfoS2C.num = _cureNum
	_unitHurtInfoS2C.hurtEleType = BattleElementTypeEnum.PHYSIC:GetId()
	_unitHurtInfoS2C.isEleReaction = false
	_unitHurtInfoS2C.reactionType = -1
	_unitHurtInfoS2C.sourceType = _snapShotData:GetSourceType()
	_unitHurtInfoS2C.sourceId = _snapShotData:GetSourceId()
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "治疗通道结束", "最终治疗数值", _cureNum, "守方治疗前血量", _oldHp, "守方治疗后血量", _defCurHp, "objId", _defObject:GetObjectId())
		LogTools.LogByLevel(LogLevel.log, "CheckHurt")
	end
	return _unitHurtInfoS2C
end

------------------------------------------------------------------------------------------------------------------------
---普通伤害计算
--- 伤害 = 攻方ATK * （1 + 攻方总物理伤害加深 - 敌方总物理伤害加深抵抗）* （1 + 攻方总物理伤害减免抵抗 - 敌方总物理伤害减免） * （1 - 敌方减伤比） * 伤害系数 * 随机系数
---这里的攻方ATK只是一个代指，可能会被其他属性的值代替
--- 普攻存在距离伤害削减
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__OnNormalHurt(_hurtStackData)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	本次为物理伤害", "伤害 = 攻方ATK * （1 + 攻方总物理伤害加深 - 敌方总物理伤害加深抵抗）* （1 + 攻方总物理伤害减免抵抗 - 敌方总物理伤害减免） * （1 - 敌方减伤比） * 伤害系数 * 随机系数")
	end
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _atk = _atkSnapShot:GetCalcUseAtk()
	local _atkHurtAdd  = _atkSnapShot:GetHurtAdd()
	local _atkAntiHurtReduce = _atkSnapShot:GetAntiHurtReduce()
	local _defAntiHurtAdd = _hurtStackData.defObjPropCom:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Normal)
	local _defHurtReduce = _hurtStackData.defObjPropCom:GetPropertyByName(BattlePropertyEnum.HurtReduce_Normal)
	local _defHurtReduceParam = self:__CountHurtReduce(_hurtStackData.defObjPropCom)
	local _hurtParam = _atkSnapShot:GetHurtParam()
	local _randomUtil = GetBattleRoom(self.battleId).randomUtil
	local _hurtRandom = _randomUtil:RandomInt(95, 105) * 0.01
	
	_hurtStackData.hurtNum = _atk * 
					 Mathf.Clamp(1 + _atkHurtAdd - _defAntiHurtAdd, 0, 100) * 
					 Mathf.Clamp(1 + _atkAntiHurtReduce - _defHurtReduce, 0, 100) * 
			         (1 - _defHurtReduceParam) * 
					 _hurtParam * 
	                 _hurtRandom
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	攻方atk", _atk, "攻方物理伤害加深", _atkHurtAdd, "攻方物理减伤抗性", _atkAntiHurtReduce, "守方物理伤害加深抗性", _defAntiHurtAdd, "守方物理减伤", _defHurtReduce, "守方减伤比", _defHurtReduceParam, "伤害系数", _hurtParam, "随机系数", _hurtRandom, "物理伤害计算结果", _hurtStackData.hurtNum)
	end
end

---元素伤害计算
--- 伤害 = 攻方ATK * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比）* 伤害系数 * 随机系数
---这里的攻方ATK只是一个代指，可能会被其他属性的值代替
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__OnElementHurt(_hurtStackData)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	本次为元素伤害", "元素类型", _hurtStackData.snapShotData:GetElementType():GetName(), "伤害 = 攻方ATK * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比）* 伤害系数 * 随机系数")
	end
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _defProperty = _hurtStackData.defObjPropCom
	local _elementType = _hurtStackData.hurtElementType
	local _atk = _atkSnapShot:GetCalcUseAtk()
	local _atkHurtAdd  = _atkSnapShot:GetHurtAdd()
	local _atkAntiHurtReduce = _atkSnapShot:GetAntiHurtReduce()
	local _defAntiHurtAdd = _defProperty:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Element_Common) + _defProperty:GetPropertyByName(_elementType:GetAntiElementHurtAddName())
	_defAntiHurtAdd = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.AntiHurtAdd_Element_Common), _defAntiHurtAdd)
	--if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
	--	LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	_defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Element_Common)", _defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Element_Common), "_elementType:GetElementHurtReduceName()", _elementType:GetElementHurtReduceName(), "_defProperty:GetPropertyByName(_elementType:GetElementHurtReduceName()", _defProperty:GetPropertyByName(_elementType:GetElementHurtReduceName())
	--end
	local _defHurtReduce = _defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Element_Common) + _defProperty:GetPropertyByName(_elementType:GetElementHurtReduceName())
	_defHurtReduce = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.HurtReduce_Element_Common), _defHurtReduce)
	local _defHurtReduceParam = self:__CountHurtReduce(_defProperty)
	_hurtParam = _atkSnapShot:GetHurtParam()
	local _randomUtil = GetBattleRoom(self.battleId).randomUtil
	local _hurtRandom = _randomUtil:RandomInt(95, 105) * 0.01

	_hurtStackData.hurtNum = _atk *
			Mathf.Clamp(1 + _atkHurtAdd - _defAntiHurtAdd, 0, 100) *
			Mathf.Clamp(1 + _atkAntiHurtReduce - _defHurtReduce, 0, 100) *
			(1 - _defHurtReduceParam) *
			_hurtParam *
			_hurtRandom

	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	攻方atk", _atk, "攻方元素伤害加深", _atkHurtAdd, "攻方元素减伤抗性", _atkAntiHurtReduce, "守方元素伤害加深抗性", _defAntiHurtAdd, "守方元素减伤", _defHurtReduce, "守方减伤比", _defHurtReduceParam, "伤害系数", _hurtParam, "随机系数", _hurtRandom, "元素伤害计算结果", _hurtStackData.hurtNum)
	end
end

---元素反应伤害计算(带元素类型)
--- 伤害 = 攻方ATK * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比）* 伤害系数 * （1 + 能量系数）*a *随机系数
---这里的攻方ATK只是一个代指，可能会被其他属性的值代替
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__OnElementReactiveHurt_EleType(_hurtStackData)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	本次为元素反应伤害", "元素类型", _hurtStackData.snapShotData:GetElementType():GetName(), "伤害 = 攻方ATK * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比）* 伤害系数 * （1 + 能量系数）*a *随机系数")
	end
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _defProperty = _hurtStackData.defObjPropCom
	local _elementType = _atkSnapShot:GetElementType()
	local _atk = _atkSnapShot:GetCalcUseAtk()
	local _atkHurtAdd  = _atkSnapShot:GetHurtAdd()
	local _atkAntiHurtReduce = _atkSnapShot:GetAntiHurtReduce()
	local _antiElementHurtAdd = _elementType:GetAntiElementHurtAddName()
	local _defAntiHurtAdd = _defProperty:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Element_Common) + _defProperty:GetPropertyByName(_antiElementHurtAdd)
	_defAntiHurtAdd = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.AntiHurtAdd_Element_Common), _defAntiHurtAdd)
	local _elementHurtReduce = _elementType:GetElementHurtReduceName()
	local _defHurtReduce = _defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Element_Common) + _defProperty:GetPropertyByName(_elementHurtReduce)
	_defHurtReduce = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.HurtReduce_Element_Common), _defHurtReduce)
	local _defHurtReduceParam = self:__CountHurtReduce(_defProperty)
	local _hurtParam = _atkSnapShot:GetHurtParam()
	local _randomUtil = GetBattleRoom(self.battleId).randomUtil
	local _hurtRandom = _randomUtil:RandomInt(95, 105) * 0.01
	local _enParam = _atkSnapShot:GetEnparam() * _atkSnapShot:GetReactEnFix()
	
	_hurtStackData.hurtNum = _atk * 
					 Mathf.Clamp(1 + _atkHurtAdd - _defAntiHurtAdd, 0, 100) * 
					 Mathf.Clamp(1 + _atkAntiHurtReduce - _defHurtReduce, 0, 100) * 
			         (1 - _defHurtReduceParam) * 
					 _hurtParam * 
					 (1 + _enParam) *
					 HurtManager.enParamA * 
	                 _hurtRandom
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	攻方atk", _atk, "攻方伤害加深", _atkHurtAdd, "攻方伤害减免抗性", _atkAntiHurtReduce, "守方伤害加深抗性", _defAntiHurtAdd, "守方伤害减免", _defHurtReduce, "守方减伤比", _defHurtReduceParam, "随机系数", _hurtRandom, "伤害系数", _hurtParam, "能量系数原始值", _atkSnapShot:GetEnparam(), "能量系数元素反应修正", _atkSnapShot:GetReactEnFix(), "最终能量系数", _enParam, "特殊系数ParamA", HurtManager.enParamA, "元素反应伤害计算结果", _hurtStackData.hurtNum)
	end
end

---元素反应伤害计算(不带元素类型)
--- 伤害 = 攻方ATK * （1 + 攻方总物理伤害加深 - 敌方总物理伤害加深抵抗）*（1 + 攻方总物理伤害减免抵抗 - 敌方总物理伤害减免）*（1 - 敌方减伤比）* 伤害系数 * （1 + 能量系数）*a *随机系数
---这里的攻方ATK只是一个代指，可能会被其他属性的值代替
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__OnElementReactiveHurt_PhysicType(_hurtStackData)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	本次为元素反应伤害(物理)", "伤害 = 攻方ATK * （1 + 攻方总物理伤害加深 - 敌方总物理伤害加深抵抗）*（1 + 攻方总物理伤害减免抵抗 - 敌方总物理伤害减免）*（1 - 敌方减伤比）* 伤害系数 * （1 + 能量系数）*a *随机系数")
	end
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _defProperty = _hurtStackData.defObjPropCom
	local _atk = _atkSnapShot:GetCalcUseAtk()
	local _atkHurtAdd  = _atkSnapShot:GetHurtAdd()
	local _atkAntiHurtReduce = _atkSnapShot:GetAntiHurtReduce()
	local _defAntiHurtAdd = _defProperty:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Normal)
	local _defHurtReduce = _defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Normal)
	local _defHurtReduceParam = self:__CountHurtReduce(_defProperty)
	local _hurtParam = _atkSnapShot:GetHurtParam()
	local _hurtRandom = self.battleRoom.randomUtil:RandomInt(95, 105) * 0.01
	local _enParam = _atkSnapShot:GetEnparam() * _atkSnapShot:GetReactEnFix()

	_hurtStackData.hurtNum = _atk *
					 Mathf.Clamp(1 + _atkHurtAdd - _defAntiHurtAdd, 0, 100) *
					 Mathf.Clamp(1 + _atkAntiHurtReduce - _defHurtReduce, 0, 100) *
			         (1 - _defHurtReduceParam) *
					 _hurtParam *
					 (1 + _enParam) *
					 HurtManager.enParamA *
	                 _hurtRandom

	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	攻方atk", _atk, "攻方伤害加深", _atkHurtAdd, "攻方伤害减免抗性", _atkAntiHurtReduce, "守方伤害加深抗性", _defAntiHurtAdd, "守方伤害减免", _defHurtReduce, "守方减伤比", _defHurtReduceParam, "随即系数", _hurtRandom, "伤害系数", _hurtParam, "能量系数原始值", _atkSnapShot:GetEnparam(), "能量系数元素反应修正", _atkSnapShot:GetReactEnFix(), "最终能量系数", _enParam, "特殊系数ParamA", HurtManager.enParamA, "元素反应伤害计算结果", _hurtStackData.hurtNum)
	end
end

---元素积累满时的普通爆炸伤害
--- 伤害 = （ 攻方等级 * M + 攻方元素击破 * N） * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比） * (1 + 击破百分比增伤) * (1 + 弱点元素类型的击破伤害加成)
---弱点元素类型可能有多个，依次计算
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__OnElementBreakExplodeHurt(_hurtStackData)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	本次为元素击破爆炸伤害", "爆炸BUFF配置的元素类型", _hurtStackData.snapShotData:GetElementType():GetName(), "伤害 = （ 攻方等级 * M + 攻方元素击破 * N） * （1 + 攻方总元素伤害加深 - 敌方总元素伤害加深抵抗）*（1 + 攻方总元素伤害减免抵抗 - 敌方总元素伤害减免）*（1 - 敌方减伤比） * (1 + 击破百分比增伤) * (1 + 弱点元素类型的击破伤害加成)")
	end
	
	local _atkSnapShot = _hurtStackData.snapShotData
	local _defProperty = _hurtStackData.defObjPropCom
	local _elementType = _hurtStackData.hurtElementType
	local _atkLevel = _atkSnapShot:GetLevel()
	local _atkEleWeakBreak = _atkSnapShot:GetElementWeakBreak()
	local _defHurtReduceParam = self:__CountHurtReduce(_defProperty)
	---@type ElementStackEffect
    local _elementStackEffect = self.battleRoom.inputDataSource:GetDict("ElementStackEffect", _hurtStackData.eleBreakId)
    local _m = _elementStackEffect.numericalParams[1] or 0
	local _n = _elementStackEffect.numericalParams[2] or 0
	local _eleBreakHurtAdd = _atkSnapShot:GetEleBreakHurtAdd()
	local _atkHurtAdd  = _atkSnapShot:GetHurtAdd()
	local _atkAntiHurtReduce = _atkSnapShot:GetAntiHurtReduce()

	local _eleTypeBreakHurtAdd = 1
	local _weakEleTypeList = _hurtStackData.defObjPropCom:GetEleWeakTypeList()
	local _atkEleWeakBreakTypeAdd
	for _, _weakEleId in pairs(_weakEleTypeList) do
		_atkEleWeakBreakTypeAdd = _atkSnapShot:GetEleTypeBreakHurtAdd(_weakEleId)
		_eleTypeBreakHurtAdd = _eleTypeBreakHurtAdd * (1 + _atkEleWeakBreakTypeAdd)
		if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	受击方弱点类型ID", _weakEleId, "攻方弱点类型击破伤害加成", _atkEleWeakBreakTypeAdd)
		end
	end
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		if 0 == #_weakEleTypeList then
			LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	受击方没有配置元素弱点类型")
		end
	end
	
	local _defAntiHurtAdd
	local _defHurtReduce
	if _elementType == BattleElementTypeEnum.PHYSIC or _elementType == BattleElementTypeEnum.NONE then
		_defAntiHurtAdd = _hurtStackData.defObjPropCom:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Normal)
		_defHurtReduce = _hurtStackData.defObjPropCom:GetPropertyByName(BattlePropertyEnum.HurtReduce_Normal)
	else
		_defAntiHurtAdd = _defProperty:GetPropertyByName(BattlePropertyEnum.AntiHurtAdd_Element_Common) + _defProperty:GetPropertyByName(_elementType:GetAntiElementHurtAddName())
		_defAntiHurtAdd = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.AntiHurtAdd_Element_Common), _defAntiHurtAdd)
		_defHurtReduce = _defProperty:GetPropertyByName(BattlePropertyEnum.HurtReduce_Element_Common) + _defProperty:GetPropertyByName(_elementType:GetElementHurtReduceName())
		_defHurtReduce = self.battleRoom.inputDataSource:FormatPropLimit(ProtoEnumTool.GetPropertyId(BattlePropertyEnum.HurtReduce_Element_Common), _defHurtReduce)
	end
	
	_hurtStackData.hurtNum = (_atkLevel * _m + _atkEleWeakBreak * _n) * 
							Mathf.Clamp(1 + _atkHurtAdd - _defAntiHurtAdd, 0, 100) *
							Mathf.Clamp(1 + _atkAntiHurtReduce - _defHurtReduce, 0, 100) *
							(1 - _defHurtReduceParam) *
							(1 + _eleBreakHurtAdd) * 
							_eleTypeBreakHurtAdd
	
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	攻方等级", _atkLevel, "攻方元素击破", _atkEleWeakBreak, "攻方伤害加深", _atkHurtAdd, "攻方减伤抗性", _atkAntiHurtReduce, "守方伤害加深抗性", _defAntiHurtAdd, "守方减伤", _defHurtReduce, "守方减伤比", _defHurtReduceParam, "元素击破ID",  _hurtStackData.eleBreakId, "元素击破配置参数", dumpTableEx(_elementStackEffect.numericalParams), "攻方元素击破伤害加成", _eleBreakHurtAdd, "最终弱点类型击破伤害加成", _eleTypeBreakHurtAdd, "爆炸伤害计算结果", _hurtStackData.hurtNum)
	end
end

---治疗量计算
---治疗量 = 具体治疗值 * （1 + 施法者治疗加值 + 目标者受治疗加值）* （1 + 施法者技能类型治疗加成）
---@param _atkSnapShot SnapShotData 攻击方属性快照
---@param _defProperty BattleObjCom_Property 受击方属性组件
function HurtChannel:__OnCure(_atkSnapShot, _defProperty)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	计算治疗量", "治疗量 = 具体治疗值 * （1 + 施法者治疗加值 + 目标者受治疗加值）* （1 + 施法者技能类型治疗加成）")
	end
	
	local _cureValue = _atkSnapShot:GetCureValue()
	local _curerAdd
	
	local _atkObj = self.battleRoom.battleObjectManager:GetObject(_atkSnapShot:GetObjId())
	if not _atkObj then
		_curerAdd = _atkSnapShot:GetCurePercentAdd()
	else
		---@type BattleObjCom_Property
		local _propCom = _atkObj:GetComponent(BattleObjectComponentType.Property)
		if not _propCom then
			_curerAdd = _atkSnapShot:GetCurePercentAdd()
		else
			_curerAdd = _propCom:GetPropertyByName(BattlePropertyEnum.Cure_PercentAdd_Curer)
		end
	end
	local _curedAdd = _defProperty:GetPropertyByName(BattlePropertyEnum.Cure_PercentAdd_Cured)
	local _skillCureAdd = _atkSnapShot:GetSkillTypeCureAdd()
	local _cureNum = _cureValue * (1 + _curerAdd + _curedAdd) * (1 + _skillCureAdd)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	治疗量计算结束", "治疗值", _cureValue, "施法者治疗加成", _curerAdd, "受治疗者治疗加成", _curedAdd, "原始技能类型", _atkSnapShot:GetHurtSkillType(), "技能类型治疗加成", _skillCureAdd, "治疗量计算结果", _cureNum)
	end
	return _cureNum
end

------------------------------------------------------------------------------------------------------------------------
---检查是否发生暴击
---@private
---@param _atkSnapShot SnapShotData 攻击方属性快照
---@param _directHurtNum number 直接指定伤害
function HurtChannel:__CheckHasCrit(_atkSnapShot)

	local _critRate = _atkSnapShot:GetCritRate()
	local _critRet = false
	if _critRate > 0 then
		local _randomUtil = GetBattleRoom(self.battleId).randomUtil
		local _critRand = _randomUtil:RandomInt(0, 100) * 0.01
		_critRet = _critRand < _critRate
	end

	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	暴击检查", "暴击率", _critRate, "暴击随机值", _critRand, "暴击结果", _critRet)
	end
	return _critRet
end

---暴击伤害计算
---伤害 = 伤害 *（基础暴击伤害率 + 暴伤加成）
---@private
---@param _atkSnapShot SnapShotData 攻击方属性快照
function HurtChannel:__OnCriticalHurt(_atkSnapShot, _hurtNum)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	计算暴击伤害", "伤害 = 伤害 *（基础暴击伤害率 + 暴伤加成）")
	end
	local _hurtAdd = _atkSnapShot:GetCritHurtAdd()
	local _critHurtRet = _hurtNum * _hurtAdd
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	暴击伤害计算结束", "最终爆伤加成", _hurtAdd, "暴击伤害计算结果", _critHurtRet)
	end
	return _critHurtRet
end

---计算减伤比
---减伤比 = 受击方防御/（ 受击方防御 + 受击方等级 * 减伤参数1 + 减伤参数2 ）
---减伤比 ≤ 95%
---@private
---@param _defProperty BattleObjCom_Property 受击方属性组件
function HurtChannel:__CountHurtReduce(_defProperty)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	计算减伤比", "减伤比 = 受击方防御/（ 受击方防御 + 受击方等级 * 减伤参数1 + 减伤参数2 ）")
	end
	local _def = _defProperty:GetPropertyByName(BattlePropertyEnum.Def)
	local _hurtReduce = _def/(_def + _defProperty:GetLevel() * HurtManager.hurtReduceParam1 + HurtManager.hurtReduceParam2);
	_hurtReduce = Mathf.Clamp(_hurtReduce, 0, 0.95)
	if LogTools.HurtLog and CheckLogLevel(LogLevel.log) then
		LogTools.LogByLevel(LogLevel.log, "CheckHurt", "HurtChannel", "	减伤比计算结束", "守方Def", _def, "守方等级", _defProperty:GetLevel(), "减伤比特殊参数param1", HurtManager.hurtReduceParam1, "减伤比特殊参数param2", HurtManager.hurtReduceParam2, "减伤比计算结果", _hurtReduce)
	end
	return _hurtReduce
end

---计算仇恨值
---@private
---@param _hurtStackData HurtStackData
function HurtChannel:__CountHurtHatred(_hurtStackData, _hurtNum, _extraHurtNum)
	
	local _snapShotData = _hurtStackData.snapShotData
	local _atkNetId = _snapShotData:GetNetId()
	local _hatredParam = _snapShotData:GetHatredParam()
	local _atkFirstCamp = _snapShotData:GetFirstCamp()
	
	---@type BattleUnitBase
	local _unit = _hurtStackData.mainDefUnit
	---@type BattleUnitCom_Hatred
	local _defHatredCom = _unit and _unit:GetComponent(BattleUnitComponentType.Hatred)
	if _defHatredCom then
		if BattleUnitCom_Camp.CheckCampHatrable(_atkFirstCamp, _unit:GetComponent(BattleUnitComponentType.Camp):GetFirstCamp()) then
			_defHatredCom:OnHurt(_atkNetId, _hurtNum, _hatredParam)
		end
	end
	
	_unit = _hurtStackData.extraDefUnit
	_defHatredCom = _unit and _unit:GetComponent(BattleUnitComponentType.Hatred)
	if _defHatredCom then
		if BattleUnitCom_Camp.CheckCampHatrable(_atkFirstCamp, _unit:GetComponent(BattleUnitComponentType.Camp):GetFirstCamp()) then
			_defHatredCom:OnHurt(_atkNetId, _extraHurtNum, _hatredParam)
		end
	end
end

------------------------------------------------------------------------------------------------------------------------ 
function HurtChannel:Clear()
	LogTools.HurtLog = nil
end

return HurtChannel