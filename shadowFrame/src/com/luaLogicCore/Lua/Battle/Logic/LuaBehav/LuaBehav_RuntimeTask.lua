---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2021/12/21 14:31
--- Describe: 行为树任务基类
--- 生命周期：
---    行为树第一次被激活时调用OnAwake，整个生命周期只调用一次
---    进入到该节点行为时执行OnStart，每次新进入都会执行
---    行为树被暂停时，会执行当前running节点的OnPause
---    行为树从暂停恢复时，会执行当前running节点的OnResume
---    行为树打断当前节点的running状态时，会执行被打断节点的OnAbort
---    节点状态变为Success，行为树从当前节点正常退出时，会执行当前节点的OnExit，此时不会执行OnAbort


---@class LuaBehav_RuntimeTask : table
---@field configTask LuaBehav_ConfigTask
 LuaBehav_RuntimeTask = class(nil, "LuaBehav_RuntimeTask")
function LuaBehav_RuntimeTask:ctor(_data) end

------------------------------------------------------------------------------------------------------------------------
---@param _runtimeBehavTree LuaBehav_RuntimeBehavTree
---@param _configTask LuaBehav_ConfigTask
function LuaBehav_RuntimeTask:__Init(_battleId, _runtimeBehavTree, _taskIndex, _parentTaskIndex, _configTask, _cntInParent)
	----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeTask", "__Init", "_taskIndex", _taskIndex, "_configTask", dumpTableEx(_configTask))
	---@type number
	self.battleId = _battleId
	self.battleRoom = GetBattleRoom(self.battleId)
	self.behavTree = _runtimeBehavTree
	self.netId = _runtimeBehavTree.netId
	self.index = _taskIndex
	self.parentTaskIndex = _parentTaskIndex
	_runtimeBehavTree.parentIndexDic[_taskIndex] = _parentTaskIndex
	self.configTask = _configTask
	self:__InitConfigTaskVariables(_configTask.variables, _runtimeBehavTree.treeVariableDic)
	self.type = _configTask.nodeType
	self.editorOnlyId = _configTask.nodeId
	if LuaBehav_RuntimeBehavTree.CheckTime then
		self.typeDesc = LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _configTask.nodeType)
	end
	self.cntInParent = _cntInParent
	self.__taskState = LuaBehav_Define_TaskState.Inactive
	self.__editorShowTaskState = LuaBehav_Define_TaskState.Inactive
	self.__editorShowDirty = false
	self.paused = false

	self.__callRet = true
	self.__isParentTask = nil
	self.__interruptTag = _configTask.interrupttag --是否设置了打断
	self.childIndexList = {}
	self.childStateList = {}
	---@type boolean[]
	self.childHideList = {} -- 单独记录一下吧，免得影响已有的状态切换
	self.curExcuteChildCnt = 0
	--LuaBehav_DebugTool.PrintLog("_runtimeBehavTree",_runtimeBehavTree,"_taskIndex",_taskIndex,"_parentTaskIndex",_parentTaskIndex,"nodeType",self.type)
end

---@private
function LuaBehav_RuntimeTask:__InitConfigTaskVariables(_variableDic, _treeVariableDic)
	---@type LuaBehav_RuntimeVariableBase[]
	self.variables = {}
	if not _variableDic then return end
	for _key, _configVariable in pairs(_variableDic) do
		self.variables[_key] = LuaBehav_RuntimeVariableBase.New()
		self.variables[_key]:Init(_configVariable, _treeVariableDic)
	end
end

--
function LuaBehav_RuntimeTask:__OnAwake()
	self:__SetTaskState(LuaBehav_Define_TaskState.Inactive)
end

function LuaBehav_RuntimeTask:__OnStart()
	self:__SetTaskState(LuaBehav_Define_TaskState.Running)
end

function LuaBehav_RuntimeTask:__OnPause()
	self.paused = true
end

function LuaBehav_RuntimeTask:__OnResume()
	self.paused = false
end

function LuaBehav_RuntimeTask:__OnAbort()
	self.__editorShowDirty = true
	self.__editorShowTaskState = LuaBehav_Define_TaskState.Inactive
end

function LuaBehav_RuntimeTask:__OnExit()
	local _defaultState = LuaBehav_Define_TaskState.Inactive
	self:__ResetAllChildState(_defaultState)
	self:__ResetCurExecuteCnt()
	self:__SetTaskState(_defaultState)
end

function LuaBehav_RuntimeTask:__OnChildStart()
	local _curCnt = self.curExcuteChildCnt + 1
	while self.childHideList[_curCnt] do
		_curCnt = _curCnt + 1
	end
	self.curExcuteChildCnt = _curCnt
	local _stateList = self.childStateList
	if _curCnt > #_stateList then return end
	--if self.index == 6 then
	--	LogTools.LogByLevel(LogLevel.log, "self.childIndexList[_curCnt]", self.childIndexList[_curCnt], "self.behavTree.__framePopStackBottomDic", dumpTableEx(self.behavTree.__framePopStackBottomDic))
	--end
	if not self.behavTree.__framePopStackBottomDic[self.childIndexList[_curCnt]] then
		_stateList[_curCnt] = LuaBehav_Define_TaskState.Running
	end
end

function LuaBehav_RuntimeTask:__OnChildExecuted(_cnt, _taskState)
	--if self.index == 10 or self.index == 6 then
	--	LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeTask", "__OnChildExecuted", "_cnt", _cnt, "#self.childStateList", #self.childStateList, "_taskState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _taskState), "index", self.index)
	--end
	local _stateList = self.childStateList
	if _cnt > #_stateList then return end
	_stateList[_cnt] = _taskState
end

function LuaBehav_RuntimeTask:__OnChildExit(_cnt, _taskState)
	local _stateList = self.childStateList
	if _cnt > #_stateList then return end
	_stateList[_cnt] = _taskState
end

function LuaBehav_RuntimeTask:__GetCurExcuteChildIndex()
	return self.childIndexList[self.curExcuteChildCnt]
end

function LuaBehav_RuntimeTask:__ResetAllChildState(_taskState)
	local _stateList = self.childStateList
	for i = 1, #_stateList do
		_stateList[i] = _taskState
	end
end

function LuaBehav_RuntimeTask:__ResetCurExecuteCnt()
	self.curExcuteChildCnt = 0	
end

function LuaBehav_RuntimeTask:__CheckCanParallel()
	return false
end

function LuaBehav_RuntimeTask:__IsInterruptTask()
	return false
end

function LuaBehav_RuntimeTask:__CheckInterruptTag()
	return self.__interruptTag
end

function LuaBehav_RuntimeTask:__SetTaskState(_taskState)
	self.__taskState = _taskState
end

function LuaBehav_RuntimeTask:__GetTaskState()
	return self.__taskState
end

function LuaBehav_RuntimeTask:__ReCountTaskState(_taskState)
	self:__SetTaskState(self.__taskState)
	return _taskState 
end

-- 检查状态
function LuaBehav_RuntimeTask:__CheckTaskState(_taskState)
	return self.__taskState == _taskState
end

function LuaBehav_RuntimeTask:__CheckCanExecute()
	return self.__taskState ~= LuaBehav_Define_TaskState.Abort	
end

---子节点向父节点注册自己的隐藏状态
---@protected
function LuaBehav_RuntimeTask:__SetHideState(_childCnt, _bool)
	self.childHideList[_childCnt] = _bool
end

-- 检查是否为父任务
function LuaBehav_RuntimeTask:__IsParentTask()
	local _ret = self.__isParentTask
	if nil == _ret then
		_ret = (#self.childIndexList > 0)
		self.__isParentTask = _ret
	end
	return _ret
end

-- 是否为条件类任务
function LuaBehav_RuntimeTask:__IsConditionalTask()
	return false
end

--- 是否是强制评估节点
---@public
function LuaBehav_RuntimeTask:__IsForceReevaluateTask()
	return false
end

function LuaBehav_RuntimeTask:__OnUpdate(_deltaTime)
	local _state = LuaBehav_Define_TaskState.Success
	if not self.__callRet then
		_state = LuaBehav_Define_TaskState.Failure
	end
	self:__SetTaskState(_state)

	-- 服务器调用统计
	if SERVER_LIB then
		SERVER_LIB.performanceService:collectCount(CollectCountType.BEHAV_TREE_NODE_COUNT)
	end
	return _state
end

function LuaBehav_RuntimeTask:__Clear()
	self.behavTree = nil
	self.netId = nil
	self.index = nil
	self.parentTaskIndex = nil
	self.configTask = nil
	self.type = nil
	self.cntInParent = nil
	self.paused = nil
	self.__callRet = nil
	self.__isParentTask = nil
	self.__interruptTag = nil
	self.__taskState = nil
	self.__editorShowTaskState = nil
	self.__editorShowDirty = nil
	self.childIndexList = nil
	self.childStateList = nil
	self.curExcuteChildCnt = nil
	for _, _variableBase in pairs(self.variables) do
		_variableBase:Clear()
	end
	self.variables = nil
end

------------------------------------------------------------------------------------------------------------------------
---@public
---@param _runtimeBehavTree LuaBehav_RuntimeBehavTree
---@param _configTask LuaBehav_ConfigTask
function LuaBehav_RuntimeTask:Init(_battleId, _runtimeBehavTree, _taskIndex, _parentTaskIndex, _configTask, _cntInParent)
	self:__Init(_battleId, _runtimeBehavTree, _taskIndex, _parentTaskIndex, _configTask, _cntInParent)
	
end

-- 行为树第一次被激活时调用
---@public
function LuaBehav_RuntimeTask:OnAwake()
	self:__OnAwake()
end

-- 进入节点时调用
---@public
function LuaBehav_RuntimeTask:OnStart()
	self:__OnStart()
end

-- 节点暂停时调用
---@public
function LuaBehav_RuntimeTask:OnPause()
	self:__OnPause()
end

-- 节点从暂停恢复时调用
---@public
function LuaBehav_RuntimeTask:OnResume()
	self:__OnResume()
end

-- 节点被打断时调用
---@public
function LuaBehav_RuntimeTask:OnAbort()
	self:__OnAbort()
end

-- 退出节点时调用
---@public
function LuaBehav_RuntimeTask:OnExit()
	self:__OnExit()
end

-- 子节点开始时调用
---@public
function LuaBehav_RuntimeTask:OnChildStart()
	self:__OnChildStart()
end

-- 子节点运行时调用
---@public
function LuaBehav_RuntimeTask:OnChildExecuted(_cnt, _taskState)
	self:__OnChildExecuted(_cnt, _taskState)
end

-- 子节点退出时调用
---@public
function LuaBehav_RuntimeTask:OnChildExit(_cnt, _taskState)
	self:__OnChildExit(_cnt, _taskState)
end

-- 获取当前正在进行的子任务的index
---@public
function LuaBehav_RuntimeTask:GetCurExcuteChildIndex()
	return self:__GetCurExcuteChildIndex()
end

-- 节点的tick
---@public
function LuaBehav_RuntimeTask:OnUpdate(_deltaTime)
	return self:__OnUpdate(_deltaTime)
end

-- 获取当前状态
---@public
function LuaBehav_RuntimeTask:GetTaskState()
	return self:__GetTaskState()
end

-- 重新评估任务的执行状态
-- 部分父任务的状态最终由子任务的状态决定
-- 这里由不同类型的父任务继承后各自根据实际的逻辑自己实现
---@public
function LuaBehav_RuntimeTask:ReCountTaskState(_taskState)
	return self:__ReCountTaskState(_taskState)
end

-- 设置为强制弹出
function LuaBehav_RuntimeTask:SetForceState()
	if self:__CheckTaskState(LuaBehav_Define_TaskState.Running) then
		self:SetTaskState(LuaBehav_Define_TaskState.ForcePop)
	end
	for i = 1, #self.childIndexList do
		local _task = self.behavTree:GetTask(self.childIndexList[i])
		if _task then
			_task:SetForceState()
		end
	end
end

-- 设置当前状态
---@public
function LuaBehav_RuntimeTask:SetTaskState(_taskState)
	self:__SetTaskState(_taskState)
end

-- 检查状态
---@public
function LuaBehav_RuntimeTask:CheckTaskState(_taskState)
	return self:__CheckTaskState(_taskState)
end

-- 重置所有子任务状态
---@public
function LuaBehav_RuntimeTask:ResetAllChildState(_taskState)
	self:__ResetAllChildState(_taskState)
end

-- 重置当前子任务执行进度
---@public
function LuaBehav_RuntimeTask:ResetCurExecuteCnt()
	self:__ResetCurExecuteCnt()
end

-- 检查是否为父任务
---@public
function LuaBehav_RuntimeTask:IsParentTask()
	return self:__IsParentTask()
end

-- 是否为条件类任务
---@public
function LuaBehav_RuntimeTask:IsConditionalTask()
	return self:__IsConditionalTask()
end

--- 是否是强制评估节点
---@public
function LuaBehav_RuntimeTask:IsForceReevaluateTask()
	return self:__IsForceReevaluateTask()
end

--- 强制重评估
---@public
function LuaBehav_RuntimeTask:ForceReevaluate(_deltaTime)
	
end

-- 是否为打断类任务
---@public
function LuaBehav_RuntimeTask:IsInterruptTask()
	return self:__IsInterruptTask()
end

-- 是否设置了打断
---@public
function LuaBehav_RuntimeTask:CheckInterruptTag()
	return self:__CheckInterruptTag()
end

-- 检查是否可以并行
---@public
function LuaBehav_RuntimeTask:CheckCanParallel()
	return self:__CheckCanParallel()
end

-- 检查当前是否满足继续运行的条件
---@public
function LuaBehav_RuntimeTask:CheckCanExecute()
	return self:__CheckCanExecute()
end

---设置跳过执行的子节点
---区别于隐藏的子节点，跳过执行的子节点的状态在自身重新计算状态时会生效
---@public
function LuaBehav_RuntimeTask:SetChildSkip(_childCnt)
	
end

---子节点向自己注册隐藏状态
---区别于跳过执行的子节点，隐藏的子节点的状态在自身重新计算状态时也不计算在内
---@public
function LuaBehav_RuntimeTask:SetHideState(_childCnt, _bool)
	self:__SetHideState(_childCnt, _bool)
end

---向自己的父节点注册隐藏状态
---@public
function LuaBehav_RuntimeTask:SetHideStateToParent(_bool)
	local _parent = self.behavTree:GetTask(self.parentTaskIndex)
	if not _parent then return end
	_parent:SetHideState(self.cntInParent, _bool)
end

---隐藏的子节点重新计算隐藏状态
---@public
function LuaBehav_RuntimeTask:RecountHidedChildren()
	local _childIndex
	local _childIndexList = self.childIndexList
	local _childTask
	for i = 1, #self.childHideList do
		if self.childHideList[i] then
			_childIndex = _childIndexList[i]
			_childTask = self.behavTree:GetTask(_childIndex)
			if _childTask then
				_childTask:RecountHideState()
			end
		end
	end
end

---重新计算自己的隐藏状态
---@public
function LuaBehav_RuntimeTask:RecountHideState()
	
end

---尝试直接返回状态
---@public
function LuaBehav_RuntimeTask:GetDirectState(_preState)
	return nil
end

---获取当前时间
---从行为树模块获取
---根据所属行为树类型不同，获取的接口不同
---@public
function LuaBehav_RuntimeTask:GetCurTimeCnt()
	if self.behavTree.belongType == LuaBehav_Define_TreeBelongType.Level then
		return self.battleRoom.behaviorManager:GetLevelTimeCnt()
	else
		return self.battleRoom.behaviorManager:GetUnitTimeCnt()
	end
end

-- 注册消息触发监听
---@public
function LuaBehav_RuntimeTask:RegistListenEvent(_listenId)
	self.behavTree:RegistTaskListenEvent(_listenId, self)
end

-- 移除消息触发监听
---@public
function LuaBehav_RuntimeTask:RemoveListenEvent(_listenId)
	self.behavTree:RemoveTaskListenEvent(_listenId, self)
end

-- 监听的消息触发
---@public
function LuaBehav_RuntimeTask:OnListenEvent(_param)
	
end

---@public
function LuaBehav_RuntimeTask:ResetEditorShowState(_state)
	self.__editorShowTaskState = _state
	self.__editorShowDirty = true

	for _, _index in pairs(self.childIndexList) do
		local _childTask = self.behavTree:GetTask(_index)
		if _childTask then
			_childTask:ResetEditorShowState(_state)
		end
	end
end

---@public
function LuaBehav_RuntimeTask:SetEditorShowState(_state)
	if self.__editorShowTaskState == _state then
		return
	end

	self.__editorShowTaskState = _state
	self.__editorShowDirty = true
end

---行为树可视化的数据收集
---@public
---@param _type number 1 全量 2 变化
function LuaBehav_RuntimeTask:GetDebugTaskShowInfo(_type)
	if _type == 1 then
		local _ProtoHashInt2Int = {}
		_ProtoHashInt2Int.key = self.editorOnlyId
		_ProtoHashInt2Int.value = self.__editorShowTaskState
		return _ProtoHashInt2Int
	elseif _type == 2 then
		if self.__editorShowDirty then
			self.__editorShowDirty = false
			local _ProtoHashInt2Int = {}
			_ProtoHashInt2Int.key = self.editorOnlyId
			_ProtoHashInt2Int.value = self.__editorShowTaskState
			return _ProtoHashInt2Int
		end
	end
	return nil
end

-- 清理
---@public
function LuaBehav_RuntimeTask:Clear()
	self:__Clear()
end

return LuaBehav_RuntimeTask