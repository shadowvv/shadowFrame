---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2021/12/21 14:29
--- Describe: 运行时行为树数据类
---

---@class LuaBehav_RuntimeBehavTree : table
LuaBehav_RuntimeBehavTree = class(nil, "LuaBehav_RuntimeBehavTree")
function LuaBehav_RuntimeBehavTree:ctor(_data) end
LuaBehav_RuntimeBehavTree.CheckTime = false

local _runTask = "RunTask"
local _pushTask = "PushTask"
local _popTask = "PopTask"

---@param _behavManager LuaBehav_RuntimeManager
function LuaBehav_RuntimeBehavTree:Init(_battleId, _behavManager, _index, _variableDic, _belongType, _netId, _treeName)
	self.runtimeBehavMgr = _behavManager
	self.__index = _index
	self.belongType = _belongType
	---@type number
	self.battleId = _battleId
	self.battleRoom = GetBattleRoom(_battleId)
	self.netId = _netId
	self.treeName = _treeName
	---@type LuaBehav_RuntimeTask[]
	self.activeStackList = {}
	---@type number[]
	self.interruptionIndexList = {}
	--自定义变量表(老的，手填的)
	self.variableDic = {}
	--配置导出的树共享变量表
	self.treeVariableDic = {}
	if _variableDic then
		for _key, _value in pairs(_variableDic) do
			if type(_value) == "table" then
				self.treeVariableDic[_key] = Vector3.New(_value.x or 0, _value.y or 0, _value.z or 0)
			else
				self.treeVariableDic[_key] = _value
			end
		end
	end
	--LogTools.LogByLevel(LogLevel.logErr, "treeVariableDic", dumpTableEx(self.treeVariableDic))
	
	--触发打断的栈
	self.trigInterruptionStackNum = -1
	--由于打断等待被重新压入栈的列表
	self.waitRepushStack = Stack.New()

	---@type LuaBehav_RuntimeTask[]
	self.taskList = {}
	self.parentIndexDic = {}  -- taskIndex - parentTaskIndex
	---@type LuaBehav_RuntimeTask[]
	self.interruptionTaskDic = {}
	---@type LuaBehav_RuntimeTask[]
	self.conditionalTaskList = {}
	---@type LuaBehav_RuntimeTask[]
	self.forceReevaluateTaskList = {}  --某些非条件节点，但是仍然需要重新评估的节点
	---@type LuaBehav_Define_TaskState[]
	self.conditionalStateList = {}
	---@type number[]
	self.conditionInterruptionParentIndexDic = {}
	self.__stackBottomDic = {}
	self.__framePopStackBottomDic = {}
	
	self.__stackPopTag = false
	
	---@type LuaBehav_RuntimeTask[][]
	self.__taskListenDic = {}
	
	self.__variableDirty = false
	
	self.__tmpTab_1 = {}
	self.__tmpTab_2 = {}
end
------------------------------------------------------------------------------------------------------------------------
function LuaBehav_RuntimeBehavTree:OnUpdate(_deltaTime)
	--if self.netId == 2 then
	--	LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree", "OnUpdate start", "self.__index", self.__index)
	--end
	
	for _key, _ in pairs(self.__framePopStackBottomDic) do
		self.__framePopStackBottomDic[_key] = nil
	end
	self:__ReevaluateConditionalTasks()
	self:__DealInterruptions()
	self:__DealRepush()
	self:__ClearEmptyStacks()
	self:__TickActiveStacks(_deltaTime)
	self:__ForceReevaluate(_deltaTime)
	--if self.netId == 2 then
	--	LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree", "OnUpdate end", "self.__index", self.__index)
	--	LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree")
	--	LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree")
	--end
end

-- 重新评估条件类任务
function LuaBehav_RuntimeBehavTree:__ReevaluateConditionalTasks(_taskState, _checkTaskIndex)
	local _conditionalTaskList = self.conditionalTaskList
	local _conditionalStateList = self.conditionalStateList
	local _interruptionParentIndexDic = self.conditionInterruptionParentIndexDic
	----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "#_conditionalTaskList", #_conditionalTaskList)
	for i = 1, #_conditionalTaskList do
		local _conditionalTask = _conditionalTaskList[i]
		local _conditionalTaskIndex = _conditionalTask.index
		if not _checkTaskIndex or _checkTaskIndex > _conditionalTaskIndex then
			----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "_conditionalTaskIndex", _conditionalTaskIndex, "type", --LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _conditionalTask.type))
			local _parentInterruptionIndex = _interruptionParentIndexDic[_conditionalTaskIndex]
			----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "_parentInterruptionIndex", _parentInterruptionIndex)
			if _parentInterruptionIndex and -1 ~= _parentInterruptionIndex then
				local _curState = _conditionalTask:OnUpdate(0)
				----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "_curState", --LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _curState))
				local _preState = _conditionalStateList[i]
				
				----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "_preState", --LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _preState))
				if _preState ~= _curState then
					_conditionalStateList[i] = _curState
					--if _curState == LuaBehav_Define_TaskState.Success then --这里只有为true时才打断么
					if _preState then
						--if self.__index == 4 then
						--	LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "tree index", self.__index, "Interrupt!!!", "_conditionalTaskIndex", _conditionalTaskIndex, LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _conditionalTask.type), "_preState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _preState), "_curState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _curState), "_parentInterruptionIndex", _parentInterruptionIndex, "_checkTaskIndex", _checkTaskIndex)
						--end
						self:Interrupt(_conditionalTaskIndex)
						return LuaBehav_Define_TaskState.Abort
					end
					--end
				end
			end
		elseif _checkTaskIndex == _conditionalTaskIndex then
			_conditionalStateList[i] = _taskState
		end
	end
	return _taskState
end

-- 处理打断
function LuaBehav_RuntimeBehavTree:__DealInterruptions()
	----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__DealInterruptions start")
	local _popState = LuaBehav_Define_TaskState.Failure
	local _runningState = LuaBehav_Define_TaskState.Running
	local _interruptionIndexList = self.interruptionIndexList
	
	for i = 1, #_interruptionIndexList do
		local _interruptionIndex = _interruptionIndexList[i]
		--LuaBehav_DebugTool.PrintRuntime("          ", "i", i, "_interruptionIndex", _interruptionIndex)
		if -1 ~= _interruptionIndex then
			_interruptionIndexList[i] = -1
			local _peekTaskIndex = self:__PeekActiveStackTaskIndex(i)
			--LuaBehav_DebugTool.PrintRuntime("          ", "_peekTaskIndex", _peekTaskIndex)
			local _lcaIndex = self:__FindLCA(_interruptionIndex, _peekTaskIndex)
			--LuaBehav_DebugTool.PrintRuntime("          ", "_lcaIndex", _lcaIndex)

			local _isAbort = false
			while _peekTaskIndex and -1 ~= _peekTaskIndex and _peekTaskIndex ~= _lcaIndex do
				--LuaBehav_DebugTool.PrintRuntime("          while:", "_peekTaskIndex", _peekTaskIndex)
				local _peekTask = self:GetTask(_peekTaskIndex)
				_isAbort = false
				if _peekTask:CheckTaskState(_runningState) then
					_isAbort = true
					_peekTask:OnAbort()
				end
				self:PopTask(i, _peekTaskIndex, _popState, _isAbort)
				_peekTaskIndex = self:__PeekActiveStackTaskIndex(i)
			end

			--LuaBehav_DebugTool.PrintRuntime("          after while:", "_peekTaskIndex", _peekTaskIndex, "_lcaIndex", _lcaIndex)
			if _peekTaskIndex == _lcaIndex then
				self.trigInterruptionStackNum = i
				local _repushTaskIndex = _interruptionIndex
				local _repushTask
				local _interruptionTaskCnt
				
				while _repushTaskIndex and _repushTaskIndex ~= -1 and _repushTaskIndex ~= _lcaIndex do
					--LuaBehav_DebugTool.PrintRuntime("          while:", "_repushTaskIndex", _repushTaskIndex)
					_repushTask = self:GetTask(_repushTaskIndex)
					--if not _repushTask then
					--	LogTools.LogByLevel(LogLevel.log, "checkLuaBehav", "LuaBehav_RuntimeBehavTree", "_repushTask is nil", "_repushTaskIndex", _repushTaskIndex)
					--end
					if _repushTask then
						_interruptionTaskCnt = _repushTask.cntInParent
						--LuaBehav_DebugTool.PrintRuntime("          ", "_interruptionTaskCnt", _interruptionTaskCnt)
						self.waitRepushStack:push(_interruptionTaskCnt)
					end
					_repushTaskIndex = self.parentIndexDic[_repushTaskIndex]
				end
				--LuaBehav_DebugTool.PrintRuntime("          after while:", "_repushTaskIndex", _repushTaskIndex)
			end
			
		end
	end

	----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__DealInterruptions end")
end

-- 打断回滚
function LuaBehav_RuntimeBehavTree:__DealRepush()
	----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__DealRepush start")
	local _repushStack = self.waitRepushStack
	local _activeStackNum = self.trigInterruptionStackNum
	while not _repushStack:isEmpty() do
		local _cnt = _repushStack:pop()
		local _peekTask = self:__PeekActiveStackTask(_activeStackNum)
		if _peekTask then
			local _childIndexList = _peekTask.childIndexList
			local _childStateList = _peekTask.childStateList
			_childStateList[_cnt] = LuaBehav_Define_TaskState.Success
			_peekTask.curExcuteChildCnt = _cnt
			self:PushTask(_activeStackNum, _childIndexList[_cnt])
		end
	end
	----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__DealRepush end")
end

-- 清除空栈
function LuaBehav_RuntimeBehavTree:__ClearEmptyStacks()
	if not self.__stackPopTag then return end
	self.__stackPopTag = false

	local _stackList = self.activeStackList
	local _maxStackNum = #_stackList
	--if self.__index == 2 then
	--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks start", "_maxStackNum", _maxStackNum)
	--end
	for i = _maxStackNum, 2, -1 do
		local _stack = _stackList[i]
		--if self.__index == 2 then
		--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks", "i", i, "_stack:isEmpty()", _stack:isEmpty(), dumpTableEx(_stack))
		--end
		if _stack:isEmpty() then
			self:__RemoveActiveStack(i)
		end
	end
	
	_maxStackNum = #_stackList
	--if self.__index == 2 then
	--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks end", "_maxStackNum", _maxStackNum)
	--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks ")
	--end
end

-- tick仍然存活的栈
function LuaBehav_RuntimeBehavTree:__TickActiveStacks(_deltaTime)
	local _maxStackNum = self:__GetActiveStackNum()
	--if self.__index == 3 then
	--	LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeBehavTree", "__TickActiveStacks", "index", self.__index, "_maxStackNum", _maxStackNum)
	--end
	local _activeStack
	local _preState
	for i = _maxStackNum, 1, -1 do
		_activeStack = self.activeStackList[i]
		_preState = LuaBehav_Define_TaskState.Failure
		--if self.__index == 3 then
		--	LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeBehavTree", "__TickActiveStacks", "curStackNum", i)
		--end
		while _activeStack and 
			  not _activeStack:isEmpty() and 
			  LuaBehav_Define_TaskState.Running ~= _preState and 
			  LuaBehav_Define_TaskState.Abort ~= _preState
		do
			_preState = self:RunTask(i, self:__PeekActiveStackTaskIndex(i), _preState, _deltaTime)
		end
	end
end

---处理强制重评估类节点
function LuaBehav_RuntimeBehavTree:__ForceReevaluate(_deltaTime)
	for i = 1, #self.forceReevaluateTaskList do
		self.forceReevaluateTaskList[i]:ForceReevaluate(_deltaTime)
	end
end

-- 设置打断标记
-- _interruptionIndex 为重新评估的条件节点index
function LuaBehav_RuntimeBehavTree:Interrupt(_interruptionIndex)
	----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "Interrupt", "_interruptionIndex", _interruptionIndex)
	local _interruptionParentIndex = self.conditionInterruptionParentIndexDic[_interruptionIndex]
	local _interruptTask = self:GetTask(_interruptionIndex)
	_interruptTask:SetTaskState(LuaBehav_Define_TaskState.Abort)
	local _interruptionIndexList = self.interruptionIndexList
	local _maxStackNum = self:__GetActiveStackNum()
	----LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "Interrupt", "_maxStackNum", _maxStackNum, "self.activeStackList", dumpTableEx(self.activeStackList))
	for i = _maxStackNum, 1, -1 do
		if not _interruptionIndexList[i] or -1 == _interruptionIndexList[i] or _interruptionParentIndex < self.conditionInterruptionParentIndexDic[_interruptionIndexList[i]] then
			local _peekIndex = self:__PeekActiveStackTaskIndex(i)
			--if self.__index == 4 then
			--	LogTools.LogByLevel(LogLevel.log, "CheckLuaBehav", "LuaBehav_RuntimeBehavTree", "Interrupt", "stackNum", i, "_peekIndex", _peekIndex, "_interruptionIndex", _interruptionIndex, "self.activeStackList", dumpTableEx(self.activeStackList))
			--end
			if _peekIndex and _peekIndex > _interruptionIndex then
				local _lcaIndex = self:__FindLCA(_interruptionIndex, _peekIndex)
				--LuaBehav_DebugTool.PrintRuntime("          _lcaIndex", _lcaIndex)
				if self:__CheckIsParentOrBrother(_interruptionParentIndex, _lcaIndex) then
					---记录当前栈是被谁打断
					_interruptionIndexList[i] = _interruptionIndex
				end
			end
		end
	end
end

-- 检查是否为父辈节点或兄弟节点
function LuaBehav_RuntimeBehavTree:__CheckIsParentOrBrother(_checkIndex, _taskIndex)
	local _parentIndexDic = self.parentIndexDic
	local _parentIndex = _parentIndexDic[_checkIndex]
	while _taskIndex and -1 ~= _taskIndex do
		if _taskIndex == _checkIndex then return true end
		if _taskIndex == _parentIndex then return true end
		_taskIndex = _parentIndexDic[_taskIndex]
	end
	return false
end

-- 查找LCA
function LuaBehav_RuntimeBehavTree:__FindLCA(_taskIndex_1, _taskIndex_2)
	local _checkTab = self.__tmpTab_1
	for _key, _ in pairs(_checkTab) do
		_checkTab[_key] = nil
	end
	local _parentIndexDic = self.parentIndexDic

	local _index = _taskIndex_1
	while _index and -1 ~= _index do
		_checkTab[_index] = 1
		_index = _parentIndexDic[_index]
	end

	_index = _taskIndex_2
	while _index and not _checkTab[_index] do
		_index = _parentIndexDic[_index]
	end
	return _index
	
	--while _index and -1 ~= _index do
	--	if _checkTab[_index] then
	--		return _index
	--	else
	--		_index = _parentIndexDic[_index]
	--	end
	--end

	--return _taskIndex_2
end
------------------------------------------------------------------------------------------------------------------------
-- 任务进栈
function LuaBehav_RuntimeBehavTree:PushTask(_stackIndex, _taskIndex)
	local _task = self:GetTask(_taskIndex)
	if not _task then return end
	--LogTools.LogByLevel(LogLevel.log, "行为树打印节点", "PushTask", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex, "taskType", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _task.type))
	
	local _topIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	--if self.__index == 3 and _taskIndex == 12 then
	--	LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree:PushTask", "_topIndex", _topIndex)
	--end
	if _topIndex == _taskIndex then return end
	self:__PushTaskToActiveStack(_stackIndex, _taskIndex)
	
	_task:OnStart()
	_task:ResetEditorShowState(LuaBehav_Define_TaskState.Inactive)
end

-- 任务出栈
function LuaBehav_RuntimeBehavTree:PopTask(_stackIndex, _taskIndex, _taskState, _isAbort)
	local _task = self:GetTask(_taskIndex)
	if not _task then return end
	
	--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask 1", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex, "taskType", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _task.type))
	local _topIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask 2", "_topIndex", _topIndex)
	if not _topIndex or _topIndex ~= _taskIndex then return end
	
	self:__PopActiveStackTaskIndex(_stackIndex)
	if not _isAbort then _task:OnExit() end
	
	--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask 3")
	-- 通知父任务
	local _parentTask = self:GetTask(_task.parentTaskIndex)
	if _parentTask then
		_parentTask:OnChildExit(_task.cntInParent, _taskState)
	end

	-- 当父任务达到退出条件时，无论子任务是否在running，都退出
	--if _task:IsParentTask() then
	--	local _childIndexList = _task.childIndexList
	--	for i = 1, #_childIndexList do
	--		local _child = self:GetTask(_childIndexList[i])
	--		--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask child", "_child.index", _child.index)
	--					
	--		if _child then _child:SetForceState() end
	--	end
	--end
	--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask 5")
	if self.__stackBottomDic[_taskIndex] and _taskState ~= LuaBehav_Define_TaskState.ForcePop then
		self.__framePopStackBottomDic[_taskIndex] = 1
	end
	self.__stackBottomDic[_taskIndex] = nil
	--LogTools.LogByLevel(LogLevel.log, '行为树打印节点', "LuaBehav_RuntimeBehavTree", "PopTask end", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _task.type), "_taskIndex", _taskIndex, "_stackIndex", _stackIndex, "state", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _taskState), "self.__framePopStackBottomDic[_taskIndex]", self.__framePopStackBottomDic[_taskIndex])
end

-- 执行任务
function LuaBehav_RuntimeBehavTree:RunTask(_stackIndex, _taskIndex, _preState, _deltaTime)

	local _taskState = _preState
	local _runtimeTask = self:GetTask(_taskIndex)
	--if self.__index == 2 then
	--	LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeBehavTree", "RunTask start", "task", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _runtimeTask.type), "_taskIndex", _taskIndex, "state", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _runtimeTask:GetTaskState()))
	--end

	if _runtimeTask:CheckTaskState(LuaBehav_Define_TaskState.ForcePop) then
		_taskState = LuaBehav_Define_TaskState.Success
		self:PopTask(_stackIndex, _taskIndex, LuaBehav_Define_TaskState.ForcePop, false)
		return _taskState
	end

	---@type number
	local _startUpdateTime
	if SERVER_LIB and SERVER_LIB.performanceService:executeTimeCheck(PerformanceType.BEHAV_TREE_NODE) then
		_startUpdateTime = TimeUtils.nowExact()
	end
	
	if _runtimeTask:IsParentTask() then
		_taskState = self:RunParentTask(_stackIndex, _taskIndex, _taskState, _deltaTime)
		_taskState = _runtimeTask:ReCountTaskState(_taskState)
	else
		_taskState = _runtimeTask:OnUpdate(_deltaTime)
	end
	_runtimeTask:SetEditorShowState(_taskState)

	if LuaBehav_Define_TaskState.Abort ~= _taskState then
		_taskState = self:__ReevaluateConditionalTasks(_taskState, _taskIndex)
		--if self.__index == 2 then
		--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "RunTask checkAbort after", "_taskState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _taskState), "_taskIndex", _taskIndex)
		--end
	end
	
	local _parentTask = self:GetTask(_runtimeTask.parentTaskIndex)
	if _parentTask then
		_parentTask:OnChildExecuted(_runtimeTask.cntInParent, _taskState)
	end
	
	--LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeBehavTree", "RunTask checkAfterRun", "task", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _runtimeTask.type), "_taskState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _taskState), "_taskIndex", _taskIndex)
	if LuaBehav_Define_TaskState.Running ~= _taskState and LuaBehav_Define_TaskState.Abort ~= _taskState then
		if _runtimeTask:IsParentTask() then
			_runtimeTask:SetForceState()
		end
		self:PopTask(_stackIndex, _taskIndex, _taskState, false)
	end

	if SERVER_LIB and SERVER_LIB.performanceService:executeTimeCheck(PerformanceType.BEHAV_TREE_NODE) then
		SERVER_LIB.performanceService:checkCommonExecuteTime(PerformanceType.BEHAV_TREE_NODE, _runtimeTask.__cname, 0, self.battleId, _startUpdateTime, TimeUtils.nowExact())
	end

	--LogTools.LogByLevel(LogLevel.log, "checktime", "LuaBehav_RuntimeBehavTree", "RunTask end", "task type", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskType, _runtimeTask.type), "_taskState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _taskState), "_taskIndex", _taskIndex, "_stackIndex", _stackIndex)

	return _taskState
end

-- 执行父任务
function LuaBehav_RuntimeBehavTree:RunParentTask(_stackIndex, _taskIndex, _preState, _deltaTime)
	local _runtimeTask = self:GetTask(_taskIndex)

	if _runtimeTask:CheckTaskState(LuaBehav_Define_TaskState.ForcePop) then
		_taskState = LuaBehav_Define_TaskState.Success
		self:PopTask(_stackIndex, _taskIndex, LuaBehav_Define_TaskState.ForcePop, false)
		return _taskState
	end
	
	local _childState = _preState
	if _runtimeTask:CheckCanParallel()  then
		_runtimeTask:ResetCurExecuteCnt()
	end

	local _opeStackIndex = _stackIndex
	
	local _curChildIndex
	local _childTask
	local _nowChildState
	local _stackBottomDic = self.__stackBottomDic
	local _framePopStackBottomDic = self.__framePopStackBottomDic
	local _directState
	
	while _runtimeTask:CheckCanExecute() and
	      ( LuaBehav_Define_TaskState.Running ~= _childState or _runtimeTask:CheckCanParallel() )
	do
		_runtimeTask:OnChildStart()
		_directState = _runtimeTask:GetDirectState(_childTask)
		if _directState then
			_childState = _directState
			break
		end
		
		_curChildIndex = _runtimeTask:GetCurExcuteChildIndex()
		---@type LuaBehav_RuntimeTask
		_childTask = self:GetTask(_curChildIndex)
		--LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "RunParentTask 1", "curExcuteChildCnt", _runtimeTask.curExcuteChildCnt, "child state list", #_runtimeTask.childStateList)
		if not _childTask then break end
		
		_nowChildState = _childTask:ReCountTaskState(LuaBehav_Define_TaskState.Success)
		--LogTools.LogByLevel(LogLevel.log, "行为树打印节点", "LuaBehav_RuntimeBehavTree", "RunParentTask 1", "_nowChildState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _nowChildState), "_curChildIndex", _curChildIndex, "self.__stackBottomDic[_curChildIndex]", self.__stackBottomDic[_curChildIndex], "self._framePopStackBottomDic[_curChildIndex]", self._framePopStackBottomDic[_curChildIndex])
		if _runtimeTask:CheckCanParallel() then
			
			if _nowChildState ~= LuaBehav_Define_TaskState.Abort and 
				--_nowChildState ~= LuaBehav_Define_TaskState.Running and
				not _stackBottomDic[_curChildIndex] and 
				not _framePopStackBottomDic[_curChildIndex]
			then
				_stackBottomDic[_curChildIndex] = 1
				_opeStackIndex = self:__AddActiveStack()
				--if self.__index == 2 then
				--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks", "RunParentTask parallel open new stack", "_opeStackIndex", _opeStackIndex, "childIndex", _childTask.index, "_nowChildState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _nowChildState), "self._framePopStackBottomDic", self._framePopStackBottomDic)
				--end
				self:PushTask(_opeStackIndex, _curChildIndex)
				_childState = self:RunTask(_opeStackIndex, _curChildIndex, _preState, _deltaTime)
				--LogTools.LogByLevel(LogLevel.logErr, "_childTask.cntInParent", _childTask.cntInParent, "_childState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _childState))
				if _childState ~= LuaBehav_Define_TaskState.Running then
					_runtimeTask:SetChildSkip(_childTask.cntInParent)
				end
			else
				--if self.__index == 2 then
				--	LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "__ClearEmptyStacks", "RunParentTask parallel not open new stack", "_nowChildState", LogTools.GetEnumTableDesc(LuaBehav_Define_TaskState, _nowChildState), "childIndex", _childTask.index, "_stackBottomDic[_curChildIndex]", _stackBottomDic[_curChildIndex])
				--end
			end
			
		else
			self:PushTask(_opeStackIndex, _curChildIndex)
			_childState = self:RunTask(_opeStackIndex, _curChildIndex, _preState, _deltaTime)
		end
	end
	
	if _runtimeTask:CheckCanParallel() and
	LuaBehav_Define_TaskState.Running == _runtimeTask:ReCountTaskState(LuaBehav_Define_TaskState.Running) then
		return LuaBehav_Define_TaskState.Running
	end
	return _childState
end

------------------------------------------------------------------------------------------------------------------------
-- 检查index
function LuaBehav_RuntimeBehavTree:CheckIndex(_index)
	return self.__index == _index
end

---获取index
function LuaBehav_RuntimeBehavTree:GetIndex()
	return self.__index
end

-- 获取指定index的任务
-- 一些特殊情况的判断可以放到这个里面进行(比如树的可用性检查之类的)
---@return LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:GetTask(_index)
	if not _index or not self.taskList then return nil end
	return self.taskList[_index]
end

-- 重置任务的状态并将子任务的执行进度设置回0
-- 包括所有子任务
---@param _runtimeTask LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:ResetTask(_runtimeTask, _taskState)
	if not _runtimeTask then return end
	_runtimeTask:ResetAllChildState(_taskState)
	_runtimeTask:ResetCurExecuteCnt()
	local _childIndexList = _runtimeTask.childIndexList
	for i = 1, #_childIndexList do
		local _childTask = self:GetTask(_childIndexList[i])
		self:ResetTask(_childTask, _taskState)
	end
end

-- 向栈内压入任务
function LuaBehav_RuntimeBehavTree:__PushTaskToActiveStack(_stackIndex, _taskIndex)
	if not self.activeStackList then return end
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then return end
	_stack:push(_taskIndex)
end

-- 以peek的方式获取指定栈顶的任务index
function LuaBehav_RuntimeBehavTree:__PeekActiveStackTaskIndex(_stackIndex)
	----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "CheckLuaBehav", "__PeekActiveStackTaskIndex", "self.activeStackList", dumpTableEx(self.activeStackList))
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then
		----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "CheckLuaBehav", "__PeekActiveStackTaskIndex", "not get activeStack", _stackIndex)
		return nil 
	end
	if _stack:isEmpty() then 
		----LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeBehavTree", "CheckLuaBehav", "activeStack is empty", "not get activeStack", _stackIndex)
		return nil 
	end
	return _stack:top()
end

-- 以pop的方式获取指定栈顶的任务index
function LuaBehav_RuntimeBehavTree:__PopActiveStackTaskIndex(_stackIndex)
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then return nil end
	if _stack:isEmpty() then return nil end
	self.__stackPopTag = true
	return _stack:pop()
end

-- 以peek的方式获取指定栈顶的任务运行时数据对象
function LuaBehav_RuntimeBehavTree:__PeekActiveStackTask(_stackIndex)
	local _taskIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	if not _taskIndex or -1 == _taskIndex then return nil end
	return self:GetTask(_taskIndex)
end

-- 以pop的方式获取指定栈顶的任务运行时数据对象
function LuaBehav_RuntimeBehavTree:__PopActiveStackTask(_stackIndex)
	local _taskIndex = self:__PopActiveStackTaskIndex(_stackIndex)
	if not _taskIndex or -1 == _taskIndex then return nil end
	return self:GetTask(_taskIndex)
end

-- 添加栈，返回栈index
function LuaBehav_RuntimeBehavTree:__AddActiveStack()
	local _stackList = self.activeStackList
	local _stack = Stack.New()
	table.insert(_stackList, _stack)
	table.insert(self.interruptionIndexList, -1)
	return #_stackList
end

-- 移除栈
function LuaBehav_RuntimeBehavTree:__RemoveActiveStack(_stackIndex)
	local _activeStack = self.activeStackList
	if _stackIndex < 1 or _stackIndex > #_activeStack then return end
	table.remove(_activeStack, _stackIndex)
	table.remove(self.interruptionIndexList, _stackIndex)
end

-- 获取当前栈数量
function LuaBehav_RuntimeBehavTree:__GetActiveStackNum()
	local _activeStack = self.activeStackList
	if not _activeStack then return 0 end
	return #_activeStack
end

------------------------------------------------------------------------------------------------------------------------
-- 激活行为树
function LuaBehav_RuntimeBehavTree:OnAwake()
	local _taskList = self.taskList
	local _max = #_taskList
	for i = 1, _max do
		_taskList[i]:OnAwake()
	end
	
	self:__AddActiveStack()
	self:PushTask(1, 1)
end

-- 暂停行为树
function LuaBehav_RuntimeBehavTree:OnPause()
	local _max = self:__GetActiveStackNum()
	for i = 1, _max do
		local _task = self:__PeekActiveStackTask(i)
		if _task and _task:CheckTaskState(LuaBehav_Define_TaskState.Running) then
			_task:OnPause()
		end
	end
end

-- 恢复行为树
function LuaBehav_RuntimeBehavTree:OnResume()
	local _max = self:__GetActiveStackNum()
	for i = 1, _max do
		local _task = self:__PeekActiveStackTask(i)
		if _task and _task:CheckTaskState(LuaBehav_Define_TaskState.Running) then
			_task:OnResume()
		end
	end
end

---@public
---@param _listenId number
---@param _runtimeTask LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:RegistTaskListenEvent(_listenId, _runtimeTask)
	local _tab = self.__taskListenDic[_listenId]
	if not _tab then _tab = {} end
	_tab[_runtimeTask.index] = _runtimeTask
	self.__taskListenDic[_listenId] = _tab
end

---@public
function LuaBehav_RuntimeBehavTree:PostTaskListenEvent(_listenId, _param)
	local _tab = self.__taskListenDic[_listenId]
	if not _tab then return end
	for _, _runtimeTask in pairs(_tab) do
		_runtimeTask:OnListenEvent(_param)
	end
end

---@public
---@param _listenId number
---@param _runtimeTask LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:RemoveTaskListenEvent(_listenId, _runtimeTask)
	local _tab = self.__taskListenDic[_listenId]
	if not _tab then return end
	_tab[_runtimeTask.index] = nil
end

---@public
function LuaBehav_RuntimeBehavTree:GetTreeName()
	return self.treeName
end

---@public
function LuaBehav_RuntimeBehavTree:CheckTreeName(_name)
	return _name and _name == self.treeName
end

---@public
function LuaBehav_RuntimeBehavTree:SetTreeVariable(_id, _value, _isSharedVariable)
	if _isSharedVariable then
		self.treeVariableDic[_id:GetValue()] = _value
	else
		self.treeVariableDic[_id] = _value
	end
	self.__variableDirty = true
end

---@public
function LuaBehav_RuntimeBehavTree:GetDebugVariableShowInfo(_result)
	if not self.treeVariableDic then return end
	
	if 1 ~= _result then
		if not self.__variableDirty then return end
	end
	
	local _variables = {}
	for _key, _value in pairs(self.treeVariableDic) do
		table.insert(_variables, tostring(_key))
		if type(_value) == "table" and _value.x then
			table.insert(_variables, "(" .._value.x ..", " .._value.y ..", " .._value.z ..")")
		else
			table.insert(_variables, tostring(_value))
		end
	end
	
	self.__variableDirty = false
	--LogTools.LogByLevel(LogLevel.logErr, " GetDebugVariableShowInfo treeVariableDic", dumpTableEx(self.treeVariableDic))
	
	return _variables
end

-- 清理
function LuaBehav_RuntimeBehavTree:OnDestroy()
	--LogTools.LogByLevel(LogLevel.logErr, "LuaBehav_RuntimeBehavTree", "OnDestroy", "_index", self.__index)
	for _, _stack in pairs(self.activeStackList) do
		_stack:clear()
	end
	self.waitRepushStack:clear()
	for _, _runtimeTask in pairs(self.taskList) do
		_runtimeTask:Clear()
	end
	
	self.runtimeBehavMgr = nil
	self.__index = nil
	self.activeStackList = nil
	self.interruptionIndexList = nil
	self.variableDic = nil
	self.trigInterruptionStackNum = nil
	self.waitRepushStack = nil
	self.taskList = nil
	self.parentIndexDic = nil
	self.interruptionTaskDic = nil
	self.conditionalTaskList = nil
	self.treeName = nil
	self.conditionalStateList = nil
	self.conditionInterruptionParentIndexDic = nil
	self.__stackPopTag = nil
	self.__tmpTab_1 = nil
	self.__tmpTab_2 = nil
	self.__stackBottomDic = nil
	self.__framePopStackBottomDic = nil
end

return LuaBehav_RuntimeBehavTree