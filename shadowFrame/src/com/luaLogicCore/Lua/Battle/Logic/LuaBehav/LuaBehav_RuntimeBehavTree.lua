---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2021/12/21 14:29
--- Describe: 运行时行为树数据类
---

---@class LuaBehav_RuntimeBehavTree : table
LuaBehav_RuntimeBehavTree = class(nil, "LuaBehav_RuntimeBehavTree")
function LuaBehav_RuntimeBehavTree:ctor(_data) end

---@param _behavManager LuaBehav_RuntimeManager
function LuaBehav_RuntimeBehavTree:Init(_behavManager, _index, _netId)
	self.runtimeBehavMgr = _behavManager
	self.__index = _index
	self.netId = _netId
	---@type number[][]
	self.activeStackList = {}
	---@type number[]
	self.interruptionIndexList = {}
	--自定义变量表
	self.variableDic = {}
	--触发打断的栈
	self.trigInterruptionStackNum = -1
	--由于打断等待被重新压入栈的列表
	self.waitRepushStack = Stack.New()

	---@type LuaBehav_RuntimeTask[]
	self.taskList = {}
	self.parentIndexDic = {}  -- taskIndex - parentTaskIndex
	---@type LuaBehav_RuntimeTask[]
	self.interruptionTaskDic = {}
	---@type LuaBehav_RuntimeTask[]
	self.conditionalTaskList = {}
	---@type LuaBehav_Define_TaskState[]
	self.conditionalStateList = {}
	---@type number[]
	self.conditionInterruptionParentIndexDic = {}
	
	self.__stackPopTag = false
	
	self.__tmpTab_1 = {}
	self.__tmpTab_2 = {}
end
------------------------------------------------------------------------------------------------------------------------
function LuaBehav_RuntimeBehavTree:OnUpdate(_deltaTime)
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "OnUpdate start", "treeIndex: ", self.__index)
	--self:__ReevaluateConditionalTasks()
	self:__DealInterruptions()
	self:__DealRepush()
	self:__ClearEmptyStacks()
	self:__TickActiveStacks(_deltaTime)
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree","OnUpdate end")
end

-- 重新评估条件类任务
function LuaBehav_RuntimeBehavTree:__ReevaluateConditionalTasks(_taskState)
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__ReevaluateConditionalTasks start", "_taskState: ", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	local _conditionalTaskList = self.conditionalTaskList
	local _conditionalStateList = self.conditionalStateList
	local _interruptionParentIndexDic = self.conditionInterruptionParentIndexDic
	for i = 1, #_conditionalTaskList do
		local _conditionalTask = _conditionalTaskList[i]
		local _conditionalTaskIndex = _conditionalTask.index
		LuaBehav_DebugTool.PrintRuntime("              ", "_conditionalTask", _conditionalTaskIndex)
		local _parentInterruptionIndex = _interruptionParentIndexDic[_conditionalTaskIndex]
		LuaBehav_DebugTool.PrintRuntime("              ", "_parentInterruptionIndex", _parentInterruptionIndex)
		if _parentInterruptionIndex and -1 ~= _parentInterruptionIndex then
			local _curState = _conditionalTask:OnUpdate(0)
			LuaBehav_DebugTool.PrintRuntime("              ", "_curState", LuaBehav_DebugTool.GetTaskStateDesc(_curState))
			local _preState = _conditionalStateList[i]
			LuaBehav_DebugTool.PrintRuntime("              ", "_preState", LuaBehav_DebugTool.GetTaskStateDesc(_preState))
			if _preState ~= _curState then
				_conditionalStateList[i] = _curState
				if _curState == LuaBehav_Define_TaskState.Success then --这里只有为true时才打断么
					self:Interrupt(_conditionalTaskIndex)
					return LuaBehav_Define_TaskState.Abort
				end
			end
		end
	end
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__ReevaluateConditionalTasks end", "_taskState: ", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	return _taskState
end

-- 处理打断
function LuaBehav_RuntimeBehavTree:__DealInterruptions()
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__DealInterruptions start")
	local _popState = LuaBehav_Define_TaskState.Failure
	local _runningState = LuaBehav_Define_TaskState.Running
	local _interruptionIndexList = self.interruptionIndexList
	
	for i = 1, #_interruptionIndexList do
		local _interruptionIndex = _interruptionIndexList[i]
		LuaBehav_DebugTool.PrintRuntime("          ", "i", i, "_interruptionIndex", _interruptionIndex)
		if -1 ~= _interruptionIndex then
			_interruptionIndexList[i] = -1
			local _peekTaskIndex = self:__PeekActiveStackTaskIndex(i)
			LuaBehav_DebugTool.PrintRuntime("          ", "_peekTaskIndex", _peekTaskIndex)
			local _lcaIndex = self:__FindLCA(_interruptionIndex, _peekTaskIndex)
			LuaBehav_DebugTool.PrintRuntime("          ", "_lcaIndex", _lcaIndex)

			local _isAbort = false
			while _peekTaskIndex and -1 ~= _peekTaskIndex and _peekTaskIndex ~= _lcaIndex do
				LuaBehav_DebugTool.PrintRuntime("          while:", "_peekTaskIndex", _peekTaskIndex)
				local _peekTask = self:GetTask(_peekTaskIndex)
				_isAbort = false
				if _peekTask:CheckTaskState(_runningState) then
					_isAbort = true
					_peekTask:OnAbort()
				end
				self:PopTask(i, _peekTaskIndex, _popState, _isAbort)
				_peekTaskIndex = self:__PeekActiveStackTaskIndex(i)
			end

			LuaBehav_DebugTool.PrintRuntime("          after while:", "_peekTaskIndex", _peekTaskIndex, "_lcaIndex", _lcaIndex)
			if _peekTaskIndex == _lcaIndex then
				self.trigInterruptionStackNum = i
				local _repushTaskIndex = _interruptionIndex
				local _repushTask
				local _interruptionTaskCnt
				
				while _repushTaskIndex ~= _lcaIndex do
					LuaBehav_DebugTool.PrintRuntime("          while:", "_repushTaskIndex", _repushTaskIndex)
					_repushTask = self:GetTask(_repushTaskIndex)
					_interruptionTaskCnt = _repushTask.cntInParent
					LuaBehav_DebugTool.PrintRuntime("          ", "_interruptionTaskCnt", _interruptionTaskCnt)
					self.waitRepushStack:push(_interruptionTaskCnt)
					_repushTaskIndex = self.parentIndexDic[_repushTaskIndex]
				end
				LuaBehav_DebugTool.PrintRuntime("          after while:", "_repushTaskIndex", _repushTaskIndex)
			end
			
		end
	end

	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__DealInterruptions end")
end

-- 打断回滚
function LuaBehav_RuntimeBehavTree:__DealRepush()
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__DealRepush start")
	local _repushStack = self.waitRepushStack
	local _activeStackNum = self.trigInterruptionStackNum
	LuaBehav_DebugTool.PrintRuntime("          ", "_activeStackNum", _activeStackNum)
	while not _repushStack:isEmpty() do
		local _cnt = _repushStack:pop()
		LuaBehav_DebugTool.PrintRuntime("          ", "_cnt", _cnt)
		local _peekTask = self:__PeekActiveStackTask(_activeStackNum)
		LuaBehav_DebugTool.PrintRuntime("          ", "_peekTask", _peekTask.index)
		local _childIndexList = _peekTask.childIndexList
		local _childStateList = _peekTask.childStateList
		_childStateList[_cnt] = LuaBehav_Define_TaskState.Success
		_peekTask.curExcuteChildCnt = _cnt
		self:PushTask(_activeStackNum, _childIndexList[_cnt])
	end
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__DealRepush end")
end

-- 清除空栈
function LuaBehav_RuntimeBehavTree:__ClearEmptyStacks()
	if not self.__stackPopTag then return end
	self.__stackPopTag = false

	local _stackList = self.activeStackList
	local _maxStackNum = #_stackList
	for i = _maxStackNum, 2, -1 do
		local _stack = _stackList[i]
		if _stack:isEmpty() then
			self:__RemoveActiveStack(i)
		end
	end
end

-- tick仍然存活的栈
function LuaBehav_RuntimeBehavTree:__TickActiveStacks(_deltaTime)
	local _maxStackNum = self:__GetActiveStackNum()
	LuaBehav_DebugTool.PrintRuntime("      now stack count: ", _maxStackNum)
	for i = 1, _maxStackNum do
		local _activeStack = self.activeStackList[i]
		local _preState = LuaBehav_Define_TaskState.Failure
		
		LuaBehav_DebugTool.PrintRuntime("          >>> start tick stack: ", i, "this stack has task count: ", _activeStack:size())
		while _activeStack and 
			  not _activeStack:isEmpty() and 
			  LuaBehav_Define_TaskState.Running ~= _preState and 
			  LuaBehav_Define_TaskState.Abort ~= _preState
		do
			local _taskIndex = self:__PeekActiveStackTaskIndex(i)
			LuaBehav_DebugTool.PrintRuntime("               >> start tick task, index: ", _taskIndex)
			_preState = self:RunTask(i, _taskIndex, _preState, _deltaTime)
			LuaBehav_DebugTool.PrintRuntime("               >> end tick task, index: ", _taskIndex,  "_preState", LuaBehav_DebugTool.GetTaskStateDesc(_preState))
		end
	end
end

-- 设置打断标记
-- _interruptionIndex 为重新评估的条件节点index
function LuaBehav_RuntimeBehavTree:Interrupt(_interruptionIndex)
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "Interrupt start", "_interruptionIndex: ", _interruptionIndex)
	local _interruptionParentIndex = self.conditionInterruptionParentIndexDic[_interruptionIndex]
	LuaBehav_DebugTool.PrintRuntime("          _interruptionParentIndex", _interruptionParentIndex)
	local _interruptTask = self:GetTask(_interruptionIndex)
	_interruptTask:SetTaskState(LuaBehav_Define_TaskState.Abort)
	local _interruptionIndexList = self.interruptionIndexList
	local _maxStackNum = self:__GetActiveStackNum()
	LuaBehav_DebugTool.PrintRuntime("          LuaBehav_RuntimeBehavTree", "Interrupt 1")
	for i = 1, _maxStackNum do
		LuaBehav_DebugTool.PrintRuntime("          ", "i", i, "_interruptionIndexList[i]", _interruptionIndexList[i])
		if -1 == _interruptionIndexList[i] then
			local _peekIndex = self:__PeekActiveStackTaskIndex(i)
			if _peekIndex > _interruptionIndex then
				local _lcaIndex = self:__FindLCA(_interruptionIndex, _peekIndex)
				LuaBehav_DebugTool.PrintRuntime("          _lcaIndex", _lcaIndex)
				if self:__CheckIsParentOrBrother(_interruptionParentIndex, _lcaIndex) then
					_interruptionIndexList[i] = _interruptionIndex
				end
			end
		end
	end
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "Interrupt end")
end

-- 检查是否为父辈节点或兄弟节点
function LuaBehav_RuntimeBehavTree:__CheckIsParentOrBrother(_checkIndex, _taskIndex)
	LuaBehav_DebugTool.PrintRuntime("----->> LuaBehav_RuntimeBehavTree", "__CheckIsParentOrBrother start", "_checkIndex", _checkIndex, "_taskIndex", _taskIndex)
	local _parentIndexDic = self.parentIndexDic
	local _parentIndex = _parentIndexDic[_checkIndex]
	while _taskIndex and -1 ~= _taskIndex do
		if _taskIndex == _checkIndex then return true end
		if _parentIndex == _taskIndex then return true end
		LuaBehav_DebugTool.PrintRuntime("          ", "_taskIndex", _taskIndex, "_parentIndexDic[_taskIndex]", _parentIndexDic[_taskIndex])
		_taskIndex = _parentIndexDic[_taskIndex]
	end
	return false
end

-- 查找LCA
function LuaBehav_RuntimeBehavTree:__FindLCA(_taskIndex_1, _taskIndex_2)
	local _checkTab = self.__tmpTab_1
	for _key, _value in pairs(_checkTab) do
		_checkTab[_key] = nil
	end
	local _parentIndexDic = self.parentIndexDic
	
	local _index = _taskIndex_1
	while _index and -1 ~= _index do
		_checkTab[_index] = 1
		_index = _parentIndexDic[_index]
	end
	
	_index = _taskIndex_2
	while _index and not _checkTab[_index] do
		_index = _parentIndexDic[_index]
	end
	
	return _index
end
------------------------------------------------------------------------------------------------------------------------
-- 任务进栈
function LuaBehav_RuntimeBehavTree:PushTask(_stackIndex, _taskIndex)
	LuaBehav_DebugTool.PrintRuntime("                    PushTask", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex)
	local _task = self:GetTask(_taskIndex)
	if not _task then return end
	
	local _topIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	if _topIndex == _taskIndex then return end
	self:__PushTaskToActiveStack(_stackIndex, _taskIndex)
	
	_task:OnStart()
	
end

-- 任务出栈
function LuaBehav_RuntimeBehavTree:PopTask(_stackIndex, _taskIndex, _taskState, _isAbort)
	LuaBehav_DebugTool.PrintRuntime("                    PopTask", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex, "_taskState", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	local _task = self:GetTask(_taskIndex)
	if not _task then return end
	
	local _topIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	if not _topIndex or _topIndex ~= _taskIndex then return end
	self:__PopActiveStackTaskIndex(_stackIndex)
	if not _isAbort then
		_task:OnExit()
	end
	
	-- 通知父任务
	local _parentTask = self:GetTask(_task.parentTaskIndex)
	if _parentTask then
		_parentTask:OnChildExit(_task.cntInParent, _taskState)
	end

	-- 当父任务达到退出条件时，无论子任务是否在running，都退出
	if _task:IsParentTask() then
		local _childIndexList = _task.childIndexList
		local _childState = LuaBehav_Define_TaskState.Success
		for i = 1, #_childIndexList do
			local _child = self:GetTask(_childIndexList[i])
			if _child then
				_child:SetTaskState(_childState)
			end
		end
	end
end

-- 执行任务
function LuaBehav_RuntimeBehavTree:RunTask(_stackIndex, _taskIndex, _preState, _deltaTime)
	LuaBehav_DebugTool.PrintRuntime("    ")
	LuaBehav_DebugTool.PrintRuntime("                    --> LuaBehav_RuntimeBehavTree", "RunTask start", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex)
	local _taskState = _preState
	local _runtimeTask = self:GetTask(_taskIndex)
	LuaBehav_DebugTool.PrintRuntime("                    task type is: ", LuaBehav_DebugTool.GetTaskTypeDesc(_runtimeTask.type))

	if _runtimeTask:IsParentTask() then
		local _logStr = ""
		for i = 1, #_runtimeTask.childIndexList do
			local _childTask = self:GetTask(_runtimeTask.childIndexList[i])
			_logStr = _logStr .." child index: " .._runtimeTask.childIndexList[i] ..", child type: " ..LuaBehav_DebugTool.GetTaskTypeDesc(_childTask.type)
		end
		LuaBehav_DebugTool.PrintRuntime("                    task is parentTask, has child count: ", #_runtimeTask.childIndexList, _logStr)
		_taskState = self:RunParentTask(_stackIndex, _taskIndex, _taskState, _deltaTime)
		_taskState = _runtimeTask:ReCountTaskState(_taskState)
	else
		LuaBehav_DebugTool.PrintRuntime("                    task is not parentTask")
		_taskState = _runtimeTask:OnUpdate(_deltaTime)
	end

	LuaBehav_DebugTool.PrintRuntime("                    _taskState after normal run: ", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	if LuaBehav_Define_TaskState.Abort ~= _taskState then
		_taskState = self:__ReevaluateConditionalTasks(_taskState)
	end
	--if LuaBehav_Define_TaskState.Abort == _taskState then
	--	self:__DealInterruptions()
	--end
	LuaBehav_DebugTool.PrintRuntime("                    _taskState after ReevaluateConditionalTasks: ", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	
	local _parentTask = self:GetTask(_runtimeTask.parentTaskIndex)
	if _parentTask then
		_parentTask:OnChildExecuted(_runtimeTask.cntInParent, _taskState)
	end
	
	if LuaBehav_Define_TaskState.Running ~= _taskState and LuaBehav_Define_TaskState.Abort ~= _taskState then
		self:PopTask(_stackIndex, _taskIndex, _taskState, false)
	end
	
	LuaBehav_DebugTool.PrintRuntime("                    --> LuaBehav_RuntimeBehavTree", "RunTask end", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex, "_taskState", LuaBehav_DebugTool.GetTaskStateDesc(_taskState))
	LuaBehav_DebugTool.PrintRuntime("    ")
	return _taskState
end

-- 执行父任务
function LuaBehav_RuntimeBehavTree:RunParentTask(_stackIndex, _taskIndex, _preState, _deltaTime)
	LuaBehav_DebugTool.PrintRuntime("    ")
	LuaBehav_DebugTool.PrintRuntime("                    --> LuaBehav_RuntimeBehavTree", "RunParentTask start", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex)
	local _runtimeTask = self:GetTask(_taskIndex)
	
	if _runtimeTask:CheckCanParallel() and 
       LuaBehav_Define_TaskState.Running == _runtimeTask:ReCountTaskState(LuaBehav_Define_TaskState.Running) then 
		return _preState 
	end
	
	local _opeStackIndex = _stackIndex
	local _childState = LuaBehav_Define_TaskState.Inactive

	LuaBehav_DebugTool.PrintRuntime("                    start check child task: ", "_childState", LuaBehav_DebugTool.GetTaskStateDesc(_childState), "_runtimeTask:CheckCanParallel()", _runtimeTask:CheckCanParallel())
	
	
	while _runtimeTask:CheckCanExecute() and
	      ( LuaBehav_Define_TaskState.Running ~= _childState or _runtimeTask:CheckCanParallel() )
	do
		
		_runtimeTask:OnChildStart()
		local _curChildIndex = _runtimeTask:GetCurExcuteChildIndex()
		local _childTask = self:GetTask(_curChildIndex)
		LuaBehav_DebugTool.PrintRuntime("                        _curChildIndex",_curChildIndex)
		LuaBehav_DebugTool.PrintRuntime("                        _childTask",_childTask)
		if not _childTask then break end
		
		if _runtimeTask:CheckCanParallel() then
			_opeStackIndex = self:__AddActiveStack()
		end
		
		self:PushTask(_opeStackIndex, _curChildIndex)
		_childState = self:RunTask(_opeStackIndex, _curChildIndex, _preState, _deltaTime)
	end
	
	LuaBehav_DebugTool.PrintRuntime("                    --> LuaBehav_RuntimeBehavTree", "RunParentTask end", "_stackIndex", _stackIndex, "_taskIndex", _taskIndex, "_childState", LuaBehav_DebugTool.GetTaskStateDesc(_childState))
	LuaBehav_DebugTool.PrintRuntime("    ")
	return _childState
end

------------------------------------------------------------------------------------------------------------------------
-- 检查index
function LuaBehav_RuntimeBehavTree:CheckIndex(_index)
	return self.__index == _index
end

-- 获取指定index的任务
-- 一些特殊情况的判断可以放到这个里面进行(比如树的可用性检查之类的)
---@return LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:GetTask(_index)
	if not _index or not self.taskList then return nil end
	return self.taskList[_index]
end

-- 重置任务的状态并将子任务的执行进度设置回0
-- 包括所有子任务
---@param _runtimeTask LuaBehav_RuntimeTask
function LuaBehav_RuntimeBehavTree:ResetTask(_runtimeTask, _taskState)
	if not _runtimeTask then return end
	_runtimeTask:ResetAllChildState(_taskState)
	_runtimeTask:ResetCurExecuteCnt()
	local _childIndexList = _runtimeTask.childIndexList
	for i = 1, #_childIndexList do
		local _childTask = self:GetTask(_childIndexList[i])
		self:ResetTask(_childTask, _taskState)
	end
end

-- 向栈内压入任务
function LuaBehav_RuntimeBehavTree:__PushTaskToActiveStack(_stackIndex, _taskIndex)
	if not self.activeStackList then return end
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then return end
	_stack:push(_taskIndex)
end

-- 以peek的方式获取指定栈顶的任务index
function LuaBehav_RuntimeBehavTree:__PeekActiveStackTaskIndex(_stackIndex)
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then return nil end
	if _stack:isEmpty() then return nil end
	return _stack:top()
end

-- 以pop的方式获取指定栈顶的任务index
function LuaBehav_RuntimeBehavTree:__PopActiveStackTaskIndex(_stackIndex)
	local _stack = self.activeStackList[_stackIndex]
	if not _stack then return nil end
	if _stack:isEmpty() then return nil end
	self.__stackPopTag = true
	return _stack:pop()
end

-- 以peek的方式获取指定栈顶的任务运行时数据对象
function LuaBehav_RuntimeBehavTree:__PeekActiveStackTask(_stackIndex)
	local _taskIndex = self:__PeekActiveStackTaskIndex(_stackIndex)
	if not _taskIndex or -1 == _taskIndex then return nil end
	return self:GetTask(_taskIndex)
end

-- 以pop的方式获取指定栈顶的任务运行时数据对象
function LuaBehav_RuntimeBehavTree:__PopActiveStackTask(_stackIndex)
	local _taskIndex = self:__PopActiveStackTaskIndex(_stackIndex)
	if not _taskIndex or -1 == _taskIndex then return nil end
	return self:GetTask(_taskIndex)
end

-- 添加栈，返回栈index
function LuaBehav_RuntimeBehavTree:__AddActiveStack()
	local _stackList = self.activeStackList
	local _stack = Stack.New()
	table.insert(_stackList, _stack)
	table.insert(self.interruptionIndexList, -1)
	return #_stackList
end

-- 移除栈
function LuaBehav_RuntimeBehavTree:__RemoveActiveStack(_stackIndex)
	local _activeStack = self.activeStackList
	if _stackIndex < 1 or _stackIndex > #_activeStack then return end
	table.remove(_activeStack, _stackIndex)
	table.remove(self.interruptionIndexList, _stackIndex)
end

-- 获取当前栈数量
function LuaBehav_RuntimeBehavTree:__GetActiveStackNum()
	local _activeStack = self.activeStackList
	if not _activeStack then return 0 end
	return #_activeStack
end

------------------------------------------------------------------------------------------------------------------------
-- 激活行为树
function LuaBehav_RuntimeBehavTree:OnAwake()
	local _taskList = self.taskList
	local _max = #_taskList
	for i = 1, _max do
		_taskList[i]:OnAwake()
	end
	
	self:__AddActiveStack()
	self:PushTask(1, 1)
end

-- 暂停行为树
function LuaBehav_RuntimeBehavTree:OnPause()
	local _max = self:__GetActiveStackNum()
	for i = 1, _max do
		local _task = self:__PeekActiveStackTask(i)
		if _task and _task:CheckTaskState(LuaBehav_Define_TaskState.Running) then
			_task:OnPause()
		end
	end
end

-- 恢复行为树
function LuaBehav_RuntimeBehavTree:OnResume()
	local _max = self:__GetActiveStackNum()
	for i = 1, _max do
		local _task = self:__PeekActiveStackTask(i)
		if _task and _task:CheckTaskState(LuaBehav_Define_TaskState.Running) then
			_task:OnResume()
		end
	end
end

-- 清理
function LuaBehav_RuntimeBehavTree:OnDestroy()
	for _, _stack in pairs(self.activeStackList) do
		_stack:clear()
	end
	self.waitRepushStack:clear()
	for _, _runtimeTask in pairs(self.taskList) do
		_runtimeTask:Clear()
	end
	
	self.runtimeBehavMgr = nil
	self.__index = nil
	self.activeStackList = nil
	self.interruptionIndexList = nil
	self.variableDic = nil
	self.trigInterruptionStackNum = nil
	self.waitRepushStack = nil
	self.taskList = nil
	self.parentIndexDic = nil
	self.interruptionTaskDic = nil
	self.conditionalTaskList = nil
	self.conditionalStateList = nil
	self.conditionInterruptionParentIndexDic = nil
	self.__stackPopTag = nil
	self.__tmpTab_1 = nil
	self.__tmpTab_2 = nil
end

return LuaBehav_RuntimeBehavTree