---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jiangxuechen
--- DateTime: 2022/10/17 15:24
--- Describe: 筛选限制节点（只能接一个子节点）
---

---@class LuaBehav_RuntimeTask_Filter : LuaBehav_RuntimeTask
LuaBehav_RuntimeTask_Filter = class(LuaBehav_RuntimeTask, "LuaBehav_RuntimeTask_Filter")

function LuaBehav_RuntimeTask_Filter:IsForceReevaluateTask()
	return true
end

function LuaBehav_RuntimeTask_Filter:OnStart()
	--LogTools.LogByLevel(LogLevel.log, "限制解除", "LuaBehav_RuntimeTask_Filter:OnStart")
	self:__OnStart()
	
	self.__failuerWhenLimited = self.configTask.failureWhenLimited
	self.__countDownTime = self.configTask.countDown
	self.__numOfTimes = self.configTask.numOfTimes
	self.__filterType = self.configTask.filterType

	--if not self.__childTask then
	--	---@private
	--	---@type LuaBehav_RuntimeTask
	--	self.__childTask = self.behavTree:GetTask(self.childIndexList[1])
	--end

	---时间冷却类型在进入后一定是限制中
	--if self.__filterType == LuaBehav_Define_FilterDecoratType.CountDown then
	--	if not self.__inLimited then
	--		self:__Limit(true)
	--	end
	--end
	
end

---子节点退出的时候才进行限制
function LuaBehav_RuntimeTask_Filter:OnChildExit(_cnt, _childState)
	local _stateList = self.childStateList
	if #_stateList == 0 then return end
	if _cnt > #_stateList then return end


	if self.__filterType == LuaBehav_Define_FilterDecoratType.NumOfTimes then
		if not self.__numAcc then  --多次运行时需要保留次数记录，不能在OnStart里初始化次数
			self.__numAcc = 1
		else
			self.__numAcc = self.__numAcc + 1
		end

		if self.__numAcc >= self.__numOfTimes then
			self:__Limit(true)
		end
	elseif self.__filterType == LuaBehav_Define_FilterDecoratType.CountDown then
		self:__Limit(true)
	end
	_stateList[_cnt] = _childState
end

---帧尾进行强制重评估
---@public
function LuaBehav_RuntimeTask_Filter:ForceReevaluate()
	---不在限制中的时候需要重新评估
	if not self.__inLimited then return end
	--只有时间冷却的才需要重新评估
	if self.__filterType ~= LuaBehav_Define_FilterDecoratType.CountDown then return end
	---评估冷却时间没到的话结束评估
	if self:GetCurTimeCnt() - self.__startTime < self.__countDownTime then return end
	self:__Limit(false)
	--LogTools.LogByLevel(LogLevel.log, "限制解除", "self.__inLimited", self.__inLimited)
end

---执行限制
---@private
function LuaBehav_RuntimeTask_Filter:__Limit(_bool)
	self.__inLimited = _bool
	if not self.__failuerWhenLimited then
		self:SetHideStateToParent(_bool)
	end
	if self.__filterType == LuaBehav_Define_FilterDecoratType.CountDown then
		--时间冷却的情况，一进入就开始限制，此时子节点可能仍在running
		if _bool then
			self.__startTime = self:GetCurTimeCnt()
		else
			self.__startTime = nil
			self.__childTask = nil
		end
		self.__needReevaluate = _bool
	elseif self.__filterType == LuaBehav_Define_FilterDecoratType.NumOfTimes then
		--次数限制的情况，一定是子节点退出后才会发生次数变化，因此不需要强制退出
		--if _bool then
		--	self:SetForceState()
		--end
	end
	
end

-- 
function LuaBehav_RuntimeTask_Filter:GetDirectState(_preState)
	--LogTools.LogByLevel(LogLevel.log, "LuaBehav_RuntimeTask_Filter:GetDirectState", "self.__inLimited", self.__inLimited)
	if self.__inLimited and self.__failuerWhenLimited then
		if not self.__childTask then 
			self.__childTask = self.behavTree:GetTask(self.childIndexList[1])	
			return nil
		end
		
		if self.__childTask:CheckTaskState(LuaBehav_Define_TaskState.Running) then
			return nil
		end
		return LuaBehav_Define_TaskState.Failure
	end
	return nil
end

return LuaBehav_RuntimeTask_Filter